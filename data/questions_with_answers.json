{
    "items": [
        {
            "tags": [
                "python",
                "iterator",
                "generator",
                "yield"
            ],
            "owner": {
                "account_id": 9828,
                "reputation": 147854,
                "user_id": 18300,
                "user_type": "registered",
                "accept_rate": 92,
                "profile_image": "https://i.sstatic.net/jcyI4.jpg?s=256",
                "display_name": "Alex. S.",
                "link": "https://stackoverflow.com/users/18300/alex-s"
            },
            "is_answered": true,
            "view_count": 3454166,
            "protected_date": 1360547307,
            "accepted_answer_id": 231855,
            "answer_count": 52,
            "score": 13089,
            "last_activity_date": 1741436803,
            "creation_date": 1224800471,
            "last_edit_date": 1711253482,
            "question_id": 231767,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python",
            "title": "What does the &quot;yield&quot; keyword do in Python?",
            "body": "<p>What functionality does the <a href=\"https://docs.python.org/3/reference/simple_stmts.html#yield\" rel=\"noreferrer\"><code>yield</code></a> keyword in Python provide?</p>\n<p>For example, I'm trying to understand this code<sup><strong>1</strong></sup>:</p>\n<pre><code>def _get_child_candidates(self, distance, min_dist, max_dist):\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild  \n</code></pre>\n<p>And this is the caller:</p>\n<pre><code>result, candidates = [], [self]\nwhile candidates:\n    node = candidates.pop()\n    distance = node._get_dist(obj)\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\nreturn result\n</code></pre>\n<p>What happens when the method <code>_get_child_candidates</code> is called?\nIs a list returned? A single element? Is it called again? When will subsequent calls stop?</p>\n\n<hr />\n<sub>\n1. This piece of code was written by Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: <a href=\"https://well-adjusted.de/~jrspieker/mspace/\" rel=\"noreferrer\">Module mspace</a>.</sub> \n",
            "top_answer": "<p>To understand what <a href=\"https://docs.python.org/3/reference/simple_stmts.html#yield\" rel=\"noreferrer\"><code>yield</code></a> does, you must understand what <em><a href=\"https://docs.python.org/3/glossary.html#term-generator\" rel=\"noreferrer\">generators</a></em> are. And before you can understand generators, you must understand <em><a href=\"https://docs.python.org/3/glossary.html#term-iterable\" rel=\"noreferrer\">iterables</a></em>.</p>\n<h2>Iterables</h2>\n<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>\n<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3\n</code></pre>\n<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>\n<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>Everything you can use &quot;<code>for... in...</code>&quot; on is an iterable; <code>lists</code>, <code>strings</code>, files...</p>\n<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>\n<h2>Generators</h2>\n<p>Generators are <em><a href=\"https://docs.python.org/3/glossary.html#term-iterator\" rel=\"noreferrer\">iterators</a></em>, a kind of iterable <strong>you can only iterate over once</strong>. Generators do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>\n<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you <strong>cannot</strong> perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.</p>\n<h2>Yield</h2>\n<p><code>yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>\n<pre><code>&gt;&gt;&gt; def create_generator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = create_generator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\n&lt;generator object create_generator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n</code></pre>\n<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>\n<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky.</p>\n<p>Then, your code will continue from where it left off each time <code>for</code> uses the generator.</p>\n<p>Now the hard part:</p>\n<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting <code>yield</code>. That can be because the loop has come to an end, or because you no longer satisfy an <code>&quot;if/else&quot;</code>.</p>\n<hr />\n<h2>Your code explained</h2>\n<p><em>Generator:</em></p>\n<pre><code># Here you create the method of the node object that will return the generator\ndef _get_child_candidates(self, distance, min_dist, max_dist):\n\n    # Here is the code that will be called each time you use the generator object:\n\n    # If there is still a child of the node object on its left\n    # AND if the distance is ok, return the next child\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n\n    # If there is still a child of the node object on its right\n    # AND if the distance is ok, return the next child\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild\n\n    # If the function arrives here, the generator will be considered empty\n    # There are no more than two values: the left and the right children\n</code></pre>\n<p><em>Caller:</em></p>\n<pre><code># Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If the distance is ok, then you can fill in the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate to the candidate's list\n    # so the loop will keep running until it has looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n</code></pre>\n<p>This code contains several smart parts:</p>\n<ul>\n<li><p>The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p>\n</li>\n<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p>\n</li>\n</ul>\n<p>Usually, we pass a list to it:</p>\n<pre><code>&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n</code></pre>\n<p>But in your code, it gets a generator, which is good because:</p>\n<ol>\n<li>You don't need to read the values twice.</li>\n<li>You may have a lot of children and you don't want them all stored in memory.</li>\n</ol>\n<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</p>\n<p>You can stop here, or read a little bit to see an advanced use of a generator:</p>\n<h2>Controlling a generator exhaustion</h2>\n<pre><code>&gt;&gt;&gt; class Bank(): # Let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield &quot;$100&quot;\n&gt;&gt;&gt; hsbc = Bank() # When everything's ok the ATM gives you as much as you want\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It's even true for new ATMs\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\n&gt;&gt;&gt; for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n</code></pre>\n<p><strong>Note:</strong> For Python 3, use<code>print(corner_street_atm.__next__())</code> or <code>print(next(corner_street_atm))</code></p>\n<p>It can be useful for various things like controlling access to a resource.</p>\n<h2>Itertools, your best friend</h2>\n<p>The <code>itertools</code> module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? <code>Map / Zip</code> without creating another list?</p>\n<p>Then just <code>import itertools</code>.</p>\n<p>An example? Let's see the possible orders of arrival for a four-horse race:</p>\n<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n</code></pre>\n<h2>Understanding the inner mechanisms of iteration</h2>\n<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>\n<p>There is more about it in this article about <a href=\"https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm\" rel=\"noreferrer\">how <code>for</code> loops work</a>.</p>\n"
        },
        {
            "tags": [
                "python",
                "namespaces",
                "program-entry-point",
                "python-module",
                "idioms"
            ],
            "owner": {
                "account_id": 21259,
                "reputation": 184353,
                "user_id": 51518,
                "user_type": "registered",
                "accept_rate": 86,
                "profile_image": "https://www.gravatar.com/avatar/eb5a95cb1be342c4089183cd8232a7f2?s=256&d=identicon&r=PG",
                "display_name": "Devoted",
                "link": "https://stackoverflow.com/users/51518/devoted"
            },
            "is_answered": true,
            "view_count": 4928735,
            "protected_date": 1365246276,
            "accepted_answer_id": 419185,
            "answer_count": 40,
            "score": 8394,
            "last_activity_date": 1724383494,
            "creation_date": 1231301460,
            "last_edit_date": 1668391615,
            "question_id": 419163,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do",
            "title": "What does if __name__ == &quot;__main__&quot;: do?",
            "body": "<p>What does this do, and why should one include the <code>if</code> statement?</p>\n<pre class=\"lang-py prettyprint-override\"><code>if __name__ == &quot;__main__&quot;:\n    print(&quot;Hello, World!&quot;)\n</code></pre>\n<hr />\n<p><sub>If you are trying to close a question where someone should be using this idiom and isn't, consider closing as a duplicate of <a href=\"https://stackoverflow.com/questions/6523791\">Why is Python running my module when I import it, and how do I stop it?</a> instead. For questions where someone simply hasn't called any functions, or incorrectly expects a function named <code>main</code> to be used as an entry point automatically, use <a href=\"https://stackoverflow.com/questions/17257631\">Why doesn&#39;t the main() function run when I start a Python script? Where does the script start running?</a>.</sub></p>\n",
            "top_answer": "<h1>Short Answer</h1>\n<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>\n<ul>\n<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p>\n</li>\n<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p>\n</li>\n</ul>\n<h1>Long Answer</h1>\n<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>\n<p>Whenever the Python interpreter reads a source file, it does two things:</p>\n<ul>\n<li><p>it sets a few special variables like <code>__name__</code>, and then</p>\n</li>\n<li><p>it executes all of the code found in the file.</p>\n</li>\n</ul>\n<p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>\n<h2>Code Sample</h2>\n<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py</code>.</p>\n<pre><code># Suppose this is foo.py.\n\nprint(&quot;before import&quot;)\nimport math\n\nprint(&quot;before function_a&quot;)\ndef function_a():\n    print(&quot;Function A&quot;)\n\nprint(&quot;before function_b&quot;)\ndef function_b():\n    print(&quot;Function B {}&quot;.format(math.sqrt(100)))\n\nprint(&quot;before __name__ guard&quot;)\nif __name__ == '__main__':\n    function_a()\n    function_b()\nprint(&quot;after __name__ guard&quot;)\n</code></pre>\n<h2>Special Variables</h2>\n<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>\n<p><strong>When Your Module Is the Main Program</strong></p>\n<p>If you are running your module (the source file) as the main program, e.g.</p>\n<pre><code>python foo.py\n</code></pre>\n<p>the interpreter will assign the hard-coded string <code>&quot;__main__&quot;</code> to the <code>__name__</code> variable, i.e.</p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = &quot;__main__&quot; \n</code></pre>\n<p><strong>When Your Module Is Imported By Another</strong></p>\n<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>\n<pre><code># Suppose this is in some other main program.\nimport foo\n</code></pre>\n<p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>&quot;foo&quot;</code> from the import statement to the <code>__name__</code> variable, i.e.</p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when it's imported from another module.\n__name__ = &quot;foo&quot;\n</code></pre>\n<h2>Executing the Module's Code</h2>\n<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>\n<p><strong>Always</strong></p>\n<ol>\n<li><p>It prints the string <code>&quot;before import&quot;</code> (without quotes).</p>\n</li>\n<li><p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p>\n</li>\n</ol>\n<pre><code># Find and load a module given its string name, &quot;math&quot;,\n# then assign it to a local variable called math.\nmath = __import__(&quot;math&quot;)\n</code></pre>\n<ol start=\"3\">\n<li><p>It prints the string <code>&quot;before function_a&quot;</code>.</p>\n</li>\n<li><p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p>\n</li>\n<li><p>It prints the string <code>&quot;before function_b&quot;</code>.</p>\n</li>\n<li><p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p>\n</li>\n<li><p>It prints the string <code>&quot;before __name__ guard&quot;</code>.</p>\n</li>\n</ol>\n<p><strong>Only When Your Module Is the Main Program</strong></p>\n<ol start=\"8\">\n<li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>&quot;__main__&quot;</code> and it calls the two functions, printing the strings <code>&quot;Function A&quot;</code> and <code>&quot;Function B 10.0&quot;</code>.</li>\n</ol>\n<p><strong>Only When Your Module Is Imported by Another</strong></p>\n<ol start=\"8\">\n<li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>&quot;foo&quot;</code>, not <code>&quot;__main__&quot;</code>, and it'll skip the body of the <code>if</code> statement.</li>\n</ol>\n<p><strong>Always</strong></p>\n<ol start=\"9\">\n<li>It will print the string <code>&quot;after __name__ guard&quot;</code> in both situations.</li>\n</ol>\n<p><em><strong>Summary</strong></em></p>\n<p>In summary, here's what'd be printed in the two cases:</p>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n</code></pre>\n<h2>Why Does It Work This Way?</h2>\n<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</p>\n<ul>\n<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p>\n</li>\n<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p>\n</li>\n<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p>\n</li>\n</ul>\n<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</p>\n<h2>Food for Thought</h2>\n<ul>\n<li><p>Question: Can I have multiple <code>__name__</code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.</p>\n</li>\n<li><p>Suppose the following is in <code>foo2.py</code>.  What happens if you say <code>python foo2.py</code> on the command-line? Why?</p>\n</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo2 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nif __name__ == &quot;__main__&quot;:\n    print(&quot;m1&quot;)\n    function_a()\n    print(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n      \n</code></pre>\n<ul>\n<li>Now, figure out what will happen in <code>foo3.py</code> (having removed the <code>__name__</code> check):</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo3 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nprint(&quot;m1&quot;)\nfunction_a()\nprint(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n</code></pre>\n<ul>\n<li>What will this do when used as a script?  When imported as a module?</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is in foo4.py\n__name__ = &quot;__main__&quot;\n\ndef bar():\n    print(&quot;bar&quot;)\n    \nprint(&quot;before __name__ guard&quot;)\nif __name__ == &quot;__main__&quot;:\n    bar()\nprint(&quot;after __name__ guard&quot;)\n</code></pre>\n"
        },
        {
            "tags": [
                "python",
                "operators",
                "conditional-operator"
            ],
            "owner": {
                "account_id": 21259,
                "reputation": 184353,
                "user_id": 51518,
                "user_type": "registered",
                "accept_rate": 86,
                "profile_image": "https://www.gravatar.com/avatar/eb5a95cb1be342c4089183cd8232a7f2?s=256&d=identicon&r=PG",
                "display_name": "Devoted",
                "link": "https://stackoverflow.com/users/51518/devoted"
            },
            "is_answered": true,
            "view_count": 3090037,
            "protected_date": 1370841342,
            "accepted_answer_id": 394814,
            "answer_count": 32,
            "score": 8091,
            "last_activity_date": 1747560370,
            "creation_date": 1230366738,
            "last_edit_date": 1654483962,
            "question_id": 394809,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator",
            "title": "Does Python have a ternary conditional operator?",
            "body": "<p>Is there a <a href=\"https://en.wikipedia.org/wiki/%3F:#Python\" rel=\"noreferrer\">ternary conditional operator</a> in Python?</p>\n",
            "top_answer": "<p>Yes, it was <a href=\"https://mail.python.org/pipermail/python-dev/2005-September/056846.html\" rel=\"noreferrer\" title=\"[Python-Dev] Conditional Expression Resolution\">added</a> in version 2.5. The expression syntax is:</p>\n<pre class=\"lang-py prettyprint-override\"><code>a if condition else b\n</code></pre>\n<p>First <code>condition</code> is evaluated, then exactly one of either <code>a</code> or <code>b</code> is evaluated and returned based on the <a href=\"https://en.wikipedia.org/wiki/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean</a> value of <code>condition</code>. If <code>condition</code> evaluates to <code>True</code>, then <code>a</code> is evaluated and returned but <code>b</code> is ignored, or else when <code>b</code> is evaluated and returned but <code>a</code> is ignored.</p>\n<p>This allows short-circuiting because when <code>condition</code> is true only <code>a</code> is evaluated and <code>b</code> is not evaluated at all, but when <code>condition</code> is false only <code>b</code> is evaluated and <code>a</code> is not evaluated at all.</p>\n<p>For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; 'true' if True else 'false'\n'true'\n&gt;&gt;&gt; 'true' if False else 'false'\n'false'\n</code></pre>\n<p>Note that conditionals are an <em>expression</em>, not a <em>statement</em>. This means you can't use <strong>statements</strong> such as <code>pass</code>, or assignments with <code>=</code> (or &quot;augmented&quot; assignments like <code>+=</code>), within a conditional <strong>expression</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; pass if False else pass\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    pass if False else pass\n         ^\nSyntaxError: invalid syntax\n\n&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`\n&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but\n&gt;&gt;&gt; # it can't be on the left-hand side of `=`.\n&gt;&gt;&gt; x = 1 if False else y = 2\n  File &quot;&lt;stdin&gt;&quot;, line 1\nSyntaxError: cannot assign to conditional expression\n\n&gt;&gt;&gt; # If we parenthesize it instead...\n&gt;&gt;&gt; (x = 1) if False else (y = 2)\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    (x = 1) if False else (y = 2)\n       ^\nSyntaxError: invalid syntax\n</code></pre>\n<p>(In 3.8 and above, the <code>:=</code> &quot;walrus&quot; operator allows simple assignment of values <em>as an expression</em>, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)</p>\n<p>Similarly, because it is an expression, the <code>else</code> part is <em>mandatory</em>:</p>\n<pre><code># Invalid syntax: we didn't specify what the value should be if the \n# condition isn't met. It doesn't matter if we can verify that\n# ahead of time.\na if True\n</code></pre>\n<p>You can, however, use conditional expressions to assign a variable like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code>x = a if True else b\n</code></pre>\n<p>Or for example to return a value:</p>\n<pre><code># Of course we should just use the standard library `max`;\n# this is just for demonstration purposes.\ndef my_max(a, b):\n    return a if a &gt; b else b\n</code></pre>\n<p>Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will <em>do the same thing</em> with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to <em>do something different</em> depending on the condition, then use a normal <code>if</code> <strong>statement</strong> instead.</p>\n<hr />\n<p>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</p>\n<ul>\n<li>The order of the arguments is different from those of the classic <code>condition ? a : b</code> ternary operator from many other languages (such as <a href=\"https://en.wikipedia.org/wiki/C_%28programming_language%29\" rel=\"noreferrer\">C</a>, <a href=\"https://en.wikipedia.org/wiki/C%2B%2B\" rel=\"noreferrer\">C++</a>, <a href=\"https://en.wikipedia.org/wiki/Go_%28programming_language%29\" rel=\"noreferrer\">Go</a>, <a href=\"https://en.wikipedia.org/wiki/Perl\" rel=\"noreferrer\">Perl</a>, <a href=\"https://en.wikipedia.org/wiki/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby</a>, <a href=\"https://en.wikipedia.org/wiki/Java_%28programming_language%29\" rel=\"noreferrer\">Java</a>, <a href=\"https://en.wikipedia.org/wiki/JavaScript\" rel=\"noreferrer\">JavaScript</a>, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</li>\n<li>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</li>\n<li>Stylistic reasons. (Although the 'inline <code>if</code>' can be <em>really</em> useful, and make your script more concise, it really does complicate your code)</li>\n</ul>\n<p>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, <code>x = 4 if b &gt; 8 else 9</code> is read aloud as <code>x will be 4 if b is greater than 8 otherwise 9</code>.</p>\n<p>Official documentation:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#conditional-expressions\" rel=\"noreferrer\" title=\"Conditional expressions\">Conditional expressions</a></li>\n<li><a href=\"https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator\" rel=\"noreferrer\" title=\"Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?\">Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?</a></li>\n</ul>\n"
        },
        {
            "tags": [
                "python",
                "oop",
                "metaclass",
                "python-class",
                "python-datamodel"
            ],
            "owner": {
                "account_id": 6018,
                "reputation": 599371,
                "user_id": 9951,
                "user_type": "registered",
                "accept_rate": 78,
                "profile_image": "https://i.sstatic.net/CIFG8.png?s=256",
                "display_name": "Bite code",
                "link": "https://stackoverflow.com/users/9951/bite-code"
            },
            "is_answered": true,
            "view_count": 1239777,
            "protected_date": 1350585760,
            "accepted_answer_id": 100146,
            "answer_count": 26,
            "score": 7507,
            "last_activity_date": 1748620333,
            "creation_date": 1221804646,
            "last_edit_date": 1675831759,
            "question_id": 100003,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python",
            "title": "What are metaclasses in Python?",
            "body": "<p>What are <a href=\"https://docs.python.org/3/reference/datamodel.html#metaclasses\" rel=\"noreferrer\">metaclasses</a>? What are they used for?</p>\n",
            "top_answer": "<h1>Classes as objects</h1>\n<p>Prior to delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.</p>\n<p>In most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:</p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n\n&gt;&gt;&gt; my_object = ObjectCreator()\n&gt;&gt;&gt; print(my_object)\n    &lt;__main__.ObjectCreator object at 0x8974f2c&gt;\n</code></pre>\n<p>But classes are more than that in Python. <strong>Classes are objects too.</strong></p>\n<p>Yes, objects.</p>\n<p>When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the <code>class</code> keyword, Python creates an <strong>object</strong> out of the &quot;description&quot; of the class that follows. Thus, the following instruction</p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n</code></pre>\n<p>...creates an <em>object</em> with the name <code>ObjectCreator</code>!</p>\n<p>This object (the class) is itself capable of creating objects (called <em>instances</em>).</p>\n<p>But still, it's an object. Therefore, like all objects:</p>\n<ul>\n<li><p>you can assign it to a variable<sup>1</sup></p>\n<pre><code>JustAnotherVariable = ObjectCreator\n</code></pre>\n</li>\n<li><p>you can attach attributes to it</p>\n<pre><code>ObjectCreator.class_attribute = 'foo'\n</code></pre>\n</li>\n<li><p>you can pass it as a function parameter</p>\n<pre><code>print(ObjectCreator)\n</code></pre>\n</li>\n</ul>\n<p><sup>1</sup> Note that merely assigning it to another variable doesn't change the class's <code>__name__</code>, i.e.,</p>\n<pre><code>&gt;&gt;&gt; print(JustAnotherVariable)\n    &lt;class '__main__.ObjectCreator'&gt;\n\n&gt;&gt;&gt; print(JustAnotherVariable())\n    &lt;__main__.ObjectCreator object at 0x8997b4c&gt;\n</code></pre>\n\n<h1>Creating classes dynamically</h1>\n<p>Since classes are objects, you can create them on the fly, like any object.</p>\n<p>First, you can create a class in a function using <code>class</code>:</p>\n<pre><code>&gt;&gt;&gt; def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n\n&gt;&gt;&gt; MyClass = choose_class('foo')\n\n&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(MyClass()) # you can create an object from this class\n    &lt;__main__.Foo object at 0x89c6d4c&gt;\n</code></pre>\n<p>But it's not so dynamic, since you still have to write the whole class yourself.</p>\n<p>Since classes are objects, they must be generated by something.</p>\n<p>When you use the <code>class</code> keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually.</p>\n<p>Remember the function <code>type</code>? The good old function that lets you know what\ntype an object is:</p>\n<pre><code>&gt;&gt;&gt; print(type(1))\n    &lt;class 'int'&gt;\n\n&gt;&gt;&gt; print(type(&quot;1&quot;))\n    &lt;class 'str'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator))\n    &lt;class 'type'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator()))\n    &lt;class '__main__.ObjectCreator'&gt;\n</code></pre>\n<p>Well, <a href=\"http://docs.python.org/2/library/functions.html#type\" rel=\"noreferrer\"><code>type</code></a> also has a completely different ability: it can create classes on the fly. <code>type</code> can take the description of a class as parameters,\nand return a class.</p>\n<p>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python)</p>\n<p><code>type</code> works this way:</p>\n<pre><code>type(name, bases, attrs)\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><strong><code>name</code></strong>: name of the class</li>\n<li><strong><code>bases</code></strong>: tuple of the parent class (for inheritance, can be empty)</li>\n<li><strong><code>attrs</code></strong>: dictionary containing attributes names and values</li>\n</ul>\n<p>e.g.:</p>\n<pre><code>&gt;&gt;&gt; class MyShinyClass(object):\n...     pass\n</code></pre>\n<p>can be created manually this way:</p>\n<pre><code>&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n&gt;&gt;&gt; print(MyShinyClass)\n    &lt;class '__main__.MyShinyClass'&gt;\n\n&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class\n    &lt;__main__.MyShinyClass object at 0x8997cec&gt;\n</code></pre>\n<p>You'll notice that we use <code>MyShinyClass</code> as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things.</p>\n<p><code>type</code> accepts a dictionary to define the attributes of the class. So:</p>\n<pre><code>&gt;&gt;&gt; class Foo(object):\n...     bar = True\n</code></pre>\n<p>Can be translated to:</p>\n<pre><code>&gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})\n</code></pre>\n<p>And used as a normal class:</p>\n<pre><code>&gt;&gt;&gt; print(Foo)\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(Foo.bar)\n    True\n\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; print(f)\n    &lt;__main__.Foo object at 0x8a9b84c&gt;\n\n&gt;&gt;&gt; print(f.bar)\n    True\n</code></pre>\n<p>And of course, you can inherit from it, so:</p>\n<pre><code>&gt;&gt;&gt; class FooChild(Foo):\n...     pass\n</code></pre>\n<p>would be:</p>\n<pre><code>&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})\n&gt;&gt;&gt; print(FooChild)\n    &lt;class '__main__.FooChild'&gt;\n\n&gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo\n    True\n</code></pre>\n<p>Eventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute.</p>\n<pre><code>&gt;&gt;&gt; def echo_bar(self):\n...     print(self.bar)\n\n&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n\n&gt;&gt;&gt; hasattr(Foo, 'echo_bar')\n    False\n\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')\n    True\n\n&gt;&gt;&gt; my_foo = FooChild()\n&gt;&gt;&gt; my_foo.echo_bar()\n    True\n</code></pre>\n<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</p>\n<pre><code>&gt;&gt;&gt; def echo_bar_more(self):\n...     print('yet another method')\n\n&gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar_more')\n    True\n</code></pre>\n<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</p>\n<p>This is what Python does when you use the keyword <code>class</code>, and it does so by using a metaclass.</p>\n<h1>What are metaclasses (finally)</h1>\n<p>Metaclasses are the 'stuff' that creates classes.</p>\n<p>You define classes in order to create objects, right?</p>\n<p>But we learned that Python classes are objects.</p>\n<p>Well, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way:</p>\n<pre><code>MyClass = MetaClass()\nmy_object = MyClass()\n</code></pre>\n<p>You've seen that <code>type</code> lets you do something like this:</p>\n<pre><code>MyClass = type('MyClass', (), {})\n</code></pre>\n<p>It's because the function <code>type</code> is in fact a metaclass. <code>type</code> is the\nmetaclass Python uses to create all classes behind the scenes.</p>\n<p>Now you wonder &quot;why the heck is it written in lowercase, and not <code>Type</code>?&quot;</p>\n<p>Well, I guess it's a matter of consistency with <code>str</code>, the class that creates\nstrings objects, and <code>int</code> the class that creates integer objects. <code>type</code> is\njust the class that creates class objects.</p>\n<p>You see that by checking the <code>__class__</code> attribute.</p>\n<p>Everything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class:</p>\n<pre><code>&gt;&gt;&gt; age = 35\n&gt;&gt;&gt; age.__class__\n    &lt;type 'int'&gt;\n\n&gt;&gt;&gt; name = 'bob'\n&gt;&gt;&gt; name.__class__\n    &lt;type 'str'&gt;\n\n&gt;&gt;&gt; def foo(): pass\n&gt;&gt;&gt; foo.__class__\n    &lt;type 'function'&gt;\n\n&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; b = Bar()\n&gt;&gt;&gt; b.__class__\n    &lt;class '__main__.Bar'&gt;\n</code></pre>\n<p>Now, what is the <code>__class__</code> of any <code>__class__</code> ?</p>\n<pre><code>&gt;&gt;&gt; age.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; name.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; foo.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; b.__class__.__class__\n    &lt;type 'type'&gt;\n</code></pre>\n<p>So, a metaclass is just the stuff that creates class objects.</p>\n<p>You can call it a 'class factory' if you wish.</p>\n<p><code>type</code> is the built-in metaclass Python uses, but of course, you can create your\nown metaclass.</p>\n<h1>The <a href=\"http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__\" rel=\"noreferrer\"><code>__metaclass__</code></a> attribute</h1>\n<p>In Python 2, you can add a <code>__metaclass__</code> attribute when you write a class (see next section for the Python 3 syntax):</p>\n<pre><code>class Foo(object):\n    __metaclass__ = something...\n    [...]\n</code></pre>\n<p>If you do so, Python will use the metaclass to create the class <code>Foo</code>.</p>\n<p>Careful, it's tricky.</p>\n<p>You write <code>class Foo(object)</code> first, but the class object <code>Foo</code> is not created\nin memory yet.</p>\n<p>Python will look for <code>__metaclass__</code> in the class definition. If it finds it,\nit will use it to create the class object <code>Foo</code>. If it doesn't, it will use\n<code>type</code> to create the class.</p>\n<p>Read that several times.</p>\n<p>When you do:</p>\n<pre><code>class Foo(Bar):\n    pass\n</code></pre>\n<p>Python does the following:</p>\n<p>Is there a <code>__metaclass__</code> attribute in <code>Foo</code>?</p>\n<p>If yes, create in-memory a class object (I said a class object, stay with me here), with the name <code>Foo</code> by using what is in <code>__metaclass__</code>.</p>\n<p>If Python can't find <code>__metaclass__</code>, it will look for a <code>__metaclass__</code> at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</p>\n<p>Then if it can't find any <code>__metaclass__</code> at all, it will use the <code>Bar</code>'s (the first parent) own metaclass (which might be the default <code>type</code>) to create the class object.</p>\n<p>Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.</p>\n<p>Now the big question is, what can you put in <code>__metaclass__</code>?</p>\n<p>The answer is something that can create a class.</p>\n<p>And what can create a class? <code>type</code>, or anything that subclasses or uses it.</p>\n<h1>Metaclasses in Python 3</h1>\n<p>The syntax to set the metaclass has been changed in Python 3:</p>\n<pre><code>class Foo(object, metaclass=something):\n    ...\n</code></pre>\n<p>i.e. the <code>__metaclass__</code> attribute is no longer used, in favor of a keyword argument in the list of base classes.</p>\n<p>The behavior of metaclasses however stays <a href=\"https://www.python.org/dev/peps/pep-3115/\" rel=\"noreferrer\">largely the same</a>.</p>\n<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</p>\n<pre><code>class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\n    ...\n</code></pre>\n<p>Read the section below for how Python handles this.</p>\n<h1>Custom metaclasses</h1>\n<p>The main purpose of a metaclass is to change the class automatically,\nwhen it's created.</p>\n<p>You usually do this for APIs, where you want to create classes matching the\ncurrent context.</p>\n<p>Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set <code>__metaclass__</code> at the module level.</p>\n<p>This way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase.</p>\n<p>Luckily, <code>__metaclass__</code> can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful).</p>\n<p>So we will start with a simple example, by using a function.</p>\n<pre><code># the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attrs):\n    &quot;&quot;&quot;\n      Return a class object, with the list of its attribute turned\n      into uppercase.\n    &quot;&quot;&quot;\n    # pick up any attribute that doesn't start with '__' and uppercase it\n    uppercase_attrs = {\n        attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n        for attr, v in future_class_attrs.items()\n    }\n\n    # let `type` do the class creation\n    return type(future_class_name, future_class_parents, uppercase_attrs)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with &quot;object&quot; though\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with &quot;object&quot; children\n    bar = 'bip'\n</code></pre>\n<p>Let's check:</p>\n<pre><code>&gt;&gt;&gt; hasattr(Foo, 'bar')\n    False\n\n&gt;&gt;&gt; hasattr(Foo, 'BAR')\n    True\n\n&gt;&gt;&gt; Foo.BAR\n    'bip'\n</code></pre>\n<p>Now, let's do exactly the same, but using a real class for a metaclass:</p>\n<pre><code># remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type):\n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(\n        upperattr_metaclass,\n        future_class_name,\n        future_class_parents,\n        future_class_attrs\n    ):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in future_class_attrs.items()\n        }\n        return type(future_class_name, future_class_parents, uppercase_attrs)\n</code></pre>\n<p>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type(clsname, bases, uppercase_attrs)\n</code></pre>\n<p>You may have noticed the extra argument <code>cls</code>. There is\nnothing special about it: <code>__new__</code> always receives the class it's defined in, as the first parameter. Just like you have <code>self</code> for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.</p>\n<p>But this is not proper OOP. We are calling <code>type</code> directly and we aren't overriding or calling the parent's <code>__new__</code>. Let's do that instead:</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type.__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>We can make it even cleaner by using <code>super</code>, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n\n        # Python 2 requires passing arguments to super:\n        return super(UpperAttrMetaclass, cls).__new__(\n            cls, clsname, bases, uppercase_attrs)\n\n        # Python 3 can use no-arg super() which infers them:\n        return super().__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:</p>\n<pre><code>class Foo(object, metaclass=MyMetaclass, kwarg1=value1):\n    ...\n</code></pre>\n<p>It translates to this in the metaclass to use it:</p>\n<pre><code>class MyMetaclass(type):\n    def __new__(cls, clsname, bases, dct, kwarg1=default):\n        ...\n</code></pre>\n<p>That's it. There is really nothing more about metaclasses.</p>\n<p>The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as <code>__dict__</code>, etc.</p>\n<p>Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple:</p>\n<ul>\n<li>intercept a class creation</li>\n<li>modify the class</li>\n<li>return the modified class</li>\n</ul>\n<h1>Why would you use metaclasses classes instead of functions?</h1>\n<p>Since <code>__metaclass__</code> can accept any callable, why would you use a class\nsince it's obviously more complicated?</p>\n<p>There are several reasons to do so:</p>\n<ul>\n<li>The intention is clear. When you read <code>UpperAttrMetaclass(type)</code>, you know\nwhat's going to follow</li>\n<li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</li>\n<li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</li>\n<li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.</li>\n<li>You can hook on <code>__new__</code>, <code>__init__</code> and <code>__call__</code>. Which will allow you to do different stuff, Even if usually you can do it all in <code>__new__</code>,\nsome people are just more comfortable using <code>__init__</code>.</li>\n<li>These are called metaclasses, damn it! It must mean something!</li>\n</ul>\n<h1>Why would you use metaclasses?</h1>\n<p>Now the big question. Why would you use some obscure error-prone feature?</p>\n<p>Well, usually you don't:</p>\n<blockquote>\n<p>Metaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why).</p>\n</blockquote>\n<p><em>Python Guru Tim Peters</em></p>\n<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</p>\n<pre><code>class Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n</code></pre>\n<p>But if you do this:</p>\n<pre><code>person = Person(name='bob', age='35')\nprint(person.age)\n</code></pre>\n<p>It won't return an <code>IntegerField</code> object. It will return an <code>int</code>, and can even take it directly from the database.</p>\n<p>This is possible because <code>models.Model</code> defines <code>__metaclass__</code> and\nit uses some magic that will turn the <code>Person</code> you just defined with simple statements\ninto a complex hook to a database field.</p>\n<p>Django makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes.</p>\n<h1>The last word</h1>\n<p>First, you know that classes are objects that can create instances.</p>\n<p>Well, in fact, classes are themselves instances. Of metaclasses.</p>\n<pre><code>&gt;&gt;&gt; class Foo(object): pass\n&gt;&gt;&gt; id(Foo)\n    142630324\n</code></pre>\n<p>Everything is an object in Python, and they are all either instance of classes\nor instances of metaclasses.</p>\n<p>Except for <code>type</code>.</p>\n<p><code>type</code> is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel.</p>\n<p>Secondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques:</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Monkey_patch\" rel=\"noreferrer\">monkey patching</a></li>\n<li>class decorators</li>\n</ul>\n<p>99% of the time you need class alteration, you are better off using these.</p>\n<p>But 98% of the time, you don't need class alteration at all.</p>\n"
        },
        {
            "tags": [
                "python",
                "file",
                "file-exists"
            ],
            "owner": {
                "account_id": 8617,
                "reputation": 80471,
                "user_id": 15616,
                "user_type": "registered",
                "accept_rate": 83,
                "profile_image": "https://www.gravatar.com/avatar/1d502f7932af0a41d8ff6ab5d9cf3406?s=256&d=identicon&r=PG",
                "display_name": "spence91",
                "link": "https://stackoverflow.com/users/15616/spence91"
            },
            "is_answered": true,
            "view_count": 5968609,
            "protected_date": 1370841219,
            "answer_count": 41,
            "score": 7311,
            "last_activity_date": 1752766259,
            "creation_date": 1221656100,
            "last_edit_date": 1616874145,
            "question_id": 82831,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions",
            "title": "How do I check whether a file exists without exceptions?",
            "body": "<p>How do I check whether a file exists or not, without using the <a href=\"https://docs.python.org/3.6/reference/compound_stmts.html#try\" rel=\"noreferrer\"><code>try</code></a> statement?</p>\n",
            "top_answer": "<p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()</code>, it's safer to use a <code>try</code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</p>\n<p>If you're not planning to open the file immediately, you can use <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\"><code>os.path.isfile</code></a> if you need to be sure it's a file.</p>\n<blockquote>\n<p>Return <code>True</code> if path is an existing regular file. This follows symbolic links, so both <a href=\"https://docs.python.org/library/os.path.html#os.path.islink\" rel=\"noreferrer\">islink()</a> and <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\">isfile()</a> can be true for the same path.</p>\n</blockquote>\n<pre><code>import os.path\nos.path.isfile(fname)\n</code></pre>\n<h3><code>pathlib</code></h3>\n<p>Starting with Python 3.4, the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file\" rel=\"noreferrer\"><code>pathlib</code> module</a> offers an object-oriented approach (backported to <code>pathlib2</code> in Python 2.7):</p>\n<pre><code>from pathlib import Path\n\nmy_file = Path(&quot;/path/to/file&quot;)\nif my_file.is_file():\n    # file exists\n</code></pre>\n<p>To check a directory, do:</p>\n<pre><code>if my_file.is_dir():\n    # directory exists\n</code></pre>\n<p>To check whether a <code>Path</code> object exists independently of whether is it a file or directory, use <code>exists()</code>:</p>\n<pre><code>if my_file.exists():\n    # path exists\n</code></pre>\n<p>You can also use <code>resolve(strict=True)</code> in a <code>try</code> block:</p>\n<pre><code>try:\n    my_abs_path = my_file.resolve(strict=True)\nexcept FileNotFoundError:\n    # doesn't exist\nelse:\n    # exists\n</code></pre>\n"
        },
        {
            "tags": [
                "python",
                "dictionary",
                "merge"
            ],
            "owner": {
                "account_id": 2310,
                "reputation": 127151,
                "user_id": 3207,
                "user_type": "registered",
                "accept_rate": 100,
                "profile_image": "https://www.gravatar.com/avatar/b1f36e554be0e1ae19f9a74d6ece9107?s=256&d=identicon&r=PG",
                "display_name": "Carl Meyer",
                "link": "https://stackoverflow.com/users/3207/carl-meyer"
            },
            "is_answered": true,
            "view_count": 3605744,
            "protected_date": 1392127410,
            "accepted_answer_id": 61116810,
            "answer_count": 45,
            "score": 7100,
            "last_activity_date": 1752656041,
            "creation_date": 1220341470,
            "last_edit_date": 1676185398,
            "question_id": 38987,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python",
            "title": "How do I merge two dictionaries in a single expression in Python?",
            "body": "<p>I want to merge two dictionaries into a new dictionary.</p>\n<pre><code>x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\nz = merge(x, y)\n\n&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n</code></pre>\n<p>Whenever a key <code>k</code> is present in both dictionaries, only the value <code>y[k]</code> should be kept.</p>\n",
            "top_answer": "<h2>How can I merge two Python dictionaries in a single expression?</h2>\n<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes values from <code>y</code>, replacing those from <code>x</code>.</p>\n<ul>\n<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\"><code>PEP-584</code></a>, <a href=\"https://bugs.python.org/issue36144\" rel=\"noreferrer\">discussed here</a>):</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x | y\n</code></pre>\n</li>\n<li><p>In Python 3.5 or greater:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n</code></pre>\n</li>\n<li><p>In Python 2, (or 3.4 or lower) write a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n</code></pre>\n</li>\n</ul>\n<h3>Explanation</h3>\n<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:</p>\n<pre class=\"lang-py prettyprint-override\"><code>x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\n</code></pre>\n<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dictionary's values overwriting those from the first.</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n</code></pre>\n<p>A new syntax for this, proposed in <a href=\"https://www.python.org/dev/peps/pep-0448\" rel=\"noreferrer\">PEP 448</a> and <a href=\"https://mail.python.org/pipermail/python-dev/2015-February/138564.html\" rel=\"noreferrer\">available as of Python 3.5</a>, is</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n</code></pre>\n<p>And it is indeed a single expression.</p>\n<p>Note that we can merge in with literal notation as well:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, 'foo': 1, 'bar': 2, **y}\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}\n</code></pre>\n<p>It is now showing as implemented in the <a href=\"https://www.python.org/dev/peps/pep-0478/#features-for-3-5\" rel=\"noreferrer\">release schedule for 3.5, PEP 478</a>, and it has now made its way into the <a href=\"https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations\" rel=\"noreferrer\">What's New in Python 3.5</a> document.</p>\n<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x.copy()\nz.update(y) # which returns None since it mutates z\n</code></pre>\n<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>b</code> will point to <code>3</code> in our final result.</p>\n<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>\n<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while the correct approach is to put it in a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;\n    z = x.copy()\n    z.update(y)\n    return z\n</code></pre>\n<p>and then you have a single expression:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n</code></pre>\n<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_dicts(*dict_args):\n    &quot;&quot;&quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    &quot;&quot;&quot;\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n</code></pre>\n<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a</code> to <code>g</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_dicts(a, b, c, d, e, f, g) \n</code></pre>\n<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>, and so on.</p>\n<h2>Critiques of Other Answers</h2>\n<p>Don't use what you see in the formerly accepted answer:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x.items() + y.items())\n</code></pre>\n<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists -</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'\n</code></pre>\n<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power.</p>\n<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() | b.items())\n</code></pre>\n<p>This example demonstrates what happens when values are unhashable:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': []}\n&gt;&gt;&gt; y = {'b': []}\n&gt;&gt;&gt; dict(x.items() | y.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n</code></pre>\n<p>Here's an example where <code>y</code> should have precedence, but instead the value from <code>x</code> is retained due to the arbitrary order of sets:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': 2}\n&gt;&gt;&gt; y = {'a': 1}\n&gt;&gt;&gt; dict(x.items() | y.items())\n{'a': 2}\n</code></pre>\n<p>Another hack you should not use:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x, **y)\n</code></pre>\n<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</p>\n<p>Here's an example of the usage being <a href=\"https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff\" rel=\"noreferrer\">remediated in django</a>.</p>\n<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a, **b)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: keyword arguments must be strings\n</code></pre>\n<p>From the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099459.html\" rel=\"noreferrer\">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>\n<blockquote>\n<p>I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\nx.update(y) and return x&quot;. Personally, I find it more despicable than\ncool.</p>\n</blockquote>\n<p>It is my understanding (as well as the understanding of the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099485.html\" rel=\"noreferrer\">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dictionaries for readability purposes, e.g.:</p>\n<pre class=\"lang-py prettyprint-override\"><code>dict(a=1, b=10, c=11)\n</code></pre>\n<p>instead of</p>\n<pre class=\"lang-py prettyprint-override\"><code>{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n<h2>Response to comments</h2>\n<blockquote>\n<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.</p>\n</blockquote>\n<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>\n<pre><code>&gt;&gt;&gt; foo(**{('a', 'b'): None})\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: foo() keywords must be strings\n&gt;&gt;&gt; dict(**{('a', 'b'): None})\n{('a', 'b'): None}\n</code></pre>\n<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>\n<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>\n<p>More comments:</p>\n<blockquote>\n<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts.</p>\n</blockquote>\n<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>\n<blockquote>\n<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</p>\n</blockquote>\n<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>\n<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() &amp; y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n</code></pre>\n<p>Usage:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}\n&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\n{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}\n</code></pre>\n<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href=\"https://stackoverflow.com/a/24088493/541136\">my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;</a>.</p>\n<h2>Less Performant But Correct Ad-hocs</h2>\n<p>These approaches are less performant, but they will provide correct behavior.\nThey will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dictionaries have precedence)</p>\n<p>You can also chain the dictionaries manually inside a <a href=\"https://www.python.org/dev/peps/pep-0274/\" rel=\"noreferrer\">dict comprehension</a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n</code></pre>\n<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>\n<pre class=\"lang-py prettyprint-override\"><code>dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n</code></pre>\n<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n</code></pre>\n<h2>Performance Analysis</h2>\n<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)</p>\n<pre class=\"lang-py prettyprint-override\"><code>from timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys('abcdefg')\ny = dict.fromkeys('efghijk')\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n</code></pre>\n<p>In Python 3.8.1, NixOS:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n</code></pre>\n<pre class=\"lang-sh prettyprint-override\"><code>$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\n</code></pre>\n<h2>Resources on Dictionaries</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302\">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535\">Answer on how to add new keys to a dictionary</a></li>\n<li><a href=\"https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067\">Mapping two lists into a dictionary</a></li>\n<li><a href=\"https://docs.python.org/3/tutorial/datastructures.html#dictionaries\" rel=\"noreferrer\">The official Python docs on dictionaries</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=66P5FMkWoVU\" rel=\"noreferrer\">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>\n<li><a href=\"https://www.youtube.com/watch?v=npw4s1QTmPg\" rel=\"noreferrer\">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>\n</ul>\n"
        },
        {
            "tags": [
                "python",
                "shell",
                "terminal",
                "subprocess",
                "command"
            ],
            "owner": {
                "account_id": 9288,
                "reputation": 64479,
                "user_id": 17085,
                "user_type": "registered",
                "accept_rate": 89,
                "profile_image": "https://www.gravatar.com/avatar/d386a6f2f3dda7bcf7f1e11c2171946b?s=256&d=identicon&r=PG",
                "display_name": "freshWoWer",
                "link": "https://stackoverflow.com/users/17085/freshwower"
            },
            "is_answered": true,
            "view_count": 5131119,
            "protected_date": 1366143800,
            "accepted_answer_id": 89243,
            "answer_count": 66,
            "score": 6264,
            "last_activity_date": 1703656296,
            "creation_date": 1221701730,
            "last_edit_date": 1671066365,
            "question_id": 89228,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command",
            "title": "How do I execute a program or call a system command?",
            "body": "<p>How do I call an external command within Python as if I had typed it in a shell or command prompt?</p>\n",
            "top_answer": "<p>Use <a href=\"https://docs.python.org/library/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run</code></a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import subprocess\n\nsubprocess.run([&quot;ls&quot;, &quot;-l&quot;]) \n</code></pre>\n<p>Another common way is <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\"><code>os.system</code></a> but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also <code>subprocess.run</code> is generally more flexible (you can get the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stdout\" rel=\"noreferrer\"><code>stdout</code></a>, <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stderr\" rel=\"noreferrer\"><code>stderr</code></a>, the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.returncode\" rel=\"noreferrer\">&quot;real&quot; status code</a>, better <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CalledProcessError\" rel=\"noreferrer\">error handling</a>, etc.). Even the <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\">documentation for <code>os.system</code></a> recommends using <code>subprocess</code> instead.</p>\n<p>On Python 3.4 and earlier, use <code>subprocess.call</code> instead of <code>.run</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>subprocess.call([&quot;ls&quot;, &quot;-l&quot;])\n</code></pre>\n"
        },
        {
            "tags": [
                "python",
                "exception",
                "path",
                "directory",
                "operating-system"
            ],
            "owner": {
                "account_id": 7495,
                "reputation": 106670,
                "user_id": 13055,
                "user_type": "registered",
                "accept_rate": 68,
                "profile_image": "https://www.gravatar.com/avatar/ab82fd8b5ffe4d09c2bb5f9c14d34b09?s=256&d=identicon&r=PG",
                "display_name": "Parand",
                "link": "https://stackoverflow.com/users/13055/parand"
            },
            "is_answered": true,
            "view_count": 3984829,
            "protected_date": 1392127892,
            "accepted_answer_id": 273227,
            "answer_count": 28,
            "score": 5798,
            "last_activity_date": 1751618433,
            "creation_date": 1226084205,
            "last_edit_date": 1682319558,
            "question_id": 273192,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories",
            "title": "How do I create a directory, and any missing parent directories?",
            "body": "<p>How do I create a directory at a given path, and also create any missing parent directories along that path? For example, the Bash command <code>mkdir -p /path/to/nested/directory</code> does this.</p>\n",
            "top_answer": "<p>On Python \u2265 3.5, use <a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir</code></a>:</p>\n\n<pre><code>from pathlib import Path\nPath(\"/my/directory\").mkdir(parents=True, exist_ok=True)\n</code></pre>\n\n<p>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</p>\n\n<p>Try <a href=\"https://docs.python.org/library/os.path.html#os.path.exists\" rel=\"noreferrer\"><code>os.path.exists</code></a>, and consider <a href=\"https://docs.python.org/library/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a> for the creation.</p>\n\n<pre><code>import os\nif not os.path.exists(directory):\n    os.makedirs(directory)\n</code></pre>\n\n<p>As noted in comments and elsewhere, there's a race condition &ndash; if the directory is created between the <code>os.path.exists</code> and the <code>os.makedirs</code> calls, the <code>os.makedirs</code> will fail with an <code>OSError</code>. Unfortunately, blanket-catching <code>OSError</code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</p>\n\n<p>One option would be to trap the <code>OSError</code> and examine the embedded error code (see <a href=\"https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror\">Is there a cross-platform way of getting information from Python\u2019s OSError</a>):</p>\n\n<pre><code>import os, errno\n\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise\n</code></pre>\n\n<p>Alternatively, there could be a second <code>os.path.exists</code>, but suppose another created the directory after the first check, then removed it before the second one &ndash; we could still be fooled. </p>\n\n<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</p>\n\n<p>Modern versions of Python improve this code quite a bit, both by exposing <a href=\"https://docs.python.org/3.3/library/exceptions.html?#FileExistsError\" rel=\"noreferrer\"><code>FileExistsError</code></a> (in 3.3+)...</p>\n\n<pre><code>try:\n    os.makedirs(\"path/to/directory\")\nexcept FileExistsError:\n    # directory already exists\n    pass\n</code></pre>\n\n<p>...and by allowing <a href=\"https://docs.python.org/3.2/library/os.html#os.makedirs\" rel=\"noreferrer\">a keyword argument to <code>os.makedirs</code> called <code>exist_ok</code></a> (in 3.2+).</p>\n\n<pre><code>os.makedirs(\"path/to/directory\", exist_ok=True)  # succeeds even if directory exists.\n</code></pre>\n"
        },
        {
            "tags": [
                "python",
                "loops",
                "list"
            ],
            "owner": {
                "account_id": 21350,
                "reputation": 332959,
                "user_id": 51816,
                "user_type": "registered",
                "accept_rate": 82,
                "profile_image": "https://www.gravatar.com/avatar/0e54bb28182bcd9df39704751306df27?s=256&d=identicon&r=PG",
                "display_name": "Joan Venge",
                "link": "https://stackoverflow.com/users/51816/joan-venge"
            },
            "is_answered": true,
            "view_count": 4925320,
            "protected_date": 1458291839,
            "accepted_answer_id": 522578,
            "answer_count": 28,
            "score": 5641,
            "last_activity_date": 1750779640,
            "creation_date": 1233960474,
            "last_edit_date": 1744140192,
            "question_id": 522563,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop",
            "title": "How can I access the index value in a &#39;for&#39; loop?",
            "body": "<p>How do I access the index while iterating over a sequence with a <code>for</code> loop?</p>\n<pre class=\"lang-py prettyprint-override\"><code>xs = [8, 23, 45]\n\nfor x in xs:\n    print(&quot;item #{} = {}&quot;.format(index, x))\n</code></pre>\n<p>Desired output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>item #1 = 8\nitem #2 = 23\nitem #3 = 45\n</code></pre>\n",
            "top_answer": "<p>Use the built-in function <a href=\"https://docs.python.org/3/library/functions.html#enumerate\" rel=\"noreferrer\" title=\"enumerate\"><code>enumerate()</code></a>:</p>\n<pre><code>for idx, x in enumerate(xs):\n    print(idx, x)\n</code></pre>\n<p>It is <em><a href=\"https://stackoverflow.com/questions/25011078/what-does-pythonic-mean\">non-Pythonic</a></em> to manually index via <code>for i in range(len(xs)): x = xs[i]</code> or manually manage an additional state variable.</p>\n<p>Check out <a href=\"https://www.python.org/dev/peps/pep-0279/\" rel=\"noreferrer\" title=\"PEP 279\">PEP 279</a> for more.</p>\n"
        },
        {
            "tags": [
                "python",
                "list",
                "multidimensional-array",
                "flatten"
            ],
            "owner": {
                "account_id": 38503,
                "reputation": 55601,
                "user_id": 110527,
                "user_type": "registered",
                "profile_image": "https://www.gravatar.com/avatar/1a3fec384503a3e0b33361f146006598?s=256&d=identicon&r=PG",
                "display_name": "Emma",
                "link": "https://stackoverflow.com/users/110527/emma"
            },
            "is_answered": true,
            "view_count": 4611221,
            "protected_date": 1357910574,
            "accepted_answer_id": 952952,
            "answer_count": 34,
            "score": 5476,
            "last_activity_date": 1749805923,
            "creation_date": 1244147405,
            "last_edit_date": 1749805923,
            "question_id": 952914,
            "content_license": "CC BY-SA 4.0",
            "link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists",
            "title": "How do I make a flat list out of a list of lists?",
            "body": "<p>I have a list of lists like</p>\n<pre><code>[\n    [1, 2, 3],\n    [4, 5, 6],\n    [7],\n    [8, 9]\n]\n</code></pre>\n<p>How can I flatten it to get <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>?</p>\n<hr />\n<p><sub>If your list of lists comes from a nested list comprehension, the problem can be solved more simply/directly by fixing the comprehension; please see <a href=\"https://stackoverflow.com/questions/1077015\">How can I get a flat result from a list comprehension instead of a nested list?</a>.</sub></p>\n<p><sub>The most popular solutions here generally only flatten one &quot;level&quot; of the nested list. See <a href=\"https://stackoverflow.com/questions/2158395\">Flatten an irregular (arbitrarily nested) list of lists</a> for solutions that completely flatten a deeply nested structure (recursively, in general).</sub></p>\n",
            "top_answer": "<p>A list of lists named <code>xss</code> can be flattened using a nested <a href=\"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions\" rel=\"noreferrer\">list comprehension</a>:</p>\n<pre><code>flat_list = [\n    x\n    for xs in xss\n    for x in xs\n]\n</code></pre>\n<p>The above is equivalent to:</p>\n<pre><code>flat_list = []\n\nfor xs in xss:\n    for x in xs:\n        flat_list.append(x)\n</code></pre>\n<p>Here is the corresponding function:</p>\n<pre><code>def flatten(xss):\n    return [x for xs in xss for x in xs]\n</code></pre>\n<p>This is the fastest method.\nAs evidence, using the <a href=\"https://docs.python.org/3/library/timeit.html\" rel=\"noreferrer\"><code>timeit</code></a> module in the standard library, we see:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'\n10000 loops, best of 3: 143 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'\n1000 loops, best of 3: 969 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'\n1000 loops, best of 3: 1.1 msec per loop\n</code></pre>\n<p>Explanation: the methods based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth <code>L-1</code> times, the second M items <code>L-2</code> times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., <code>M * (L**2)/2</code>.</p>\n<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>\n"
        }
    ],
    "has_more": true,
    "quota_max": 300,
    "quota_remaining": 297
}