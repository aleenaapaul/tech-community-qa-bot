title,link,score,tags,answer
What does the &quot;yield&quot; keyword do in Python?,https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python,13089,python;iterator;generator;yield,"To understand what yield does, you must understand what generators are. And before you can understand generators, you must understand iterables.
Iterables
When you create a list, you can read its items one by one. Reading its items one by one is called iteration:
>>> mylist = [1, 2, 3]
>>> for i in mylist:
...    print(i)
1
2
3

mylist is an iterable. When you use a list comprehension, you create a list, and so an iterable:
>>> mylist = [x*x for x in range(3)]
>>> for i in mylist:
...    print(i)
0
1
4

Everything you can use ""for... in..."" on is an iterable; lists, strings, files...
These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.
Generators
Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly:
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)
0
1
4

It is just the same except you used () instead of []. BUT, you cannot perform for i in mygenerator a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.
Yield
yield is a keyword that is used like return, except the function will return a generator.
>>> def create_generator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
>>> mygenerator = create_generator() # create a generator
>>> print(mygenerator) # mygenerator is an object!
<generator object create_generator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4

Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.
To master yield, you must understand that when you call the function, the code you have written in the function body does not run. The function only returns the generator object, this is a bit tricky.
Then, your code will continue from where it left off each time for uses the generator.
Now the hard part:
The first time the for calls the generator object created from your function, it will run the code in your function from the beginning until it hits yield, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting yield. That can be because the loop has come to an end, or because you no longer satisfy an ""if/else"".

Your code explained
Generator:
# Here you create the method of the node object that will return the generator
def _get_child_candidates(self, distance, min_dist, max_dist):

    # Here is the code that will be called each time you use the generator object:

    # If there is still a child of the node object on its left
    # AND if the distance is ok, return the next child
    if self._leftchild and distance - max_dist < self._median:
        yield self._leftchild

    # If there is still a child of the node object on its right
    # AND if the distance is ok, return the next child
    if self._rightchild and distance + max_dist >= self._median:
        yield self._rightchild

    # If the function arrives here, the generator will be considered empty
    # There are no more than two values: the left and the right children

Caller:
# Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning)
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If the distance is ok, then you can fill in the result
    if distance <= max_dist and distance >= min_dist:
        result.extend(node._values)

    # Add the children of the candidate to the candidate's list
    # so the loop will keep running until it has looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result

This code contains several smart parts:

The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) exhausts all the values of the generator, but while keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.

The extend() method is a list object method that expects an iterable and adds its values to the list.


Usually, we pass a list to it:
>>> a = [1, 2]
>>> b = [3, 4]
>>> a.extend(b)
>>> print(a)
[1, 2, 3, 4]

But in your code, it gets a generator, which is good because:

You don't need to read the values twice.
You may have a lot of children and you don't want them all stored in memory.

And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...
You can stop here, or read a little bit to see an advanced use of a generator:
Controlling a generator exhaustion
>>> class Bank(): # Let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self):
...        while not self.crisis:
...            yield ""$100""
>>> hsbc = Bank() # When everything's ok the ATM gives you as much as you want
>>> corner_street_atm = hsbc.create_atm()
>>> print(corner_street_atm.next())
$100
>>> print(corner_street_atm.next())
$100
>>> print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
>>> hsbc.crisis = True # Crisis is coming, no more money!
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> wall_street_atm = hsbc.create_atm() # It's even true for new ATMs
>>> print(wall_street_atm.next())
<type 'exceptions.StopIteration'>
>>> hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> brand_new_atm = hsbc.create_atm() # Build a new one to get back in business
>>> for cash in brand_new_atm:
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...

Note: For Python 3, useprint(corner_street_atm.__next__()) or print(next(corner_street_atm))
It can be useful for various things like controlling access to a resource.
Itertools, your best friend
The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one-liner? Map / Zip without creating another list?
Then just import itertools.
An example? Let's see the possible orders of arrival for a four-horse race:
>>> horses = [1, 2, 3, 4]
>>> races = itertools.permutations(horses)
>>> print(races)
<itertools.permutations object at 0xb754f1dc>
>>> print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]

Understanding the inner mechanisms of iteration
Iteration is a process implying iterables (implementing the __iter__() method) and iterators (implementing the __next__() method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.
There is more about it in this article about how for loops work.
"
What does if __name__ == &quot;__main__&quot;: do?,https://stackoverflow.com/questions/419163/what-does-if-name-main-do,8394,python;namespaces;program-entry-point;python-module;idioms,"Short Answer
It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:

If you import the guardless script in another script (e.g. import my_script_without_a_name_eq_main_guard), then the latter script will trigger the former to run at import time and using the second script's command line arguments. This is almost always a mistake.

If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.


Long Answer
To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.
Whenever the Python interpreter reads a source file, it does two things:

it sets a few special variables like __name__, and then

it executes all of the code found in the file.


Let's see how this works and how it relates to your question about the __name__ checks we always see in Python scripts.
Code Sample
Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called foo.py.
# Suppose this is foo.py.

print(""before import"")
import math

print(""before function_a"")
def function_a():
    print(""Function A"")

print(""before function_b"")
def function_b():
    print(""Function B {}"".format(math.sqrt(100)))

print(""before __name__ guard"")
if __name__ == '__main__':
    function_a()
    function_b()
print(""after __name__ guard"")

Special Variables
When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the __name__ variable.
When Your Module Is the Main Program
If you are running your module (the source file) as the main program, e.g.
python foo.py

the interpreter will assign the hard-coded string ""__main__"" to the __name__ variable, i.e.
# It's as if the interpreter inserts this at the top
# of your module when run as the main program.
__name__ = ""__main__"" 

When Your Module Is Imported By Another
On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:
# Suppose this is in some other main program.
import foo

The interpreter will search for your foo.py file (along with searching for a few other variants), and prior to executing that module, it will assign the name ""foo"" from the import statement to the __name__ variable, i.e.
# It's as if the interpreter inserts this at the top
# of your module when it's imported from another module.
__name__ = ""foo""

Executing the Module's Code
After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.
Always

It prints the string ""before import"" (without quotes).

It loads the math module and assigns it to a variable called math. This is equivalent to replacing import math with the following (note that __import__ is a low-level function in Python that takes a string and triggers the actual import):


# Find and load a module given its string name, ""math"",
# then assign it to a local variable called math.
math = __import__(""math"")


It prints the string ""before function_a"".

It executes the def block, creating a function object, then assigning that function object to a variable called function_a.

It prints the string ""before function_b"".

It executes the second def block, creating another function object, then assigning it to a variable called function_b.

It prints the string ""before __name__ guard"".


Only When Your Module Is the Main Program

If your module is the main program, then it will see that __name__ was indeed set to ""__main__"" and it calls the two functions, printing the strings ""Function A"" and ""Function B 10.0"".

Only When Your Module Is Imported by Another

(instead) If your module is not the main program but was imported by another one, then __name__ will be ""foo"", not ""__main__"", and it'll skip the body of the if statement.

Always

It will print the string ""after __name__ guard"" in both situations.

Summary
In summary, here's what'd be printed in the two cases:
# What gets printed if foo is the main program
before import
before function_a
before function_b
before __name__ guard
Function A
Function B 10.0
after __name__ guard

# What gets printed if foo is imported as a regular module
before import
before function_a
before function_b
before __name__ guard
after __name__ guard

Why Does It Work This Way?
You might naturally wonder why anybody would want this.  Well, sometimes you want to write a .py file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:

Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.

Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing .py files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.

Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.


Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. ""Running"" the script is a side effect of importing the script's module.
Food for Thought

Question: Can I have multiple __name__ checking blocks?  Answer: it's strange to do so, but the language won't stop you.

Suppose the following is in foo2.py.  What happens if you say python foo2.py on the command-line? Why?


# Suppose this is foo2.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print(""a1"")
    from foo2 import function_b
    print(""a2"")
    function_b()
    print(""a3"")

def function_b():
    print(""b"")

print(""t1"")
if __name__ == ""__main__"":
    print(""m1"")
    function_a()
    print(""m2"")
print(""t2"")
      


Now, figure out what will happen in foo3.py (having removed the __name__ check):

# Suppose this is foo3.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print(""a1"")
    from foo3 import function_b
    print(""a2"")
    function_b()
    print(""a3"")

def function_b():
    print(""b"")

print(""t1"")
print(""m1"")
function_a()
print(""m2"")
print(""t2"")


What will this do when used as a script?  When imported as a module?

# Suppose this is in foo4.py
__name__ = ""__main__""

def bar():
    print(""bar"")
    
print(""before __name__ guard"")
if __name__ == ""__main__"":
    bar()
print(""after __name__ guard"")

"
Does Python have a ternary conditional operator?,https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator,8091,python;operators;conditional-operator,"Yes, it was added in version 2.5. The expression syntax is:
a if condition else b

First condition is evaluated, then exactly one of either a or b is evaluated and returned based on the Boolean value of condition. If condition evaluates to True, then a is evaluated and returned but b is ignored, or else when b is evaluated and returned but a is ignored.
This allows short-circuiting because when condition is true only a is evaluated and b is not evaluated at all, but when condition is false only b is evaluated and a is not evaluated at all.
For example:
>>> 'true' if True else 'false'
'true'
>>> 'true' if False else 'false'
'false'

Note that conditionals are an expression, not a statement. This means you can't use statements such as pass, or assignments with = (or ""augmented"" assignments like +=), within a conditional expression:
>>> pass if False else pass
  File ""<stdin>"", line 1
    pass if False else pass
         ^
SyntaxError: invalid syntax

>>> # Python parses this as `x = (1 if False else y) = 2`
>>> # The `(1 if False else x)` part is actually valid, but
>>> # it can't be on the left-hand side of `=`.
>>> x = 1 if False else y = 2
  File ""<stdin>"", line 1
SyntaxError: cannot assign to conditional expression

>>> # If we parenthesize it instead...
>>> (x = 1) if False else (y = 2)
  File ""<stdin>"", line 1
    (x = 1) if False else (y = 2)
       ^
SyntaxError: invalid syntax

(In 3.8 and above, the := ""walrus"" operator allows simple assignment of values as an expression, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)
Similarly, because it is an expression, the else part is mandatory:
# Invalid syntax: we didn't specify what the value should be if the 
# condition isn't met. It doesn't matter if we can verify that
# ahead of time.
a if True

You can, however, use conditional expressions to assign a variable like so:
x = a if True else b

Or for example to return a value:
# Of course we should just use the standard library `max`;
# this is just for demonstration purposes.
def my_max(a, b):
    return a if a > b else b

Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will do the same thing with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to do something different depending on the condition, then use a normal if statement instead.

Keep in mind that it's frowned upon by some Pythonistas for several reasons:

The order of the arguments is different from those of the classic condition ? a : b ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, JavaScript, etc.), which may lead to bugs when people unfamiliar with Python's ""surprising"" behaviour use it (they may reverse the argument order).
Some find it ""unwieldy"", since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).
Stylistic reasons. (Although the 'inline if' can be really useful, and make your script more concise, it really does complicate your code)

If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, x = 4 if b > 8 else 9 is read aloud as x will be 4 if b is greater than 8 otherwise 9.
Official documentation:

Conditional expressions
Is there an equivalent of C’s ”?:” ternary operator?

"
What are metaclasses in Python?,https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python,7507,python;oop;metaclass;python-class;python-datamodel,"A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.
While in Python you can use arbitrary callables for metaclasses (like Jerub shows), the better approach is to make it an actual class itself. type is the usual metaclass in Python. type is itself a class, and it is its own type. You won't be able to recreate something like type purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass type.
A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal __init__ and __new__ methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.
When the class statement is executed, Python first executes the body of the class statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the __metaclass__ attribute of the class-to-be (if any) or the __metaclass__ global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.
However, metaclasses actually define the type of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. type.__subclasses__() is an example of a method on the type metaclass. You can also define the normal 'magic' methods, like __add__, __iter__ and __getattr__, to implement or change how the class behaves.
Here's an aggregated example of the bits and pieces:
def make_hook(f):
    """"""Decorator to turn 'foo' method into '__foo__'""""""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(mcls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print ""Would register class %s now."" % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print ""Would unregister class %s now."" % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print ""NoneType None""
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__

"
How do I merge two dictionaries in a single expression in Python?,https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python,7100,python;dictionary;merge,"Python 3.9+ only
Merge (|) and update (|=) operators have been added to the built-in dict class.
>>> d = {'spam': 1, 'eggs': 2, 'cheese': 3}
>>> e = {'cheese': 'cheddar', 'aardvark': 'Ethel'}
>>> d | e
{'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}

The augmented assignment version operates in-place:
>>> d |= e
>>> d
{'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}

See PEP 584
"
How do I execute a program or call a system command?,https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command,6264,python;shell;terminal;subprocess;command,"Use subprocess.run:
import subprocess

subprocess.run([""ls"", ""-l""]) 

Another common way is os.system but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also subprocess.run is generally more flexible (you can get the stdout, stderr, the ""real"" status code, better error handling, etc.). Even the documentation for os.system recommends using subprocess instead.
On Python 3.4 and earlier, use subprocess.call instead of .run:
subprocess.call([""ls"", ""-l""])

"
"How do I create a directory, and any missing parent directories?",https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories,5798,python;exception;path;directory;operating-system,"On Python ≥ 3.5, use pathlib.Path.mkdir:
from pathlib import Path
Path(""/my/directory"").mkdir(parents=True, exist_ok=True)

For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:
Try os.path.exists, and consider os.makedirs for the creation.
import os
if not os.path.exists(directory):
    os.makedirs(directory)

As noted in comments and elsewhere, there's a race condition – if the directory is created between the os.path.exists and the os.makedirs calls, the os.makedirs will fail with an OSError. Unfortunately, blanket-catching OSError and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.
One option would be to trap the OSError and examine the embedded error code (see Is there a cross-platform way of getting information from Python’s OSError):
import os, errno

try:
    os.makedirs(directory)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

Alternatively, there could be a second os.path.exists, but suppose another created the directory after the first check, then removed it before the second one – we could still be fooled. 
Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.
Modern versions of Python improve this code quite a bit, both by exposing FileExistsError (in 3.3+)...
try:
    os.makedirs(""path/to/directory"")
except FileExistsError:
    # directory already exists
    pass

...and by allowing a keyword argument to os.makedirs called exist_ok (in 3.2+).
os.makedirs(""path/to/directory"", exist_ok=True)  # succeeds even if directory exists.

"
How can I access the index value in a &#39;for&#39; loop?,https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop,5641,python;loops;list,"Use the built-in function enumerate():
for idx, x in enumerate(xs):
    print(idx, x)

It is non-Pythonic to manually index via for i in range(len(xs)): x = xs[i] or manually manage an additional state variable.
Check out PEP 279 for more.
"
How do I make a flat list out of a list of lists?,https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists,5476,python;list;multidimensional-array;flatten,"A list of lists named xss can be flattened using a nested list comprehension:
flat_list = [
    x
    for xs in xss
    for x in xs
]

The above is equivalent to:
flat_list = []

for xs in xss:
    for x in xs:
        flat_list.append(x)

Here is the corresponding function:
def flatten(xss):
    return [x for xs in xss for x in xs]

This is the fastest method.
As evidence, using the timeit module in the standard library, we see:
$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'
10000 loops, best of 3: 143 usec per loop

$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'
1000 loops, best of 3: 969 usec per loop

$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'
1000 loops, best of 3: 1.1 msec per loop

Explanation: the methods based on + (including the implied use in sum) are, of necessity, O(L**2) when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth L-1 times, the second M items L-2 times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., M * (L**2)/2.
The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.
"
What is the difference between @staticmethod and @classmethod in Python?,https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python,4765,python;oop;static-methods;python-decorators;class-method,"Maybe a bit of example code will help: Notice the difference in the call signatures of foo, class_foo and static_foo:
class A(object):
    def foo(self, x):
        print(f""executing foo({self}, {x})"")

    @classmethod
    def class_foo(cls, x):
        print(f""executing class_foo({cls}, {x})"")

    @staticmethod
    def static_foo(x):
        print(f""executing static_foo({x})"")

a = A()

Below is the usual way an object instance calls a method. The object instance, a, is implicitly passed as the first argument.
a.foo(1)
# executing foo(<__main__.A object at 0xb7dbef0c>, 1)


With classmethods, the class of the object instance is implicitly passed as the first argument instead of self.
a.class_foo(1)
# executing class_foo(<class '__main__.A'>, 1)

You can also call class_foo using the class. In fact, if you define something to be
a classmethod, it is probably because you intend to call it from the class rather than from a class instance. A.foo(1) would have raised a TypeError, but A.class_foo(1) works just fine:
A.class_foo(1)
# executing class_foo(<class '__main__.A'>, 1)

One use people have found for class methods is to create inheritable alternative constructors.

With staticmethods, neither self (the object instance) nor  cls (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:
a.static_foo(1)
# executing static_foo(1)

A.static_foo('hi')
# executing static_foo(hi)

Staticmethods are used to group functions which have some logical connection with a class to the class.

foo is just a function, but when you call a.foo you don't just get the function,
you get a ""partially applied"" version of the function with the object instance a bound as the first argument to the function. foo expects 2 arguments, while a.foo only expects 1 argument.
a is bound to foo. That is what is meant by the term ""bound"" below:
print(a.foo)
# <bound method A.foo of <__main__.A object at 0xb7d52f0c>>

With a.class_foo, a is not bound to class_foo, rather the class A is bound to class_foo.
print(a.class_foo)
# <bound method type.class_foo of <class '__main__.A'>>

Here, with a staticmethod, even though it is a method, a.static_foo just returns
a good 'ole function with no arguments bound. static_foo expects 1 argument, and
a.static_foo expects 1 argument too.
print(a.static_foo)
# <function static_foo at 0xb7d479cc>

And of course the same thing happens when you call static_foo with the class A instead.
print(A.static_foo)
# <function static_foo at 0xb7d479cc>

"
How slicing in Python works,https://stackoverflow.com/questions/509211/how-slicing-in-python-works,4682,python;slice;sequence,"The syntax is:
a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array

There is also the step value, which can be used with any of the above:
a[start:stop:step] # start through not past stop, by step

The key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default).
The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So:
a[-1]    # last item in the array
a[-2:]   # last two items in the array
a[:-2]   # everything except the last two items

Similarly, step may be a negative number:
a[::-1]    # all items in the array, reversed
a[1::-1]   # the first two items, reversed
a[:-3:-1]  # the last two items, reversed
a[-3::-1]  # everything except the last two items, reversed

Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.
Relationship with the slice object
A slice object can represent a slicing operation, i.e.:
a[start:stop:step]

is equivalent to:
a[slice(start, stop, step)]

Slice objects also behave slightly differently depending on the number of arguments, similar to range(), i.e. both slice(stop) and slice(start, stop[, step]) are supported.
To skip specifying a given argument, one might use None, so that e.g. a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)].
While the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing.
"
How can I find the index for a given item in a list?,https://stackoverflow.com/questions/176918/how-can-i-find-the-index-for-a-given-item-in-a-list,4477,python;list;indexing,">>> [""foo"", ""bar"", ""baz""].index(""bar"")
1

See the documentation for the built-in .index() method of the list:

list.index(x[, start[, end]])

Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if there is no such item.
The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.

Caveats
Linear time-complexity in list length
An index call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code.
This problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the start and end parameters can be used to narrow the search.
For example:
>>> import timeit
>>> timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)
9.356267921015387
>>> timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)
0.0004404920036904514

The second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.
Only the index of the first match is returned
A call to index searches through the list in order until it finds a match, and stops there. If there could be more than one occurrence of the value, and all indices are needed, index cannot solve the problem:
>>> [1, 1].index(1) # the `1` index is not found.
0

Instead, use a list comprehension or generator expression to do the search, with enumerate to get indices:
>>> # A list comprehension gives a list of indices directly:
>>> [i for i, e in enumerate([1, 2, 1]) if e == 1]
[0, 2]
>>> # A generator comprehension gives us an iterable object...
>>> g = (i for i, e in enumerate([1, 2, 1]) if e == 1)
>>> # which can be used in a `for` loop, or manually iterated with `next`:
>>> next(g)
0
>>> next(g)
2

The list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.
Raises an exception if there is no match
As noted in the documentation above, using .index will raise an exception if the searched-for value is not in the list:
>>> [1, 1].index(2)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: 2 is not in list

If this is a concern, either explicitly check first using item in my_list, or handle the exception with try/except as appropriate.
The explicit check is simple and readable, but it must iterate the list a second time. See What is the EAFP principle in Python? for more guidance on this choice.
"
Iterating over dictionaries using &#39;for&#39; loops,https://stackoverflow.com/questions/3294889/iterating-over-dictionaries-using-for-loops,4404,python;loops;dictionary;key,"key is just a variable name.  
for key in d:

will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:
For Python 3.x:
for key, value in d.items():

For Python 2.x:
for key, value in d.iteritems():

To test for yourself, change the word key to poop.
In Python 3.x, iteritems() was replaced with simply items(), which returns a set-like view backed by the dict, like iteritems() but even better. 
This is also available in 2.7 as viewitems(). 
The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary's (key, value) pairs, which will not reflect changes to the dict that happen after the items() call. If you want the 2.x behavior in 3.x, you can call list(d.items()).
"
How can I iterate over rows in a Pandas DataFrame?,https://stackoverflow.com/questions/16476924/how-can-i-iterate-over-rows-in-a-pandas-dataframe,4230,python;pandas;dataframe;loops,"DataFrame.iterrows is a generator which yields both the index and row (as a Series):
import pandas as pd

df = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})
df = df.reset_index()  # make sure indexes pair with number of rows

for index, row in df.iterrows():
    print(row['c1'], row['c2'])

10 100
11 110
12 120


Obligatory disclaimer from the documentation

Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:

Look for a vectorized solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …
When you have a function that cannot work on the full DataFrame/Series at once, it is better to use apply() instead of iterating over the values. See the docs on function application.
If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the enhancing performance section for some examples of this approach.


Other answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.
"
How can I use a global variable in a function?,https://stackoverflow.com/questions/423379/how-can-i-use-a-global-variable-in-a-function,4041,python;global-variables;scope,"You can use a global variable within other functions by declaring it as global within each function that assigns a value to it:
globvar = 0

def set_globvar_to_one():
    global globvar    # Needed to modify global copy of globvar
    globvar = 1

def print_globvar():
    print(globvar)     # No need for global declaration to read value of globvar

set_globvar_to_one()
print_globvar()       # Prints 1

Since it's unclear whether globvar = 1 is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the global keyword.
See other answers if you want to share a global variable across modules.
"
How do I get the current time in Python?,https://stackoverflow.com/questions/415511/how-do-i-get-the-current-time-in-python,3976,python;datetime;time,"Use datetime:
>>> import datetime
>>> now = datetime.datetime.now()
>>> now
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)
>>> print(now)
2009-01-06 15:08:24.789150

For just the clock time without the date:
>>> now.time()
datetime.time(15, 8, 24, 78915)
>>> print(now.time())
15:08:24.789150


To save typing, you can import the datetime object from the datetime module:
>>> from datetime import datetime

Then remove the prefix datetime. from all of the above.
"
How can I catch multiple exceptions in one line? (in the &quot;except&quot; block),https://stackoverflow.com/questions/6470428/how-can-i-catch-multiple-exceptions-in-one-line-in-the-except-block,3945,python;exception,"From Python Documentation:

An except clause may name multiple exceptions as a parenthesized tuple, for example

except (IDontLikeYouException, YouAreBeingMeanException) as e:
    pass

Or, for Python 2 only:
except (IDontLikeYouException, YouAreBeingMeanException), e:
    pass

Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using as.
"
How do I copy a file?,https://stackoverflow.com/questions/123198/how-do-i-copy-a-file,3930,python;file;copy;filesystems;file-copying,"shutil has many methods you can use. One of which is:
import shutil

shutil.copyfile(src, dst)

# 2nd option
shutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp


Copy the contents of the file named src to a file named dst. Both src and dst need to be the entire filename of the files, including path.
The destination location must be writable; otherwise, an IOError exception will be raised.
If dst already exists, it will be replaced.
Special files such as character or block devices and pipes cannot be copied with this function.
With copy, src and dst are path names given as strs.

Another shutil method to look at is shutil.copy2(). It's similar but preserves more metadata (e.g. time stamps).
If you use os.path operations, use copy rather than copyfile. copyfile will only accept strings.
"
What is __init__.py for?,https://stackoverflow.com/questions/448271/what-is-init-py-for,3887,python;module;package;python-packaging,"It used to be a required part of a package (old, pre-3.3 ""regular package"", not newer 3.3+ ""namespace package"").
Here's the documentation.

Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an __init__.py file. When a regular package is imported, this __init__.py file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The __init__.py file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.

But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without __init__.py.
"
Convert bytes to a string in Python 3,https://stackoverflow.com/questions/606191/convert-bytes-to-a-string-in-python-3,3873,python;string;python-3.x,"Decode the bytes object to produce a string:
>>> b""abcde"".decode(""utf-8"")
'abcde'

The above example assumes that the bytes object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!
"
What is the difference between __str__ and __repr__?,https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr,3810,python;magic-methods;repr,"
Alex Martelli summarized well but, surprisingly, was too succinct.
First, let me reiterate the main points in Alex’s post:

The default implementation is useless (it’s hard to think of one which wouldn’t be, but yeah)
__repr__ goal is to be unambiguous
__str__ goal is to be readable
Container’s __str__ uses contained objects’ __repr__

Default implementation is useless
This is mostly a surprise because Python’s defaults tend to be fairly useful. However, in this case, having a default for __repr__ which would act like:
return ""%s(%r)"" % (self.__class__, self.__dict__)

Or in new f-string formatting:
return f""{self.__class__!s}({self.__dict__!r})""

would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if __repr__ is defined, and __str__ is not, the object will behave as though __str__=__repr__.
This means, in simple terms: almost every object you implement should have a functional __repr__ that’s usable for understanding the object. Implementing __str__ is optional: do that if you need a “pretty print” functionality (for example, used by a report generator).
The goal of __repr__ is to be unambiguous
Let me come right out and say it — I do not believe in debuggers. I don’t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature — most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a
log(INFO, ""I am in the weird function and a is"", a, ""and b is"", b, ""but I got a null C — using default"", default_c)

But you have to do the last step — make sure every object you implement has a useful repr, so code like that can just work. This is why the “eval” thing comes up: if you have enough information so eval(repr(c))==c, that means you know everything there is to know about c. If that’s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about c anyway. I usually use an eval-like format: ""MyClass(this=%r,that=%r)"" % (self.this,self.that). It does not mean that you can actually construct MyClass, or that those are the right constructor arguments — but it is a useful form to express “this is everything you need to know about this instance”.
Note: I used %r above, not %s. You always want to use repr() [or %r formatting character, equivalently] inside __repr__ implementation, or you’re defeating the goal of repr. You want to be able to differentiate MyClass(3) and MyClass(""3"").
The goal of __str__ is to be readable
Specifically, it is not intended to be unambiguous — notice that str(3)==str(""3""). Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be ""2010/4/12 15:35:22"", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class — as long is it supports readability, it is an improvement.
Container’s __str__ uses contained objects’ __repr__
This seems surprising, doesn’t it? It is a little, but how readable would it be if it used their __str__?
[moshe is, 3, hello
world, this is a list, oh I don't know, containing just 4 elements]

Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you’re printing a list, just
print(""["" + "", "".join(lst) + ""]"")

(you can probably also figure out what to do about dictionaries).
Summary
Implement __repr__ for any class you implement. This should be second nature. Implement __str__ if you think it would be useful to have a string version which errs on the side of readability.
"
How do I select rows from a DataFrame based on column values?,https://stackoverflow.com/questions/17071871/how-do-i-select-rows-from-a-dataframe-based-on-column-values,3615,python;pandas;dataframe;indexing;filter,"To select rows whose column value equals a scalar, some_value, use ==:
df.loc[df['column_name'] == some_value]

To select rows whose column value is in an iterable, some_values, use isin:
df.loc[df['column_name'].isin(some_values)]

Combine multiple conditions with &:
df.loc[(df['column_name'] >= A) & (df['column_name'] <= B)]

Note the parentheses. Due to Python's operator precedence rules, & binds more tightly than <= and >=. Thus, the parentheses in the last example are necessary. Without the parentheses
df['column_name'] >= A & df['column_name'] <= B

is parsed as
df['column_name'] >= (A & df['column_name']) <= B

which results in a Truth value of a Series is ambiguous error.

To select rows whose column value does not equal some_value, use !=:
df.loc[df['column_name'] != some_value]

The isin returns a boolean Series, so to select rows whose value is not in some_values, negate the boolean Series using ~:
df = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement


For example,
import pandas as pd
import numpy as np
df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),
                   'B': 'one one two three two two one three'.split(),
                   'C': np.arange(8), 'D': np.arange(8) * 2})
print(df)
#      A      B  C   D
# 0  foo    one  0   0
# 1  bar    one  1   2
# 2  foo    two  2   4
# 3  bar  three  3   6
# 4  foo    two  4   8
# 5  bar    two  5  10
# 6  foo    one  6  12
# 7  foo  three  7  14

print(df.loc[df['A'] == 'foo'])

yields
     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14


If you have multiple values you want to include, put them in a
list (or more generally, any iterable) and use isin:
print(df.loc[df['B'].isin(['one','three'])])

yields
     A      B  C   D
0  foo    one  0   0
1  bar    one  1   2
3  bar  three  3   6
6  foo    one  6  12
7  foo  three  7  14


Note, however, that if you wish to do this many times, it is more efficient to
make an index first, and then use df.loc:
df = df.set_index(['B'])
print(df.loc['one'])

yields
       A  C   D
B              
one  foo  0   0
one  bar  1   2
one  foo  6  12

or, to include multiple values from the index use df.index.isin:
df.loc[df.index.isin(['one','two'])]

yields
       A  C   D
B              
one  foo  0   0
one  bar  1   2
two  foo  2   4
two  foo  4   8
two  bar  5  10
one  foo  6  12

"
How can I add new keys to a dictionary?,https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary,3591,python;dictionary;key;lookup,"You create a new key/value pair on a dictionary by assigning a value to that key
d = {'key': 'value'}
print(d)  # {'key': 'value'}

d['mynewkey'] = 'mynewvalue'

print(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}

If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten.
"
Does Python have a string &#39;contains&#39; substring method?,https://stackoverflow.com/questions/3437059/does-python-have-a-string-contains-substring-method,3586,python;string;substring;contains,"Use the in operator:
if ""blah"" not in somestring: 
    continue

Note: This is case-sensitive.
"
How can I delete a file or folder in Python?,https://stackoverflow.com/questions/6996603/how-can-i-delete-a-file-or-folder-in-python,3521,python;file-io;directory;delete-file,"Use one of these methods:

pathlib.Path.unlink() removes a file or symbolic link.

pathlib.Path.rmdir() removes an empty directory.

shutil.rmtree() deletes a directory and all its contents.



On Python 3.3 and below, you can use these methods instead of the pathlib ones:

os.remove() removes a file.

os.unlink() removes a symbolic link.

os.rmdir() removes an empty directory.


"
&quot;Least Astonishment&quot; and the Mutable Default Argument,https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument,3498,python;language-design;default-parameters;least-astonishment,"Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.
As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of ""member data"" and therefore their state may change from one call to the other - exactly as in any other object.
In any case, the Effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python. I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.
"
What does ** (double star/asterisk) and * (star/asterisk) do for parameters?,https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters,3483,python;syntax;parameter-passing;variadic-functions;argument-unpacking,"The *args and **kwargs are common idioms to allow an arbitrary number of arguments to functions, as described in the section more on defining functions in the Python tutorial.
The *args will give you all positional arguments as a tuple:
def foo(*args):
    for a in args:
        print(a)        

foo(1)
# 1

foo(1, 2, 3)
# 1
# 2
# 3

The **kwargs will give you all
keyword arguments as a dictionary:
def bar(**kwargs):
    for a in kwargs:
        print(a, kwargs[a])  

bar(name='one', age=27)
# name one
# age 27

Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:
def foo(kind, *args, bar=None, **kwargs):
    print(kind, args, bar, kwargs)

foo(123, 'a', 'b', apple='red')
# 123 ('a', 'b') None {'apple': 'red'}

It is also possible to use this the other way around:
def foo(a, b, c):
    print(a, b, c)

obj = {'b':10, 'c':'lee'}

foo(100, **obj)
# 100 10 lee

Another usage of the *l idiom is to unpack argument lists when calling a function.
def foo(bar, lee):
    print(bar, lee)

baz = [1, 2]

foo(*baz)
# 1 2

In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable Unpacking), though it gives a list instead of a tuple in this context:
first, *rest = [1, 2, 3, 4]
# first = 1
# rest = [2, 3, 4]

Also Python 3 adds a new semantic (refer PEP 3102):
def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
    pass

Such function accepts only 3 positional arguments, and everything after * can only be passed as keyword arguments.
Note:
A Python dict, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order.
""The order of elements in **kwargs now corresponds to the order in which keyword arguments were passed to the function."" - What’s New In Python 3.6.
In fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7.
"
How can I access environment variables in Python?,https://stackoverflow.com/questions/4906977/how-can-i-access-environment-variables-in-python,3437,python;environment-variables,"Environment variables are accessed through os.environ:
import os
print(os.environ['HOME'])

To see a list of all environment variables:
print(os.environ)


If a key is not present, attempting to access it will raise a KeyError. To avoid this:
# Returns `None` if the key doesn't exist
print(os.environ.get('KEY_THAT_MIGHT_EXIST'))

# Returns `default_value` if the key doesn't exist
print(os.environ.get('KEY_THAT_MIGHT_EXIST', default_value))

# Returns `default_value` if the key doesn't exist
print(os.getenv('KEY_THAT_MIGHT_EXIST', default_value))

"
How do I sort a dictionary by value?,https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value,3413,python;sorting;dictionary,"Python 3.7+ or CPython 3.6
Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but it's an implementation detail.
>>> x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
>>> {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}

or
>>> dict(sorted(x.items(), key=lambda item: item[1]))
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}

Older Python
It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list—probably a list of tuples.
For instance,
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))

sorted_x will be a list of tuples sorted by the second element in each tuple. dict(sorted_x) == x.
And for those wishing to sort on keys instead of values:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))

In Python3 since unpacking is not allowed we can use
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])

If you want the output as a dict, you can use collections.OrderedDict:
import collections

sorted_dict = collections.OrderedDict(sorted_x)

"
How do I clone a list so that it doesn&#39;t change unexpectedly after assignment?,https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment,3362,python;list;clone;mutable,"new_list = my_list doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment.
To actually copy the list, you have several options:

You can use the built-in list.copy() method (available since Python 3.3):
new_list = old_list.copy()


You can slice it:
new_list = old_list[:]

Alex Martelli's opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable).

You can use the built-in list() constructor:
new_list = list(old_list)


You can use generic copy.copy():
import copy
new_list = copy.copy(old_list)

This is a little slower than list() because it has to find out the datatype of old_list first.

If you need to copy the elements of the list as well, use generic copy.deepcopy():
import copy
new_list = copy.deepcopy(old_list)

Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).


Example:
import copy

class Foo(object):
    def __init__(self, val):
         self.val = val

    def __repr__(self):
        return f'Foo({self.val!r})'

foo = Foo(1)

a = ['foo', foo]
b = a.copy()
c = a[:]
d = list(a)
e = copy.copy(a)
f = copy.deepcopy(a)

# edit orignal list and instance 
a.append('baz')
foo.val = 5

print(f'original: {a}\nlist.copy(): {b}\nslice: {c}\nlist(): {d}\ncopy: {e}\ndeepcopy: {f}')

Result:
original: ['foo', Foo(5), 'baz']
list.copy(): ['foo', Foo(5)]
slice: ['foo', Foo(5)]
list(): ['foo', Foo(5)]
copy: ['foo', Foo(5)]
deepcopy: ['foo', Foo(1)]

"
How do I pass a variable by reference?,https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference,3355,python;reference;parameter-passing;pass-by-reference,"Arguments are passed by assignment. The rationale behind this is twofold:

the parameter passed in is actually a reference to an object (but the reference is passed by value)
some data types are mutable, but others aren't

So:

If you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. 
If you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object.

To make it even more clear, let's have some examples. 
List - a mutable type
Let's try to modify the list that was passed to a method:
def try_to_change_list_contents(the_list):
    print('got', the_list)
    the_list.append('four')
    print('changed to', the_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)

Output:
before, outer_list = ['one', 'two', 'three']
got ['one', 'two', 'three']
changed to ['one', 'two', 'three', 'four']
after, outer_list = ['one', 'two', 'three', 'four']

Since the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.
Now let's see what happens when we try to change the reference that was passed in as a parameter:
def try_to_change_list_reference(the_list):
    print('got', the_list)
    the_list = ['and', 'we', 'can', 'not', 'lie']
    print('set to', the_list)

outer_list = ['we', 'like', 'proper', 'English']

print('before, outer_list =', outer_list)
try_to_change_list_reference(outer_list)
print('after, outer_list =', outer_list)

Output:
before, outer_list = ['we', 'like', 'proper', 'English']
got ['we', 'like', 'proper', 'English']
set to ['and', 'we', 'can', 'not', 'lie']
after, outer_list = ['we', 'like', 'proper', 'English']

Since the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed.
String - an immutable type
It's immutable, so there's nothing we can do to change the contents of the string
Now, let's try to change the reference
def try_to_change_string_reference(the_string):
    print('got', the_string)
    the_string = 'In a kingdom by the sea'
    print('set to', the_string)

outer_string = 'It was many and many a year ago'

print('before, outer_string =', outer_string)
try_to_change_string_reference(outer_string)
print('after, outer_string =', outer_string)

Output:
before, outer_string = It was many and many a year ago
got It was many and many a year ago
set to In a kingdom by the sea
after, outer_string = It was many and many a year ago

Again, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The the_string was a copy of the outer_string reference, and we had the_string point to a new string, but there was no way to change where outer_string pointed.
I hope this clears things up a little.
EDIT: It's been noted that this doesn't answer the question that @David originally asked, ""Is there something I can do to pass the variable by actual reference?"". Let's work on that.
How do we get around this?
As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:
def return_a_whole_new_string(the_string):
    new_string = something_to_do_with_the_old_string(the_string)
    return new_string

# then you could call it like
my_string = return_a_whole_new_string(my_string)

If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:
def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):
    new_string = something_to_do_with_the_old_string(stuff_to_change[0])
    stuff_to_change[0] = new_string

# then you could call it like
wrapper = [my_string]
use_a_wrapper_to_simulate_pass_by_reference(wrapper)

do_something_with(wrapper[0])

Although this seems a little cumbersome.
"
Manually raising (throwing) an exception in Python,https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python,3310,python;exception,"
How do I manually throw/raise an exception in Python?

Use the most specific Exception constructor that semantically fits your issue.
Be specific in your message, e.g.:
raise ValueError('A very specific bad thing happened.')

Don't raise generic exceptions
Avoid raising a generic Exception. To catch it, you'll have to catch all other more specific exceptions that subclass it.
Problem 1: Hiding bugs
raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.

For example:
def demo_bad_catch():
    try:
        raise ValueError('Represents a hidden bug, do not catch this')
        raise Exception('This is the exception you expect to handle')
    except Exception as error:
        print('Caught this error: ' + repr(error))

>>> demo_bad_catch()
Caught this error: ValueError('Represents a hidden bug, do not catch this',)

Problem 2: Won't catch
And more specific catches won't catch the general exception:
def demo_no_catch():
    try:
        raise Exception('general exceptions not caught by specific handling')
    except ValueError as e:
        print('we will not catch exception: Exception')
 

>>> demo_no_catch()
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""<stdin>"", line 3, in demo_no_catch
Exception: general exceptions not caught by specific handling

Best Practices: raise statement
Instead, use the most specific Exception constructor that semantically fits your issue.
raise ValueError('A very specific bad thing happened')

which also handily allows an arbitrary number of arguments to be passed to the constructor:
raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') 

These arguments are accessed by the args attribute on the Exception object. For example:
try:
    some_code_that_may_raise_our_value_error()
except ValueError as err:
    print(err.args)

prints
('message', 'foo', 'bar', 'baz')    

In Python 2.5, an actual message attribute was added to BaseException in favor of encouraging users to subclass Exceptions and stop using args, but the introduction of message and the original deprecation of args has been retracted.
Best Practices: except clause
When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:
logger = logging.getLogger(__name__)

try:
    do_something_in_app_that_breaks_easily()
except AppError as error:
    logger.error(error)
    raise                 # just this!
    # raise AppError      # Don't do this, you'll lose the stack trace!

Don't modify your errors... but if you insist.
You can preserve the stacktrace (and error value) with sys.exc_info(), but this is way more error prone and has compatibility problems between Python 2 and 3, prefer to use a bare raise to re-raise.
To explain - the sys.exc_info() returns the type, value, and traceback.
type, value, traceback = sys.exc_info()

This is the syntax in Python 2 - note this is not compatible with Python 3:
raise AppError, error, sys.exc_info()[2] # avoid this.
# Equivalently, as error *is* the second object:
raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]

If you want to, you can modify what happens with your new raise - e.g. setting new args for the instance:
def error():
    raise ValueError('oops!')

def catch_error_modify_message():
    try:
        error()
    except ValueError:
        error_type, error_instance, traceback = sys.exc_info()
        error_instance.args = (error_instance.args[0] + ' <modification>',)
        raise error_type, error_instance, traceback

And we have preserved the whole traceback while modifying the args. Note that this is not a best practice and it is invalid syntax in Python 3 (making keeping compatibility much harder to work around).
>>> catch_error_modify_message()
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""<stdin>"", line 3, in catch_error_modify_message
  File ""<stdin>"", line 2, in error
ValueError: oops! <modification>

In Python 3:
raise error.with_traceback(sys.exc_info()[2])

Again: avoid manually manipulating tracebacks. It's less efficient and more error prone. And if you're using threading and sys.exc_info you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)
Python 3, Exception chaining
In Python 3, you can chain Exceptions, which preserve tracebacks:
raise RuntimeError('specific message') from error

Be aware:

this does allow changing the error type raised, and
this is not compatible with Python 2.

Deprecated Methods:
These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, but not the one intended!
Valid in Python 2, but not in Python 3 is the following:
raise ValueError, 'message' # Don't do this, it's deprecated!

Only valid in much older versions of Python (2.4 and lower), you may still see people raising strings:
raise 'message' # really really wrong. don't do this.

In all modern versions, this will actually raise a TypeError, because you're not raising a BaseException type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.
Example Usage
I raise Exceptions to warn consumers of my API if they're using it incorrectly:
def api_func(foo):
    '''foo should be either 'baz' or 'bar'. returns something very useful.'''
    if foo not in _ALLOWED_ARGS:
        raise ValueError('{foo} wrong, use ""baz"" or ""bar""'.format(foo=repr(foo)))

Create your own error types when apropos

""I want to make an error on purpose, so that it would go into the except""

You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:
class MyAppLookupError(LookupError):
    '''raise this when there's a lookup error for my app'''

and usage:
if important_key not in resource_dict and not ok_to_be_missing:
    raise MyAppLookupError('resource is missing, and that is not ok.')

"
Understanding Python super() with __init__() methods,https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods,3284,python;class;oop;inheritance;super,"super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.
Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. The standard docs also refer to a guide to using super() which is quite explanatory.
"
How do I concatenate two lists in Python?,https://stackoverflow.com/questions/1720421/how-do-i-concatenate-two-lists-in-python,3238,python;list;concatenation,"Use the + operator to combine the lists:
listone = [1, 2, 3]
listtwo = [4, 5, 6]

joinedlist = listone + listtwo

Output:
>>> joinedlist
[1, 2, 3, 4, 5, 6]

NOTE: This will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use copy.deepcopy() to get deep copies of lists.
"
How do I check if a list is empty?,https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty,3222,python;list,"if not a:
    print(""List is empty"")

Using the implicit booleanness of the empty list is quite Pythonic.
"
How do I make function decorators and chain them together?,https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together,3196,python;function;decorator;python-decorators;chain,"Check out the documentation to see how decorators work. Here is what you asked for:
from functools import wraps

def makebold(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        return ""<b>"" + fn(*args, **kwargs) + ""</b>""
    return wrapper

def makeitalic(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        return ""<i>"" + fn(*args, **kwargs) + ""</i>""
    return wrapper

@makebold
@makeitalic
def hello():
    return ""hello world""

@makebold
@makeitalic
def log(s):
    return s

print hello()        # returns ""<b><i>hello world</i></b>""
print hello.__name__ # with functools.wraps() this returns ""hello""
print log('hello')   # returns ""<b><i>hello</i></b>""

"
How do I split a list into equally-sized chunks?,https://stackoverflow.com/questions/312443/how-do-i-split-a-list-into-equally-sized-chunks,3162,python;list;split;chunks,"Here's a generator that yields evenly-sized chunks:
def chunks(lst, n):
    """"""Yield successive n-sized chunks from lst.""""""
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

import pprint
pprint.pprint(list(chunks(range(10, 75), 10)))
[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
 [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
 [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
 [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
 [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
 [70, 71, 72, 73, 74]]

For Python 2, using xrange instead of range:
def chunks(lst, n):
    """"""Yield successive n-sized chunks from lst.""""""
    for i in xrange(0, len(lst), n):
        yield lst[i:i + n]


Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:
[lst[i:i + n] for i in range(0, len(lst), n)]

For Python 2:
[lst[i:i + n] for i in xrange(0, len(lst), n)]

"
Find the current directory and file&#39;s directory,https://stackoverflow.com/questions/5137497/find-the-current-directory-and-files-directory,3116,python;directory,"To get the full path to the directory a Python file is contained in, write this in that file:
import os 
dir_path = os.path.dirname(os.path.realpath(__file__))

(Note that the incantation above won't work if you've already used os.chdir() to change your current working directory, since the value of the __file__ constant is relative to the current working directory and is not changed by an os.chdir() call.)

To get the current working directory use 
import os
cwd = os.getcwd()


Documentation references for the modules, constants and functions used above:

The os and os.path modules.
The __file__ constant
os.path.realpath(path) (returns ""the canonical path of the specified filename, eliminating any symbolic links encountered in the path"")
os.path.dirname(path) (returns ""the directory name of pathname path"")
os.getcwd() (returns ""a string representing the current working directory"")
os.chdir(path) (""change the current working directory to path"")

"
What is the difference between Python&#39;s list methods append and extend?,https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend,3110,python;list;data-structures;append;extend,".append() appends a single object at the end of the list:
>>> x = [1, 2, 3]
>>> x.append([4, 5])
>>> print(x)
[1, 2, 3, [4, 5]]

.extend() appends multiple objects that are taken from inside the specified iterable:
>>> x = [1, 2, 3]
>>> x.extend([4, 5])
>>> print(x)
[1, 2, 3, 4, 5]

"
Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3?,https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3,3068,python;performance;python-3.x;range;python-internals,"The Python 3 range() object doesn't produce numbers immediately; it is a smart sequence object that produces numbers on demand. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.
The object also implements the object.__contains__ hook, and calculates if your number is part of its range. Calculating is a (near) constant time operation *. There is never a need to scan through all possible integers in the range.
From the range() object documentation:

The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed).

So at a minimum, your range() object would do:
class my_range:
    def __init__(self, start, stop=None, step=1, /):
        if stop is None:
            start, stop = 0, start
        self.start, self.stop, self.step = start, stop, step
        if step < 0:
            lo, hi, step = stop, start, -step
        else:
            lo, hi = start, stop
        self.length = 0 if lo > hi else ((hi - lo - 1) // step) + 1

    def __iter__(self):
        current = self.start
        if self.step < 0:
            while current > self.stop:
                yield current
                current += self.step
        else:
            while current < self.stop:
                yield current
                current += self.step

    def __len__(self):
        return self.length

    def __getitem__(self, i):
        if i < 0:
            i += self.length
        if 0 <= i < self.length:
            return self.start + i * self.step
        raise IndexError('my_range object index out of range')

    def __contains__(self, num):
        if self.step < 0:
            if not (self.stop < num <= self.start):
                return False
        else:
            if not (self.start <= num < self.stop):
                return False
        return (num - self.start) % self.step == 0

This is still missing several things that a real range() supports (such as the .index() or .count() methods, hashing, equality testing, or slicing), but should give you an idea.
I also simplified the __contains__ implementation to only focus on integer tests; if you give a real range() object a non-integer value (including subclasses of int), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original Python issue that implemented the containment test.

* Near constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it’s all executed in optimised C code and Python stores integer values in 30-bit chunks, you’d run out of memory before you saw any performance impact due to the size of the integers involved here.
"
Renaming column names in Pandas,https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas,3062,python;pandas;replace;dataframe;rename,"Just assign it to the .columns attribute:
>>> df = pd.DataFrame({'$a':[1,2], '$b': [10,20]})
>>> df
   $a  $b
0   1  10
1   2  20

>>> df.columns = ['a', 'b']
>>> df
   a   b
0  1  10
1  2  20

"
Convert string &quot;Jun 1 2005 1:33PM&quot; into datetime,https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime,2999,python;datetime;type-conversion,"datetime.strptime parses an input string in the user-specified format into a timezone-naive datetime object:
>>> from datetime import datetime
>>> datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')
datetime.datetime(2005, 6, 1, 13, 33)

To obtain a date object using an existing datetime object, convert it using .date():
>>> datetime.strptime('Jun 1 2005', '%b %d %Y').date()
date(2005, 6, 1)


Links:

strptime docs: Python 2, Python 3

strptime/strftime format string docs: Python 2, Python 3

strftime.org format string cheatsheet


Notes:

strptime = ""string parse time""
strftime = ""string format time""

"
How can I remove a key from a Python dictionary?,https://stackoverflow.com/questions/11277432/how-can-i-remove-a-key-from-a-python-dictionary,2999,python;dictionary;unset,"To delete a key regardless of whether it is in the dictionary, use the two-argument form of dict.pop():
my_dict.pop('key', None)

This will return my_dict[key] if key exists in the dictionary, and None otherwise. If the second parameter is not specified (i.e. my_dict.pop('key')) and key does not exist, a KeyError is raised.
To delete a key that is guaranteed to exist, you can also use
del my_dict['key']

This will raise a KeyError if the key is not in the dictionary.
"
How to upgrade all Python packages with pip,https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip,2872,python;pip;pypi,"There isn't a built-in flag yet. Starting with pip version 22.3, the --outdated and --format=freeze have become mutually exclusive. Use Python, to parse the JSON output:
pip --disable-pip-version-check list --outdated --format=json | python -c ""import json, sys; print('\n'.join([x['name'] for x in json.load(sys.stdin)]))"" | xargs -n1 pip install -U

If you are using pip<22.3 you can use:
pip list --outdated --format=freeze | grep -v '^\-e' | cut -d = -f 1  | xargs -n1 pip install -U

For older versions of pip:
pip freeze --local | grep -v '^\-e' | cut -d = -f 1  | xargs -n1 pip install -U



The grep is to skip editable (""-e"") package definitions, as suggested by @jawache. (Yes, you could replace grep+cut with sed or awk or perl or...).

The -n1 flag for xargs prevents stopping everything if updating one package fails (thanks @andsens).



Note: there are infinite potential variations for this. I'm trying to keep this answer short and simple, but please do suggest variations in the comments!
"
How can I sort a list of dictionaries by a value of the dictionary in Python?,https://stackoverflow.com/questions/72899/how-can-i-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary-in-python,2850,python;list;sorting;dictionary;data-structures,"The sorted() function takes a key= parameter
newlist = sorted(list_to_be_sorted, key=lambda d: d['name'])

Alternatively, you can use operator.itemgetter instead of defining the function yourself
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

For completeness, add reverse=True to sort in descending order
newlist = sorted(list_to_be_sorted, key=itemgetter('name'), reverse=True)

"
How to leave/exit/deactivate a Python virtualenv,https://stackoverflow.com/questions/990754/how-to-leave-exit-deactivate-a-python-virtualenv,2808,python;virtualenv;exit;virtualenvwrapper,"Usually, activating a virtualenv gives you a shell function named:
$ deactivate

which puts things back to normal.
I have just looked specifically again at the code for virtualenvwrapper, and, yes, it too supports deactivate as the way to escape from all virtualenvs.
If you are trying to leave an Anaconda environment, the command depends upon your version of conda. Recent versions (like 4.6) install a conda function directly in your shell, in which case you run:
conda deactivate

Older conda versions instead implement deactivation using a stand-alone script:
source deactivate

"
How do I get the last element of a list?,https://stackoverflow.com/questions/930397/how-do-i-get-the-last-element-of-a-list,2805,python;list;indexing,"some_list[-1] is the shortest and most Pythonic.
In fact, you can do much more with this syntax. The some_list[-n] syntax gets the nth-to-last element. So some_list[-1] gets the last element, some_list[-2] gets the second to last, etc, all the way down to some_list[-len(some_list)], which gives you the first element.
You can also set list elements in this way. For instance:
>>> some_list = [1, 2, 3]
>>> some_list[-1] = 5 # Set the last element
>>> some_list[-2] = 3 # Set the second to last element
>>> some_list
[1, 3, 5]

Note that getting a list item by index will raise an IndexError if the expected item doesn't exist. This means that some_list[-1] will raise an exception if some_list is empty, because an empty list can't have a last element.
"
How do I install pip on Windows?,https://stackoverflow.com/questions/4750806/how-do-i-install-pip-on-windows,2772,python;windows;pip,"Python 3.4+ and 2.7.9+
Good news! Python 3.4 (released March 2014) and Python 2.7.9 (released December 2014) ship with Pip. This is the best feature of any Python release. It makes the community's wealth of libraries accessible to everyone. Newbies are no longer excluded from using community libraries by the prohibitive difficulty of setup. In shipping with a package manager, Python joins Ruby, Node.js, Haskell, Perl, Go—almost every other contemporary language with a majority open-source community. Thank you, Python.
If you do find that pip is not available, simply run ensurepip.

On Windows:
py -3 -m ensurepip


Otherwise:
python3 -m ensurepip



Of course, that doesn't mean Python packaging is problem solved. The experience remains frustrating. I discuss this in the Stack Overflow question Does Python have a package/module management system?.
Python 3 ≤ 3.3 and 2 ≤ 2.7.8
Flying in the face of its 'batteries included' motto, Python ships without a package manager. To make matters worse, Pip was—until recently—ironically difficult to install.
Official instructions
Per https://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip:
Download get-pip.py, being careful to save it as a .py file rather than .txt. Then, run it from the command prompt:
python get-pip.py

You possibly need an administrator command prompt to do this. Follow Start a Command Prompt as an Administrator (Microsoft TechNet).
This installs the pip package, which (in Windows) contains ...\Scripts\pip.exe that path must be in PATH environment variable to use pip from the command line (see the second part of 'Alternative Instructions' for adding it to your PATH,
Alternative instructions
The official documentation tells users to install Pip and each of its dependencies from source. That's tedious for the experienced and prohibitively difficult for newbies.
For our sake, Christoph Gohlke prepares Windows installers (.msi) for popular Python packages. He builds installers for all Python versions, both 32 and 64 bit. You need to:

Install setuptools
Install pip

For me, this installed Pip at C:\Python27\Scripts\pip.exe. Find pip.exe on your computer, then add its folder (for example, C:\Python27\Scripts) to your path (Start / Edit environment variables). Now you should be able to run pip from the command line. Try installing a package:
pip install httpie

There you go (hopefully)! Solutions for common problems are given below:
Proxy problems
If you work in an office, you might be behind an HTTP proxy. If so, set the environment variables http_proxy and https_proxy. Most Python applications (and other free software) respect these. Example syntax:
http://proxy_url:port
http://username:password@proxy_url:port

If you're really unlucky, your proxy might be a Microsoft NTLM proxy. Free software can't cope. The only solution is to install a free software friendly proxy that forwards to the nasty proxy. http://cntlm.sourceforge.net/
Unable to find vcvarsall.bat
Python modules can be partly written in C or C++. Pip tries to compile from source. If you don't have a C/C++ compiler installed and configured, you'll see this cryptic error message.

Error: Unable to find vcvarsall.bat

You can fix that by installing a C++ compiler such as MinGW or Visual C++. Microsoft actually ships one specifically for use with Python. Or try Microsoft Visual C++ Compiler for Python 2.7.
Often though it's easier to check Christoph's site for your package.
"
How do I parse a string to a float or int?,https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int,2771,python;parsing;floating-point;type-conversion;integer,">>> a = ""545.2222""
>>> float(a)
545.22220000000004
>>> int(float(a))
545

"
How do I get a substring of a string in Python?,https://stackoverflow.com/questions/663171/how-do-i-get-a-substring-of-a-string-in-python,2717,python;string;substring,">>> x = ""Hello World!""
>>> x[2:]
'llo World!'
>>> x[:2]
'He'
>>> x[:-2]
'Hello Worl'
>>> x[-2:]
'd!'
>>> x[2:-2]
'llo Worl'

Python calls this concept ""slicing"" and it works on more than just strings. Take a look here for a comprehensive introduction.
"
How do I escape curly-brace ({}) characters characters in a string while using .format?,https://stackoverflow.com/questions/5466451/how-do-i-escape-curly-brace-characters-characters-in-a-string-while-using,2696,python;string;format;string-formatting;curly-braces,"You need to double the {{ and }}:
>>> x = "" {{ Hello }} {0} ""
>>> print(x.format(42))
' { Hello } 42 '

Here's the relevant part of the Python documentation for format string syntax:

Format strings contain “replacement fields” surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}.

"
Check if a given key already exists in a dictionary,https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary,2675,python;dictionary,"in tests for the existence of a key in a dict:
d = {""key1"": 10, ""key2"": 23}

if ""key1"" in d:
    print(""this will execute"")

if ""nonexistent key"" in d:
    print(""this will not"")


Use dict.get() to provide a default value when the key does not exist:
d = {}

for i in range(100):
    key = i % 10
    d[key] = d.get(key, 0) + 1


To provide a default value for every key, either use dict.setdefault() on each assignment:
d = {}

for i in range(100):
    d[i % 10] = d.setdefault(i % 10, 0) + 1    

...or better, use defaultdict from the collections module:
from collections import defaultdict

d = defaultdict(int)

for i in range(100):
    d[i % 10] += 1

"
Class (static) variables and methods,https://stackoverflow.com/questions/68645/class-static-variables-and-methods,2626,python;class;static;class-variables,"Variables declared inside the class definition, but not inside a method are class or static variables:
>>> class MyClass:
...     i = 3
...
>>> MyClass.i
3 

As @millerdev points out, this creates a class-level i variable, but this is distinct from any instance-level i variable, so you could have
>>> m = MyClass()
>>> m.i = 4
>>> MyClass.i, m.i
>>> (3, 4)

This is different from C++ and Java, but not so different from C#, where a static member can't be accessed using a reference to an instance.
See what the Python tutorial has to say on the subject of classes and class objects.
@Steve Johnson has already answered regarding static methods, also documented under ""Built-in Functions"" in the Python Library Reference.
class C:
    @staticmethod
    def f(arg1, arg2, ...): ...

@beidy recommends classmethods over staticmethod, as the method then receives the class type as the first argument.
"
How do I lowercase a string in Python?,https://stackoverflow.com/questions/6797984/how-do-i-lowercase-a-string-in-python,2577,python;string;uppercase;lowercase,"Use str.lower():
""Kilometer"".lower()

"
How can I check if an object has an attribute?,https://stackoverflow.com/questions/610883/how-can-i-check-if-an-object-has-an-attribute,2527,python;class;object;attributes;attributeerror,"Try hasattr():
if hasattr(a, 'property'):
    a.property

See zweiterlinde's answer, which offers good advice about asking forgiveness! It is a very Pythonic approach!
The general practice in Python is that, if the property is likely to be there most of the time, simply call it and either let the exception propagate, or trap it with a try/except block. This will likely be faster than hasattr. If the property is likely to not be there most of the time, or you're not sure, using hasattr will probably be faster than repeatedly falling into an exception block.
"
How to print without a newline or space,https://stackoverflow.com/questions/493386/how-to-print-without-a-newline-or-space,2508,python;trailing-newline,"In Python 3, you can use the sep= and end= parameters of the print function:
To not add a newline to the end of the string:
print('.', end='')

To not add a space between all the function arguments you want to print:
print('a', 'b', 'c', sep='')

You can pass any string to either parameter, and you can use both parameters at the same time.
If you are having trouble with buffering, you can flush the output by adding flush=True keyword argument:
print('.', end='', flush=True)

Python 2.6 and 2.7
From Python 2.6 you can either import the print function from Python 3 using the __future__ module:
from __future__ import print_function

which allows you to use the Python 3 solution above.
However, note that the flush keyword is not available in the version of the print function imported from __future__ in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you'll still need to flush manually with a call to sys.stdout.flush(). You'll also have to rewrite all other print statements in the file where you do this import.
Or you can use sys.stdout.write()
import sys
sys.stdout.write('.')

You may also need to call
sys.stdout.flush()

to ensure stdout is flushed immediately.
"
Calling a function of a module by using its name (a string),https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string,2490,python;object;reflection,"Given a module foo with method bar:
import foo
bar = getattr(foo, 'bar')
result = bar()

getattr can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.
"
How can I randomly select (choose) an item from a list (get a random element)?,https://stackoverflow.com/questions/306400/how-can-i-randomly-select-choose-an-item-from-a-list-get-a-random-element,2429,python;list;random,"Use random.choice():
import random

foo = ['a', 'b', 'c', 'd', 'e']
print(random.choice(foo))

For cryptographically secure random choices (e.g., for generating a passphrase from a wordlist), use secrets.choice():
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))

secrets is new in Python 3.6. On older versions of Python you can use the random.SystemRandom class:
import random

secure_random = random.SystemRandom()
print(secure_random.choice(foo))

"
How to remove an element from a list by index,https://stackoverflow.com/questions/627435/how-to-remove-an-element-from-a-list-by-index,2341,python;list;indexing,"Use del and specify the index of the element you want to delete:
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> del a[-1]
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8]

Also supports slices:
>>> del a[2:4]
>>> a
[0, 1, 4, 5, 6, 7, 8, 9]

Here is the section from the tutorial.
"
Delete a column from a Pandas DataFrame,https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe,2326,python;pandas;dataframe;del,"As you've guessed, the right syntax is 
del df['column_name']

It's difficult to make del df.column_name work simply as the result of syntactic limitations in Python. del df[name] gets translated to df.__delitem__(name) under the covers by Python.
"
How do I get the number of elements in a list (length of a list) in Python?,https://stackoverflow.com/questions/1712227/how-do-i-get-the-number-of-elements-in-a-list-length-of-a-list-in-python,2296,python;list,"The len() function can be used with several different types in Python - both built-in types and library types. For example:
>>> len([1, 2, 3])
3

"
How do I pad a string with zeros?,https://stackoverflow.com/questions/339007/how-do-i-pad-a-string-with-zeros,2243,python;string;zero-padding,"To pad strings:
>>> n = '4'
>>> print(n.zfill(3))
004

To pad numbers:
>>> n = 4
>>> print(f'{n:03}') # Preferred method, python >= 3.6
004
>>> print('%03d' % n)
004
>>> print(format(n, '03')) # python >= 2.6
004
>>> print('{0:03d}'.format(n))  # python >= 2.6 + python 3
004
>>> print('{foo:03d}'.format(foo=n))  # python >= 2.6 + python 3
004
>>> print('{:03d}'.format(n))  # python >= 2.7 + python3
004

String formatting documentation.
"
"What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?",https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe,2243,python;virtualenv;virtualenvwrapper;pyenv;python-venv,"This is my personal recommendation for beginners: start by learning virtualenv and pip, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.
Now on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?
PyPI packages not in the standard library:

virtualenv is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool.
It works by installing a bunch of files in a directory (eg: env/), and then modifying the PATH environment variable to prefix it with a custom bin directory (eg: env/bin/). An exact copy of the python or python3 binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using pip.

pyenv is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the PATH environment variable with ~/.pyenv/shims, where there are special files matching the Python commands (python, pip). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the PYENV_VERSION environment variable, or the .python-version file, or the ~/.pyenv/version file. pyenv also makes the process of downloading and installing multiple Python versions easier, using the command pyenv install.

pyenv-virtualenv is a plugin for pyenv by the same author as pyenv, to allow you to use pyenv and virtualenv at the same time conveniently. However, if you're using Python 3.3 or later, pyenv-virtualenv will try to run python -m venv if it is available, instead of virtualenv. You can use virtualenv and pyenv together without pyenv-virtualenv, if you don't want the convenience features.

virtualenvwrapper is a set of extensions to virtualenv (see docs). It gives you commands like mkvirtualenv, lssitepackages, and especially workon for switching between different virtualenv directories. This tool is especially useful if you want multiple virtualenv directories.

pyenv-virtualenvwrapper is a plugin for pyenv by the same author as pyenv, to conveniently integrate virtualenvwrapper into pyenv.

pipenv aims to combine Pipfile, pip and virtualenv into one command on the command-line. The virtualenv directory typically gets placed in ~/.local/share/virtualenvs/XXX, with XXX being a hash of the path of the project directory. This is different from virtualenv, where the directory is typically in the current working directory. pipenv is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to pipenv, such as poetry, which I won't list here since this question is only about the packages that are similarly named.


Standard library:

pyvenv (not to be confused with pyenv in the previous section) is a script shipped with Python 3.3 to 3.7. It was removed from Python 3.8 as it had problems (not to mention the confusing name). Running python3 -m venv has exactly the same effect as pyvenv.

venv is a package shipped with Python 3, which you can run using python3 -m venv (although for some reason some distros separate it out into a separate distro package, such as python3-venv on Ubuntu/Debian). It serves the same purpose as virtualenv, but only has a subset of its features (see a comparison here). virtualenv continues to be more popular than venv, especially since the former supports both Python 2 and 3.


"
Delete an element from a dictionary,https://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary,2237,python;dictionary;del,"The del statement removes an element:
del d[key]

Note that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a new dictionary, make a copy of the dictionary:
def removekey(d, key):
    r = dict(d)
    del r[key]
    return r

The dict() constructor makes a shallow copy. To make a deep copy, see the copy module.

Note that making a copy for every dict del/assignment/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in this answer).
"
Determine the type of an object?,https://stackoverflow.com/questions/2225038/determine-the-type-of-an-object,2219,python;dictionary;types;typeof,"There are two built-in functions that help you identify the type of an object. You can use type()  if you need the exact type of an object, and isinstance() to check an object’s type against something. Usually, you want to use isinstance() most of the times since it is very robust and also supports type inheritance.

To get the actual type of an object, you use the built-in type() function. Passing an object as the only parameter will return the type object of that object:
>>> type([]) is list
True
>>> type({}) is dict
True
>>> type('') is str
True
>>> type(0) is int
True

This of course also works for custom types:
>>> class Test1 (object):
        pass
>>> class Test2 (Test1):
        pass
>>> a = Test1()
>>> b = Test2()
>>> type(a) is Test1
True
>>> type(b) is Test2
True

Note that type() will only return the immediate type of the object, but won’t be able to tell you about type inheritance.
>>> type(b) is Test1
False

To cover that, you should use the isinstance function. This of course also works for built-in types:
>>> isinstance(b, Test1)
True
>>> isinstance(b, Test2)
True
>>> isinstance(a, Test1)
True
>>> isinstance(a, Test2)
False
>>> isinstance([], list)
True
>>> isinstance({}, dict)
True

isinstance() is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using isinstance() is preferred over type().
The second parameter of isinstance() also accepts a tuple of types, so it’s possible to check for multiple types at once. isinstance will then return true, if the object is of any of those types:
>>> isinstance([], (tuple, list, set))
True

"
How do I count the occurrences of a list item?,https://stackoverflow.com/questions/2600191/how-do-i-count-the-occurrences-of-a-list-item,2218,python;list;count,"If you only want a single item's count, use the count method:
>>> [1, 2, 3, 4, 1, 4, 1].count(1)
3


Important: this is very slow if you are counting multiple different items
Each count call goes over the entire list of n elements. Calling count in a loop n times means n * n total checks, which can be catastrophic for performance.
If you want to count multiple items, use Counter, which only does n total checks.
"
How to check if the string is empty in Python?,https://stackoverflow.com/questions/9573244/how-to-check-if-the-string-is-empty-in-python,2213,python;string;boolean;is-empty;comparison-operators,"Empty strings are ""falsy"" (python 2 or python 3 reference), which means they are considered false in a Boolean context, so you can just do this:
if not myString:

This is the preferred way if you know that your variable is a string.  If your variable could also be some other type then you should use:
if myString == """":

See the documentation on Truth Value Testing for other values that are false in Boolean contexts.
"
Why is reading lines from stdin much slower in C++ than Python?,https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python,2199,python;c++;benchmarking;iostream;getline,"tl;dr: Because of different default settings in C++ requiring more system calls.
By default, cin is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:
std::ios_base::sync_with_stdio(false);

Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the FILE* based stdio and iostreams often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:
int myvalue1;
cin >> myvalue1;
int myvalue2;
scanf(""%d"",&myvalue2);

If more input was read by cin than it actually needed, then the second integer value wouldn't be available for the scanf function, which has its own independent buffer.  This would lead to unexpected results.
To avoid this, by default, streams are synchronized with stdio.  One common way to achieve this is to have cin read each character one at a time as needed using stdio functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.
Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the sync_with_stdio method. From this link (emphasis added):

If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.

"
Why is it string.join(list) instead of list.join(string)?,https://stackoverflow.com/questions/493819/why-is-it-string-joinlist-instead-of-list-joinstring,2151,python;string;list,"It's because any iterable can be joined (e.g, list, tuple, dict, set), but its contents and the ""joiner"" must be strings.
For example:
'_'.join(['welcome', 'to', 'stack', 'overflow'])
'_'.join(('welcome', 'to', 'stack', 'overflow'))

'welcome_to_stack_overflow'

Using something other than strings will raise the following error:

TypeError: sequence item 0: expected str instance, int found

"
How do I append to a file?,https://stackoverflow.com/questions/4706499/how-do-i-append-to-a-file,2134,python;file;append,"Set the mode in open() to ""a"" (append) instead of ""w"" (write):
with open(""test.txt"", ""a"") as myfile:
    myfile.write(""appended text"")

The documentation lists all the available modes.
"
Is there a way to run Python on Android?,https://stackoverflow.com/questions/101754/is-there-a-way-to-run-python-on-android,2083,android;python;jython;ase;android-scripting,"One way is to use Kivy:

Open source Python library for rapid development of applications
  that make use of innovative user interfaces, such as multi-touch apps.



Kivy runs on Linux, Windows, OS X, Android and iOS. You can run the same [python] code on all supported platforms.

Kivy Showcase app 
"
Static methods in Python?,https://stackoverflow.com/questions/735975/static-methods-in-python,2062,python;static-methods,"Yep, using the staticmethod decorator:
class MyClass(object):
    @staticmethod
    def the_static_method(x):
        print(x)

MyClass.the_static_method(2)  # outputs 2

Note that some code might use the old method of defining a static method, using staticmethod as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3):
class MyClass(object):
    def the_static_method(x):
        print(x)
    the_static_method = staticmethod(the_static_method)

MyClass.the_static_method(2)  # outputs 2

This is entirely identical to the first example (using @staticmethod), just not using the nice decorator syntax.
Finally, use staticmethod sparingly! There are very few situations where static-methods are necessary in Python, and I've seen them used many times where a separate ""top-level"" function would have been clearer.

The following is verbatim from the documentation::

A static method does not receive an implicit first argument. To declare a static method, use this idiom:
class C:
    @staticmethod
    def f(arg1, arg2, ...): ...

The @staticmethod form is a function decorator – see the description of function definitions in Function definitions for details.
It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class.
Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see classmethod().
For more information on static methods, consult the documentation on the standard type hierarchy in The standard type hierarchy.
New in version 2.2.
Changed in version 2.4: Function decorator syntax added.

"
Installing specific package version with pip,https://stackoverflow.com/questions/5226311/installing-specific-package-version-with-pip,2060,python;mysql;pip;pypi;mysql-python,"TL;DR:
Update as of 2022-12-28:
pip install --force-reinstall -v
For example: pip install --force-reinstall -v ""MySQL_python==1.2.2""
What these options mean:

--force-reinstall is an option to reinstall all packages even if they are already up-to-date.
-v is for verbose. You can combine for even more verbosity (i.e. -vv) up to 3 times (e.g. --force-reinstall -vvv).

Thanks to @Peter for highlighting this (and it seems that the context of the question has broadened given the time when the question was first asked!), the documentation for Python discusses a caveat with using -I, in that it can break your installation if it was installed with a different package manager or if if your package is/was a different version.

Original answer:

pip install -Iv (i.e. pip install -Iv MySQL_python==1.2.2)


What these options mean:

-I stands for --ignore-installed which will ignore the installed packages, overwriting them.
-v is for verbose. You can combine for even more verbosity (i.e. -vv) up to 3 times (e.g. -Ivvv).

For more information, see pip install --help
First, I see two issues with what you're trying to do. Since you already have an installed version, you should either uninstall the current existing driver or use pip install -I MySQL_python==1.2.2
However, you'll soon find out that this doesn't work. If you look at pip's installation log, or if you do a pip install -Iv MySQL_python==1.2.2 you'll find that the PyPI URL link does not work for MySQL_python v1.2.2. You can verify this here: http://pypi.python.org/pypi/MySQL-python/1.2.2
The download link 404s and the fallback URL links are re-directing infinitely due to sourceforge.net's recent upgrade and PyPI's stale URL.
So to properly install the driver, you can follow these steps:
pip uninstall MySQL_python
pip install -Iv http://sourceforge.net/projects/mysql-python/files/mysql-python/1.2.2/MySQL-python-1.2.2.tar.gz/download

"
How do I split the definition of a long string over multiple lines?,https://stackoverflow.com/questions/10660435/how-do-i-split-the-definition-of-a-long-string-over-multiple-lines,2053,python;string;multiline;multilinestring,"Are you talking about multi-line strings? Easy, use triple quotes to start and end them.
s = """""" this is a very
        long string if I had the
        energy to type more and more ...""""""

You can use single quotes too (3 of them of course at start and end) and treat the resulting string s just like any other string.
NOTE: Just as with any string, anything between the starting and ending quotes becomes part of the string, so this example has a leading blank (as pointed out by @root45). This string will also contain both blanks and newlines.
I.e.,:
' this is a very\n        long string if I had the\n        energy to type more and more ...'

Finally, one can also construct long lines in Python like this:
 s = (""this is a very""
      ""long string too""
      ""for sure ...""
     )

which will not include any extra blanks or newlines (this is a deliberate example showing what the effect of skipping blanks will result in):
'this is a verylong string toofor sure ...'

No commas required, simply place the strings to be joined together into a pair of parenthesis and be sure to account for any needed blanks and newlines.
"
How to prettyprint a JSON file?,https://stackoverflow.com/questions/12943819/how-to-prettyprint-a-json-file,2038,python;json;formatting;pretty-print,"Use the indent= parameter of json.dump() or json.dumps() to specify how many spaces to indent by:
>>> import json
>>> your_json = '[""foo"", {""bar"": [""baz"", null, 1.0, 2]}]'
>>> parsed = json.loads(your_json)
>>> print(json.dumps(parsed, indent=4))
[
    ""foo"",
    {
        ""bar"": [
            ""baz"",
            null,
            1.0,
            2
        ]
    }
]

To parse a file, use json.load():
with open('filename.txt', 'r') as handle:
    parsed = json.load(handle)

"
Getting the class name of an instance,https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance,2025,python;introspection;instanceof;python-datamodel,"Have you tried the __name__ attribute of the class? ie type(x).__name__ will give you the name of the class, which I think is what you want.
>>> import itertools
>>> x = itertools.count(0)
>>> type(x).__name__
'count'

If you're still using Python 2, note that the above method works with new-style classes only (in Python 3+ all classes are ""new-style"" classes). Your code might use some old-style classes. The following works for both:
x.__class__.__name__

"
How do I get the row count of a Pandas DataFrame?,https://stackoverflow.com/questions/15943769/how-do-i-get-the-row-count-of-a-pandas-dataframe,2016,python;pandas;dataframe,"For a dataframe df, one can use any of the following:

len(df.index)
df.shape[0]
df[df.columns[0]].count() (== number of non-NaN values in first column)



Code to reproduce the plot:
import numpy as np
import pandas as pd
import perfplot

perfplot.save(
    ""out.png"",
    setup=lambda n: pd.DataFrame(np.arange(n * 3).reshape(n, 3)),
    n_range=[2**k for k in range(25)],
    kernels=[
        lambda df: len(df.index),
        lambda df: df.shape[0],
        lambda df: df[df.columns[0]].count(),
    ],
    labels=[""len(df.index)"", ""df.shape[0]"", ""df[df.columns[0]].count()""],
    xlabel=""Number of rows"",
)

"
How do I check if a string represents a number (float or int)?,https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-represents-a-number-float-or-int,2015,python;casting;floating-point;type-conversion;integer,"
Which, not only is ugly and slow

I'd dispute both.
A regex or other string parsing method would be uglier and slower.  
I'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames.
The issue is that any numeric conversion function has two kinds of results

A number, if the number is valid
A status code (e.g., via errno) or exception to show that no valid number could be parsed.

C (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.
I think your code for doing this is perfect.
"
Meaning of @classmethod and @staticmethod for beginner,https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner,1995,python;oop;static-methods;class-method,"Though classmethod and staticmethod are quite similar, there's a slight difference in usage for both entities: classmethod must have a reference to a class object as the first parameter, whereas staticmethod can have no parameters at all.
Example
class Date(object):
    
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

    @classmethod
    def from_string(cls, date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        date1 = cls(day, month, year)
        return date1

    @staticmethod
    def is_date_valid(date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        return day <= 31 and month <= 12 and year <= 3999

date2 = Date.from_string('11-09-2012')
is_date = Date.is_date_valid('11-09-2012')

Explanation
Let's assume an example of a class, dealing with date information (this will be our boilerplate):
class Date(object):
    
    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

This class obviously could be used to store information about certain dates (without timezone information; let's assume all dates are presented in UTC).
Here we have __init__, a typical initializer of Python class instances, which receives arguments as a typical instance method, having the first non-optional argument (self) that holds a reference to a newly created instance.
Class Method
We have some tasks that can be nicely done using classmethods.
Let's assume that we want to create a lot of Date class instances having date information coming from an outer source encoded as a string with format 'dd-mm-yyyy'. Suppose we have to do this in different places in the source code of our project.
So what we must do here is:

Parse a string to receive day, month and year as three integer variables or a 3-item tuple consisting of that variable.
Instantiate Date by passing those values to the initialization call.

This will look like:
day, month, year = map(int, string_date.split('-'))
date1 = Date(day, month, year)

For this purpose, C++ can implement such a feature with overloading, but Python lacks this overloading. Instead, we can use classmethod. Let's create another constructor.
    @classmethod
    def from_string(cls, date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        date1 = cls(day, month, year)
        return date1

date2 = Date.from_string('11-09-2012')

Let's look more carefully at the above implementation, and review what advantages we have here:

We've implemented date string parsing in one place and it's reusable now.
Encapsulation works fine here (if you think that you could implement string parsing as a single function elsewhere, this solution fits the OOP paradigm far better).
cls is the class itself, not an instance of the class. It's pretty cool because if we inherit our Date class, all children will have from_string defined also.

Static method
What about staticmethod? It's pretty similar to classmethod but doesn't take any obligatory parameters (like a class method or instance method does).
Let's look at the next use case.
We have a date string that we want to validate somehow. This task is also logically bound to the Date class we've used so far, but doesn't require instantiation of it.
Here is where staticmethod can be useful. Let's look at the next piece of code:
    @staticmethod
    def is_date_valid(date_as_string):
        day, month, year = map(int, date_as_string.split('-'))
        return day <= 31 and month <= 12 and year <= 3999

# usage:
is_date = Date.is_date_valid('11-09-2012')

So, as we can see from usage of staticmethod, we don't have any access to what the class is---it's basically just a function,  called syntactically like a method, but without access to the object and its internals (fields and other methods), which classmethod does have.
"
What&#39;s the canonical way to check for type in Python?,https://stackoverflow.com/questions/152580/whats-the-canonical-way-to-check-for-type-in-python,1994,python;types,"Use isinstance to check if o is an instance of str or any subclass of str:
if isinstance(o, str):

To check if the type of o is exactly str, excluding subclasses of str:
if type(o) is str:

See Built-in Functions in the Python Library Reference for relevant information.

Checking for strings in Python 2
For Python 2, this is a better way to check if o is a string:
if isinstance(o, basestring):

because this will also catch Unicode strings. unicode is not a subclass of str; both str and unicode are subclasses of basestring. In Python 3, basestring no longer exists since there's a strict separation of strings (str) and binary data (bytes).
Alternatively, isinstance accepts a tuple of classes. This will return True if o is an instance of any subclass of any of (str, unicode):
if isinstance(o, (str, unicode)):

"
How can I install packages using pip according to the requirements.txt file from a local directory?,https://stackoverflow.com/questions/7225900/how-can-i-install-packages-using-pip-according-to-the-requirements-txt-file-from,1969,python;virtualenv;pip,"This works for me:
$ pip install -r requirements.txt --no-index --find-links file:///tmp/packages

--no-index - Ignore package index (only look at --find-links URLs instead).
-f, --find-links <URL> - If <URL> is a URL or a path to an HTML file, then parse for links to archives. If <URL> is a local path or a file:// URL that's a directory, then look for archives in the directory listing.
"
How do I declare custom exceptions in modern Python?,https://stackoverflow.com/questions/1319615/how-do-i-declare-custom-exceptions-in-modern-python,1954,python;python-3.x;exception;python-dataclasses;pep352,"Maybe I missed the question, but why not:
class MyException(Exception):
    pass

To override something (or pass extra args), do this:
class ValidationError(Exception):
    def __init__(self, message, errors):            
        # Call the base class constructor with the parameters it needs
        super().__init__(message)
            
        # Now for your custom code...
        self.errors = errors

That way you could pass dict of error messages to the second param, and get to it later with e.errors.
In Python 2, you have to use this slightly more complex form of super():
super(ValidationError, self).__init__(message)

"
fatal error: Python.h: No such file or directory,https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory,1929,python;gcc;python-c-api,"I managed to solve this issue and generate the .so file in one command 
gcc -shared -o UtilcS.so
-fPIC -I/usr/include/python2.7 -lpython2.7  utilsmodule.c

"
Generate random integers between 0 and 9,https://stackoverflow.com/questions/3996904/generate-random-integers-between-0-and-9,1929,python;random;integer,"Try random.randrange:
from random import randrange
print(randrange(10))

"
What is the meaning of single and double underscore before an object name?,https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name,1909,python;oop;naming-conventions;identifier,"Single Underscore
In a class, names with a leading underscore indicate to other programmers that the attribute or method is intended to be be used inside that class. However, privacy is not enforced in any way.
Using leading underscores for functions in a module indicates it should not be imported from somewhere else.
From the PEP-8 style guide:

_single_leading_underscore: weak ""internal use"" indicator. E.g. from M import * does not import objects whose name starts with an underscore.

Double Underscore (Name Mangling)
From the Python docs:

Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes.

And a warning from the same page:

Name mangling is intended to give classes an easy way to define “private” instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; it still is possible for a determined soul to access or modify a variable that is considered private.

Example
>>> class MyClass():
...     def __init__(self):
...             self.__superprivate = ""Hello""
...             self._semiprivate = "", world!""
...
>>> mc = MyClass()
>>> print mc.__superprivate
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
AttributeError: myClass instance has no attribute '__superprivate'
>>> print mc._semiprivate
, world!
>>> print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}

"
Relative imports for the billionth time,https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time,1881,python;python-import;relative-path;python-packaging;relative-import,"Script vs. Module
Here's an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  Just knowing what directory a file is in does not determine what package Python thinks it is in.  That depends, additionally, on how you load the file into Python (by running or by importing).
There are two ways to load a Python file: as the top-level script, or as a
module.  A file is loaded as the top-level script if you execute it directly, for instance by typing python myfile.py on the command line.  It is loaded as a module when an import statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.
Naming
When a file is loaded, it is given a name (which is stored in its __name__ attribute).  If it was loaded as the top-level script, its name is __main__.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.
So for instance in your example:
package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
    moduleA.py

if you imported moduleX (note: imported, not directly executed), its name would be package.subpackage1.moduleX.  If you imported moduleA, its name would be package.moduleA.  However, if you directly run moduleX from the command line, its name will instead be __main__, and if you directly run moduleA from the command line, its name will be __main__.  When a module is run as the top-level script, it loses its normal name and its name is instead __main__.
Accessing a module NOT through its containing package
There is an additional wrinkle: the module's name depends on whether it was imported ""directly"" from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory package/subpackage1 and then do import moduleX, the name of moduleX will just be moduleX, and not package.subpackage1.moduleX.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module's name.
A special case is if you run the interpreter interactively (e.g., just type python and start entering Python code on the fly).  In this case, the name of that interactive session is __main__.
Now here is the crucial thing for your error message: if a module's name has no dots, it is not considered to be part of a package.  It doesn't matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.
Now look at the quote you included in your question:

Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.

Relative imports...
Relative imports use the module's name to determine where it is in a package.  When you use a relative import like from .. import foo, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module's name is package.subpackage1.moduleX, then ..moduleA would mean package.moduleA.  For a from .. import to work, the module's name must have at least as many dots as there are in the import statement.
... are only relative in a package
However, if your module's name is __main__, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use from .. import statements inside it.  If you try to do so, you will get the ""relative-import in non-package"" error.
Scripts can't import relative
What you probably did is you tried to run moduleX or the like from the command line.  When you did this, its name was set to __main__, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory ""too early"" without realizing it is part of a package.
Also remember that when you run the interactive interpreter, the ""name"" of that interactive session is always __main__.  Thus you cannot do relative imports directly from an interactive session.  Relative imports are only for use within module files.
Two solutions:

If you really do want to run moduleX directly, but you still want it to be considered part of a package, you can do python -m package.subpackage1.moduleX.  The -m tells Python to load it as a module, not as the top-level script.

Or perhaps you don't actually want to run moduleX, you just want to run some other script, say myfile.py, that uses functions inside moduleX.  If that is the case, put myfile.py somewhere else – not inside the package directory – and run it.  If inside myfile.py you do things like from package.moduleA import spam, it will work fine.


Notes

For either of these solutions, the package directory (package in your example) must be accessible from the Python module search path (sys.path).  If it is not, you will not be able to use anything in the package reliably at all.

Since Python 2.6, the module's ""name"" for package-resolution purposes is determined not just by its __name__ attributes but also by the __package__ attribute.  That's why I'm avoiding using the explicit symbol __name__ to refer to the module's ""name"".  Since Python 2.6 a module's ""name"" is effectively __package__ + '.' + __name__, or just __name__ if __package__ is None.)


"
Extracting extension from filename,https://stackoverflow.com/questions/541390/extracting-extension-from-filename,1866,python;filenames;file-extension,"Use os.path.splitext:
>>> import os
>>> filename, file_extension = os.path.splitext('/path/to/somefile.ext')
>>> filename
'/path/to/somefile'
>>> file_extension
'.ext'

Unlike most manual string-splitting attempts, os.path.splitext will correctly treat /a/b.c/d as having no extension instead of having extension .c/d, and it will treat .bashrc as having no extension instead of having extension .bashrc:
>>> os.path.splitext('/a/b.c/d')
('/a/b.c/d', '')
>>> os.path.splitext('.bashrc')
('.bashrc', '')

"
How do I write JSON data to a file?,https://stackoverflow.com/questions/12309269/how-do-i-write-json-data-to-a-file,1865,python;json,"data is a Python dictionary. It needs to be encoded as JSON before writing.
Use this for maximum compatibility (Python 2 and 3):
import json
with open('data.json', 'w') as f:
    json.dump(data, f)

On a modern system (i.e. Python 3 and UTF-8 support), you can write a nicer file using:
import json
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

See json documentation.
"
Relative imports in Python 3,https://stackoverflow.com/questions/16981921/relative-imports-in-python-3,1864,python;python-3.x;python-import,"
unfortunately, this module needs to be inside the package, and it also
needs to be runnable as a script, sometimes. Any idea how I could
achieve that?

It's quite common to have a layout like this...
main.py
mypackage/
    __init__.py
    mymodule.py
    myothermodule.py

...with a mymodule.py like this...
#!/usr/bin/env python3

# Exported function
def as_int(a):
    return int(a)

# Test function for module  
def _test():
    assert as_int('1') == 1

if __name__ == '__main__':
    _test()

...a myothermodule.py like this...
#!/usr/bin/env python3

from .mymodule import as_int

# Exported function
def add(a, b):
    return as_int(a) + as_int(b)

# Test function for module  
def _test():
    assert add('1', '1') == 2

if __name__ == '__main__':
    _test()

...and a main.py like this...
#!/usr/bin/env python3

from mypackage.myothermodule import add

def main():
    print(add('1', '1'))

if __name__ == '__main__':
    main()

...which works fine when you run main.py or mypackage/mymodule.py, but fails with mypackage/myothermodule.py, due to the relative import...
from .mymodule import as_int

The way you're supposed to run it is...
python3 -m mypackage.myothermodule

...but it's somewhat verbose, and doesn't mix well with a shebang line like #!/usr/bin/env python3.
The simplest fix for this case, assuming the name mymodule is globally unique, would be to avoid using relative imports, and just use...
from mymodule import as_int

...although, if it's not unique, or your package structure is more complex, you'll need to include the directory containing your package directory in PYTHONPATH, and do it like this...
from mypackage.mymodule import as_int

...or if you want it to work ""out of the box"", you can frob the PYTHONPATH in code first with this...
import sys
import os

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.dirname(SCRIPT_DIR))

from mypackage.mymodule import as_int

It's kind of a pain, but there's a clue as to why in an email written by a certain Guido van Rossum...

I'm -1 on this and on any other proposed twiddlings of the __main__
machinery. The only use case seems to be running scripts that happen
to be living inside a module's directory, which I've always seen as an
antipattern. To make me change my mind you'd have to convince me that
it isn't.

Whether running scripts inside a package is an antipattern or not is subjective, but personally I find it really useful in a package I have which contains some custom wxPython widgets, so I can run the script for any of the source files to display a wx.Frame containing only that widget for testing purposes.
"
How can I import a module dynamically given the full path?,https://stackoverflow.com/questions/67631/how-can-i-import-a-module-dynamically-given-the-full-path,1861,python;python-import;python-module,"Let's have MyClass in module.name module defined at /path/to/file.py. Below is how we import MyClass from this module
For Python 3.5+ use (docs):
import importlib.util
import sys
spec = importlib.util.spec_from_file_location(""module.name"", ""/path/to/file.py"")
foo = importlib.util.module_from_spec(spec)
sys.modules[""module.name""] = foo
spec.loader.exec_module(foo)
foo.MyClass()

For Python 3.3 and 3.4 use:
from importlib.machinery import SourceFileLoader

foo = SourceFileLoader(""module.name"", ""/path/to/file.py"").load_module()
foo.MyClass()

(Although this has been deprecated in Python 3.4.)
For Python 2 use:
import imp

foo = imp.load_source('module.name', '/path/to/file.py')
foo.MyClass()

There are equivalent convenience functions for compiled Python files and DLLs.
See also http://bugs.python.org/issue21436.
"
Use different Python version with virtualenv,https://stackoverflow.com/questions/1534210/use-different-python-version-with-virtualenv,1859,python;virtualenv;virtualenvwrapper,"NOTE: For Python 3.3+, see The Aelfinn's answer below.

Use the --python (or short -p) option when creating a virtualenv instance to specify the Python executable you want to use, e.g.:
virtualenv --python=""/usr/bin/python2.6"" ""/path/to/new/virtualenv/""

"
How do I get time of a Python program&#39;s execution?,https://stackoverflow.com/questions/1557571/how-do-i-get-time-of-a-python-programs-execution,1821,python;time;execution-time,"The simplest way in Python:
import time
start_time = time.time()
main()
print(""--- %s seconds ---"" % (time.time() - start_time))

This assumes that your program takes at least a tenth of second to run.
Prints:
--- 0.764891862869 seconds ---

"
Random string generation with upper case letters and digits,https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits,1806,python;string;random,"Answer in one line:
''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))

or even shorter starting with Python 3.6 using random.choices():
''.join(random.choices(string.ascii_uppercase + string.digits, k=N))

A cryptographically more secure version: see this post
''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))

In details, with a clean function for further reuse:
>>> import string
>>> import random
>>> def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
...    return ''.join(random.choice(chars) for _ in range(size))
...
>>> id_generator()
'G5G74W'
>>> id_generator(3, ""6793YUIO"")
'Y3U'

How does it work ?
We import string, a module that contains sequences of common ASCII characters, and random, a module that deals with random generation.
string.ascii_uppercase + string.digits just concatenates the list of characters representing uppercase ASCII chars and digits:
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.digits
'0123456789'
>>> string.ascii_uppercase + string.digits
'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

Then we use a list comprehension to create a list of 'n' elements:
>>> range(4) # range create a list of 'n' numbers
[0, 1, 2, 3]
>>> ['elem' for _ in range(4)] # we use range to create 4 times 'elem'
['elem', 'elem', 'elem', 'elem']

In the example above, we use [ to create the list, but we don't in the id_generator function so Python doesn't create the list in memory, but generates the elements on the fly, one by one (more about this here).
Instead of asking to create 'n' times the string elem, we will ask Python to create 'n' times a random character, picked from a sequence of characters:
>>> random.choice(""abcde"")
'a'
>>> random.choice(""abcde"")
'd'
>>> random.choice(""abcde"")
'b'

Therefore random.choice(chars) for _ in range(size) really is creating a sequence of size characters. Characters that are randomly picked from chars:
>>> [random.choice('abcde') for _ in range(3)]
['a', 'b', 'b']
>>> [random.choice('abcde') for _ in range(3)]
['e', 'b', 'e']
>>> [random.choice('abcde') for _ in range(3)]
['d', 'a', 'c']

Then we just join them with an empty string so the sequence becomes a string:
>>> ''.join(['a', 'b', 'b'])
'abb'
>>> [random.choice('abcde') for _ in range(3)]
['d', 'c', 'b']
>>> ''.join(random.choice('abcde') for _ in range(3))
'dac'

"
How do I print to stderr in Python?,https://stackoverflow.com/questions/5574702/how-do-i-print-to-stderr-in-python,1805,python;printing;stderr,"I found this to be the only one short, flexible, portable and readable:
import sys

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

The optional function eprint saves some repetition. It can be used in the same way as the standard print function:
>>> print(""Test"")
Test
>>> eprint(""Test"")
Test
>>> eprint(""foo"", ""bar"", ""baz"", sep=""---"")
foo---bar---baz

"
Save plot to image file instead of displaying it,https://stackoverflow.com/questions/9622163/save-plot-to-image-file-instead-of-displaying-it,1798,python;matplotlib;savefig,"When using matplotlib.pyplot.savefig, the file format can be specified by the extension:
from matplotlib import pyplot as plt

plt.savefig('foo.png')
plt.savefig('foo.pdf')

That gives a rasterized or vectorized output respectively.
In addition, there is sometimes undesirable whitespace around the image, which can be removed with:
plt.savefig('foo.png', bbox_inches='tight')

Note that if showing the plot, plt.show() should follow plt.savefig(); otherwise, the file image will be blank.
"
Selecting multiple columns in a Pandas dataframe,https://stackoverflow.com/questions/11285613/selecting-multiple-columns-in-a-pandas-dataframe,1791,python;pandas;dataframe;select;indexing,"The column names (which are strings) cannot be sliced in the manner you tried.
Here you have a couple of options. If you know from context which variables you want to slice out, you can just return a view of only those columns by passing a list into the __getitem__ syntax (the []'s).
df1 = df[['a', 'b']]

Alternatively, if it matters to index them numerically and not by their name (say your code should automatically do this without knowing the names of the first two columns) then you can do this instead:
df1 = df.iloc[:, 0:2] # Remember that Python does not slice inclusive of the ending index.

Additionally, you should familiarize yourself with the idea of a view into a Pandas object vs. a copy of that object. The first of the above methods will return a new copy in memory of the desired sub-object (the desired slices).
Sometimes, however, there are indexing conventions in Pandas that don't do this and instead give you a new variable that just refers to the same chunk of memory as the sub-object or slice in the original object. This will happen with the second way of indexing, so you can modify it with the .copy() method to get a regular copy. When this happens, changing what you think is the sliced object can sometimes alter the original object. Always good to be on the look out for this.
df1 = df.iloc[0, 0:2].copy() # To avoid the case where changing df1 also changes df

To use iloc, you need to know the column positions (or indices). As the column positions may change, instead of hard-coding indices, you can use iloc along with get_loc function of columns method of dataframe object to obtain column indices.
{df.columns.get_loc(c): c for idx, c in enumerate(df.columns)}

Now you can use this dictionary to access columns through names and using iloc.
"
Make a dictionary (dict) from separate lists of keys and values,https://stackoverflow.com/questions/209840/make-a-dictionary-dict-from-separate-lists-of-keys-and-values,1787,python;list;dictionary;key,"Like this:
keys = ['a', 'b', 'c']
values = [1, 2, 3]
dictionary = dict(zip(keys, values))
print(dictionary) # {'a': 1, 'b': 2, 'c': 3}

Voila :-)  The pairwise dict constructor and zip function are awesomely useful.
"
What is the best way of implementing a singleton in Python?,https://stackoverflow.com/questions/6760685/what-is-the-best-way-of-implementing-a-singleton-in-python,1787,python;singleton;decorator;base-class;metaclass,"You just need a decorator, different depending on the python version.
Notice how foo gets printed only once.

Python 3.2+
Implementation:
from functools import lru_cache

@lru_cache(maxsize=None)
class CustomClass(object):

    def __init__(self, arg):
        print(f""CustomClass initialised with {arg}"")
        self.arg = arg

Usage
c1 = CustomClass(""foo"")
c2 = CustomClass(""foo"")
c3 = CustomClass(""bar"")

print(c1 == c2)
print(c1 == c3)

Output
>>> CustomClass initialised with foo
>>> CustomClass initialised with bar
>>> True
>>> False


Python 3.9+
Implementation:
from functools import cache

@cache
class CustomClass(object):
    ...

"
What does __all__ mean in Python?,https://stackoverflow.com/questions/44834/what-does-all-mean-in-python,1786,python;syntax;namespaces;python-import,"It's a list of public objects of that module, as interpreted by import *. It overrides the default of hiding everything that begins with an underscore.
"
How do I get the filename without the extension from a path in Python?,https://stackoverflow.com/questions/678236/how-do-i-get-the-filename-without-the-extension-from-a-path-in-python,1776,python;string;path,"Python 3.4+
Use pathlib.Path.stem
>>> from pathlib import Path
>>> Path(""/path/to/file.txt"").stem
'file'
>>> Path(""/path/to/file.tar.gz"").stem
'file.tar'

Python < 3.4
Use os.path.splitext in combination with os.path.basename:
>>> os.path.splitext(os.path.basename(""/path/to/file.txt""))[0]
'file'
>>> os.path.splitext(os.path.basename(""/path/to/file.tar.gz""))[0]
'file.tar'

"
How do I profile a Python script?,https://stackoverflow.com/questions/582336/how-do-i-profile-a-python-script,1745,python;performance;optimization;time-complexity;profiling,"Python includes a profiler called cProfile. It not only gives the total running time, but also times each function separately, and tells you how many times each function was called, making it easy to determine where you should make optimizations.
You can call it from within your code, or from the interpreter, like this:
import cProfile
cProfile.run('foo()')

Even more usefully, you can invoke cProfile when running a script:
python -m cProfile myscript.py

Or when running a module:
python -m cProfile -m mymodule

To make it even easier, I made a little batch file called 'profile.bat':
python -m cProfile %1

So all I have to do is run:
profile euler048.py

And I get this:
1007 function calls in 0.061 CPU seconds

Ordered by: standard name
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    0.061    0.061 <string>:1(<module>)
 1000    0.051    0.000    0.051    0.000 euler048.py:2(<lambda>)
    1    0.005    0.005    0.061    0.061 euler048.py:2(<module>)
    1    0.000    0.000    0.061    0.061 {execfile}
    1    0.002    0.002    0.053    0.053 {map}
    1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler objects}
    1    0.000    0.000    0.000    0.000 {range}
    1    0.003    0.003    0.003    0.003 {sum}

For more information, check out this tutorial from PyCon 2013 titled
Python Profiling
Also via YouTube.
"
if/else in a list comprehension,https://stackoverflow.com/questions/4260280/if-else-in-a-list-comprehension,1734,python;list;if-statement;list-comprehension,"You can totally do that. It's just an ordering issue:
[f(x) if x is not None else '' for x in xs]

In general,
[f(x) if condition else g(x) for x in sequence]

And, for list comprehensions with if conditions only,
[f(x) for x in sequence if condition]

Note that this actually uses a different language construct, a conditional expression, which itself is not part of the comprehension syntax, while the if after the for…in is part of list comprehensions and used to filter elements from the source iterable.

Conditional expressions can be used in all kinds of situations where you want to choose between two expression values based on some condition. This does the same as the ternary operator ?: that exists in other languages. For example:
value = 123
print(value, 'is', 'even' if value % 2 == 0 else 'odd')

"
How to put the legend outside the plot,https://stackoverflow.com/questions/4700614/how-to-put-the-legend-outside-the-plot,1717,python;matplotlib;seaborn;legend,"
You can make the legend text smaller by specifying set_size of FontProperties.
Resources:

Legend guide
matplotlib.legend
matplotlib.pyplot.legend
matplotlib.font_manager

set_size(self, size)
Valid font size are xx-small, x-small, small, medium, large, x-large, xx-large, larger, smaller, and None.


Real Python: Python Plotting With Matplotlib (Guide)



import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

fontP = FontProperties()
fontP.set_size('xx-small')

p1, = plt.plot([1, 2, 3], label='Line 1')
p2, = plt.plot([3, 2, 1], label='Line 2')
plt.legend(handles=[p1, p2], title='title', bbox_to_anchor=(1.05, 1), loc='upper left', prop=fontP)



fontsize='xx-small' also works, without importing FontProperties.

plt.legend(handles=[p1, p2], title='title', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='xx-small')

"
How to check for NaN values,https://stackoverflow.com/questions/944700/how-to-check-for-nan-values,1717,python;math;nan,"Use math.isnan:
>>> import math
>>> x = float('nan')
>>> math.isnan(x)
True

"
Replacements for switch statement in Python?,https://stackoverflow.com/questions/60208/replacements-for-switch-statement-in-python,1716,python;switch-statement,"Python 3.10 (2021) introduced the match-case statement, which provides a first-class implementation of a ""switch"" for Python. For example:
def f(x):
    match x:
        case 'a':
            return 1
        case 'b':
            return 2
        case _:
            return 0   # 0 is the default case if x is not found

The match-case statement is considerably more powerful than this simple example.
Documentation:

match statements (under the ""More Control Flow Tools"" page)
The match statement (under ""Compound statements"" page)
PEP 634 – Structural Pattern Matching: Specification
PEP 636 – Structural Pattern Matching: Tutorial


If you need to support Python ≤ 3.9, use a dictionary instead:
def f(x):
    return {
        'a': 1,
        'b': 2,
    }.get(x, 0)  # default case

"
Why do Python classes inherit object?,https://stackoverflow.com/questions/4015417/why-do-python-classes-inherit-object,1711,python;class;oop;object;inheritance,"
Is there any reason for a class declaration to inherit from object?

In Python 3, apart from compatibility between Python 2 and 3, no reason. In Python 2, many reasons. 

Python 2.x story:
In Python 2.x (from 2.2 onwards) there's two styles of classes depending on the presence or absence of object as a base-class:

""classic"" style classes: they don't have object as a base class:
>>> class ClassicSpam:      # no base class
...     pass
>>> ClassicSpam.__bases__
()

""new"" style classes: they have, directly or indirectly (e.g inherit from a built-in type), object as a base class:
>>> class NewSpam(object):           # directly inherit from object
...    pass
>>> NewSpam.__bases__
(<type 'object'>,)
>>> class IntSpam(int):              # indirectly inherit from object...
...    pass
>>> IntSpam.__bases__
(<type 'int'>,) 
>>> IntSpam.__bases__[0].__bases__   # ... because int inherits from object  
(<type 'object'>,)


Without a doubt, when writing a class you'll always want to go for new-style classes. The perks of doing so are numerous, to list some of them:

Support for descriptors. Specifically, the following constructs are made possible with descriptors: 

classmethod: A method that receives the class as an implicit argument instead of the instance.
staticmethod: A method that does not receive the implicit argument self as a first argument.
properties with property: Create functions for managing the getting, setting and deleting of an attribute. 
__slots__: Saves memory consumptions of a class and also results in faster attribute access. Of course, it does impose limitations.

The __new__ static method: lets you customize how new class instances are created. 
Method resolution order (MRO): in what order the base classes of a class will be searched when trying to resolve which method to call. 
Related to MRO, super calls. Also see, super() considered super.

If you don't inherit from object, forget these. A more exhaustive description of the previous bullet points along with other perks of ""new"" style classes can be found here.
One of the downsides of new-style classes is that the class itself is more memory demanding. Unless you're creating many class objects, though, I doubt this would be an issue and it's a negative sinking in a sea of positives.

Python 3.x story:
In Python 3, things are simplified. Only new-style classes exist (referred to plainly as classes) so, the only difference in adding object is requiring you to type in 8 more characters. This:
class ClassicSpam:
    pass

is completely equivalent (apart from their name :-) to this:
class NewSpam(object):
     pass

and to this:
class Spam():
    pass

All have object in their __bases__.
>>> [object in cls.__bases__ for cls in {Spam, NewSpam, ClassicSpam}]
[True, True, True]


So, what should you do?
In Python 2: always inherit from object explicitly. Get the perks.
In Python 3: inherit from object if you are writing code that tries to be Python agnostic, that is, it needs to work both in Python 2 and in Python 3. Otherwise don't, it really makes no difference since Python inserts it for you behind the scenes.
"
How do I reverse a string in Python?,https://stackoverflow.com/questions/931092/how-do-i-reverse-a-string-in-python,1704,python;string,"Using slicing:
>>> 'hello world'[::-1]
'dlrow olleh'


Slice notation takes the form [start:stop:step]. In this case, we omit the start and stop positions since we want the whole string. We also use step = -1, which means, ""repeatedly step from right to left by 1 character"".
"
How do I check if a directory exists in Python?,https://stackoverflow.com/questions/8933237/how-do-i-check-if-a-directory-exists-in-python,1666,python;directory,"Use os.path.isdir for directories only:
>>> import os
>>> os.path.isdir('new_folder')
True

Use os.path.exists for both files and directories:
>>> import os
>>> os.path.exists(os.path.join(os.getcwd(), 'new_folder', 'file.txt'))
False

Alternatively, you can use pathlib:
 >>> from pathlib import Path
 >>> Path('new_folder').is_dir()
 True
 >>> (Path.cwd() / 'new_folder' / 'file.txt').exists()
 False

"
What is the Python 3 equivalent of &quot;python -m SimpleHTTPServer&quot;,https://stackoverflow.com/questions/7943751/what-is-the-python-3-equivalent-of-python-m-simplehttpserver,1651,python;python-3.x;httpserver;simplehttpserver,"From the docs:

The SimpleHTTPServer module has been merged into http.server in Python 3.0. The 2to3 tool will automatically adapt imports when converting your sources to 3.0.

So, your command is python -m http.server, or depending on your installation, it can be:
python3 -m http.server

"
What is setup.py?,https://stackoverflow.com/questions/1471994/what-is-setup-py,1647,python;pypi;setup.py;python-packaging,"setup.py is a Python file, the presence of which is an indication that the module/package you are about to install has likely been packaged and distributed with Distutils, which is the standard for distributing Python Modules.
This allows you to easily install Python packages. Often it's enough to write:
$ pip install . 

pip will use setup.py to install your module. Avoid calling setup.py directly.
"
How can I flush the output of the print function?,https://stackoverflow.com/questions/230751/how-can-i-flush-the-output-of-the-print-function,1634,python;printing;flush;output-buffering,"In Python 3, print can take an optional flush argument:
print(""Hello, World!"", flush=True)

In Python 2, after calling print, do:
import sys
sys.stdout.flush()

By default, print prints to sys.stdout (see the documentation for more about file objects).
"
Create a dictionary with comprehension,https://stackoverflow.com/questions/1747817/create-a-dictionary-with-comprehension,1608,python;dictionary;list-comprehension;dictionary-comprehension,"Use a dict comprehension (Python 2.7 and later):
{key: value for key, value in zip(keys, values)}


Alternatively, use the dict constructor:
pairs = [('a', 1), ('b', 2)]
dict(pairs)                          # → {'a': 1, 'b': 2}
dict((k, v + 10) for k, v in pairs)  # → {'a': 11, 'b': 12}

Given separate lists of keys and values, use the dict constructor with zip:
keys = ['a', 'b']
values = [1, 2]
dict(zip(keys, values))              # → {'a': 1, 'b': 2}

"
Convert integer to string in Python,https://stackoverflow.com/questions/961632/convert-integer-to-string-in-python,1595,python;string;integer,">>> str(42)
'42'

>>> int('42')
42

Links to the documentation:

int()
str()

str(x) converts any object x to a string by calling x.__str__(), or repr(x) if x doesn't have a __str__() method.
"
Catch and print full Python exception traceback without halting/exiting the program,https://stackoverflow.com/questions/3702675/catch-and-print-full-python-exception-traceback-without-halting-exiting-the-prog,1592,python;exception;try-catch;traceback,"Some other answer have already pointed out the traceback module.
Please notice that with print_exc, in some corner cases, you will not obtain what you would expect. In Python 2.x:
import traceback

try:
    raise TypeError(""Oups!"")
except Exception, err:
    try:
        raise TypeError(""Again !?!"")
    except:
        pass

    traceback.print_exc()

...will display the traceback of the last exception:
Traceback (most recent call last):
  File ""e.py"", line 7, in <module>
    raise TypeError(""Again !?!"")
TypeError: Again !?!

If you really need to access the original traceback one solution is to cache the exception infos as returned from exc_info in a local variable and display it using print_exception:
import traceback
import sys

try:
    raise TypeError(""Oups!"")
except Exception, err:
    try:
        exc_info = sys.exc_info()

        # do you usefull stuff here
        # (potentially raising an exception)
        try:
            raise TypeError(""Again !?!"")
        except:
            pass
        # end of useful stuff


    finally:
        # Display the *original* exception
        traceback.print_exception(*exc_info)
        del exc_info

Producing:
Traceback (most recent call last):
  File ""t.py"", line 6, in <module>
    raise TypeError(""Oups!"")
TypeError: Oups!

Few pitfalls with this though:

From the doc of sys_info:

Assigning the traceback return value to a local variable in a function that is handling an exception will cause a circular reference. This will prevent anything referenced by a local variable in the same function or by the traceback from being garbage collected. [...] If you do need the traceback, make sure to delete it after use (best done with a try ... finally statement)

but, from the same doc:

Beginning with Python 2.2, such cycles are automatically reclaimed when garbage collection is enabled and they become unreachable, but it remains more efficient to avoid creating cycles.



On the other hand, by allowing you to access the traceback associated with an exception, Python 3 produce a less surprising result:
import traceback

try:
    raise TypeError(""Oups!"")
except Exception as err:
    try:
        raise TypeError(""Again !?!"")
    except:
        pass

    traceback.print_tb(err.__traceback__)

... will display:
  File ""e3.py"", line 4, in <module>
    raise TypeError(""Oups!"")

"
Use of *args and **kwargs,https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs,1582,python;args;keyword-argument,"The syntax is the * and **.  The names *args and **kwargs are only by convention but there's no hard requirement to use them.
You would use *args when you're not sure how many arguments might be passed to your function, i.e. it allows you pass an arbitrary number of arguments to your function.  For example:
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print( '{0}. {1}'.format(count, thing))
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage

Similarly, **kwargs allows you to handle named arguments that you have not defined in advance:
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print( '{0} = {1}'.format(name, value))
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit

You can use these along with named arguments too.  The explicit arguments get values first and then everything else is passed to *args and **kwargs.  The named arguments come first in the list.  For example:
def table_things(titlestring, **kwargs)

You can also use both in the same function definition but *args must occur before **kwargs.
You can also use the * and ** syntax when calling a function.  For example:
>>> def print_three_things(a, b, c):
...     print( 'a = {0}, b = {1}, c = {2}'.format(a,b,c))
...
>>> mylist = ['aardvark', 'baboon', 'cat']
>>> print_three_things(*mylist)
a = aardvark, b = baboon, c = cat

As you can see in this case it takes the list (or tuple) of items and unpacks it. By this it matches them to the arguments in the function.  Of course, you could have a * both in the function definition and in the function call.
"
How do I sort a dictionary by key?,https://stackoverflow.com/questions/9001509/how-do-i-sort-a-dictionary-by-key,1576,python;sorting;dictionary,"
Note: for Python 3.7+, see this answer

Standard Python dictionaries are unordered (until Python 3.7). Even if you sorted the (key,value) pairs, you wouldn't be able to store them in a dict in a way that would preserve the ordering.
The easiest way is to use OrderedDict, which remembers the order in which the elements have been inserted:
In [1]: import collections

In [2]: d = {2:3, 1:89, 4:5, 3:0}

In [3]: od = collections.OrderedDict(sorted(d.items()))

In [4]: od
Out[4]: OrderedDict([(1, 89), (2, 3), (3, 0), (4, 5)])

Never mind the way od is printed out; it'll work as expected:
In [11]: od[1]
Out[11]: 89

In [12]: od[3]
Out[12]: 0

In [13]: for k, v in od.iteritems(): print k, v
   ....: 
1 89
2 3
3 0
4 5

Python 3
For Python 3 users, one needs to use the .items() instead of .iteritems():
In [13]: for k, v in od.items(): print(k, v)
   ....: 
1 89
2 3
3 0
4 5

"
Change column type in pandas,https://stackoverflow.com/questions/15891038/change-column-type-in-pandas,1575,python;pandas;dataframe;types;type-conversion,"You have four main options for converting types in pandas:

to_numeric() - provides functionality to safely convert non-numeric types (e.g. strings) to a suitable numeric type. (See also to_datetime() and to_timedelta().)

astype() - convert (almost) any type to (almost) any other type (even if it's not necessarily sensible to do so). Also allows you to convert to categorial types (very useful).

infer_objects() - a utility method to convert object columns holding Python objects to a pandas type if possible.

convert_dtypes() - convert DataFrame columns to the ""best possible""  dtype that supports pd.NA (pandas' object to indicate a missing value).


Read on for more detailed explanations and usage of each of these methods.

1. to_numeric()
The best way to convert one or more columns of a DataFrame to numeric values is to use pandas.to_numeric().
This function will try to change non-numeric objects (such as strings) into integers or floating-point numbers as appropriate.
Basic usage
The input to to_numeric() is a Series or a single column of a DataFrame.
>>> s = pd.Series([""8"", 6, ""7.5"", 3, ""0.9""]) # mixed string and numeric values
>>> s
0      8
1      6
2    7.5
3      3
4    0.9
dtype: object

>>> pd.to_numeric(s) # convert everything to float values
0    8.0
1    6.0
2    7.5
3    3.0
4    0.9
dtype: float64

As you can see, a new Series is returned. Remember to assign this output to a variable or column name to continue using it:
# convert Series
my_series = pd.to_numeric(my_series)

# convert column ""a"" of a DataFrame
df[""a""] = pd.to_numeric(df[""a""])

You can also use it to convert multiple columns of a DataFrame via the apply() method:
# convert all columns of DataFrame
df = df.apply(pd.to_numeric) # convert all columns of DataFrame

# convert just columns ""a"" and ""b""
df[[""a"", ""b""]] = df[[""a"", ""b""]].apply(pd.to_numeric)

As long as your values can all be converted, that's probably all you need.
Error handling
But what if some values can't be converted to a numeric type?
to_numeric() also takes an errors keyword argument that allows you to force non-numeric values to be NaN, or simply ignore columns containing these values.
Here's an example using a Series of strings s which has the object dtype:
>>> s = pd.Series(['1', '2', '4.7', 'pandas', '10'])
>>> s
0         1
1         2
2       4.7
3    pandas
4        10
dtype: object

The default behaviour is to raise if it can't convert a value. In this case, it can't cope with the string 'pandas':
>>> pd.to_numeric(s) # or pd.to_numeric(s, errors='raise')
ValueError: Unable to parse string

Rather than fail, we might want 'pandas' to be considered a missing/bad numeric value. We can coerce invalid values to NaN as follows using the errors keyword argument:
>>> pd.to_numeric(s, errors='coerce')
0     1.0
1     2.0
2     4.7
3     NaN
4    10.0
dtype: float64

The third option for errors is just to ignore the operation if an invalid value is encountered:
>>> pd.to_numeric(s, errors='ignore')
# the original Series is returned untouched

This last option is particularly useful for converting your entire DataFrame, but don't know which of our columns can be converted reliably to a numeric type. In that case, just write:
df.apply(pd.to_numeric, errors='ignore')

The function will be applied to each column of the DataFrame. Columns that can be converted to a numeric type will be converted, while columns that cannot (e.g. they contain non-digit strings or dates) will be left alone.
Downcasting
By default, conversion with to_numeric() will give you either an int64 or float64 dtype (or whatever integer width is native to your platform).
That's usually what you want, but what if you wanted to save some memory and use a more compact dtype, like float32, or int8?
to_numeric() gives you the option to downcast to either 'integer', 'signed', 'unsigned', 'float'. Here's an example for a simple series s of integer type:
>>> s = pd.Series([1, 2, -7])
>>> s
0    1
1    2
2   -7
dtype: int64

Downcasting to 'integer' uses the smallest possible integer that can hold the values:
>>> pd.to_numeric(s, downcast='integer')
0    1
1    2
2   -7
dtype: int8

Downcasting to 'float' similarly picks a smaller than normal floating type:
>>> pd.to_numeric(s, downcast='float')
0    1.0
1    2.0
2   -7.0
dtype: float32


2. astype()
The astype() method enables you to be explicit about the dtype you want your DataFrame or Series to have. It's very versatile in that you can try and go from one type to any other.
Basic usage
Just pick a type: you can use a NumPy dtype (e.g. np.int16), some Python types (e.g. bool), or pandas-specific types (like the categorical dtype).
Call the method on the object you want to convert and astype() will try and convert it for you:
# convert all DataFrame columns to the int64 dtype
df = df.astype(int)

# convert column ""a"" to int64 dtype and ""b"" to complex type
df = df.astype({""a"": int, ""b"": complex})

# convert Series to float16 type
s = s.astype(np.float16)

# convert Series to Python strings
s = s.astype(str)

# convert Series to categorical type - see docs for more details
s = s.astype('category')

Notice I said ""try"" - if astype() does not know how to convert a value in the Series or DataFrame, it will raise an error. For example, if you have a NaN or inf value you'll get an error trying to convert it to an integer.
As of pandas 0.20.0, this error can be suppressed by passing errors='ignore'. Your original object will be returned untouched.
Be careful
astype() is powerful, but it will sometimes convert values ""incorrectly"". For example:
>>> s = pd.Series([1, 2, -7])
>>> s
0    1
1    2
2   -7
dtype: int64

These are small integers, so how about converting to an unsigned 8-bit type to save memory?
>>> s.astype(np.uint8)
0      1
1      2
2    249
dtype: uint8

The conversion worked, but the -7 was wrapped round to become 249 (i.e. 28 - 7)!
Trying to downcast using pd.to_numeric(s, downcast='unsigned') instead could help prevent this error.

3. infer_objects()
Version 0.21.0 of pandas introduced the method infer_objects() for converting columns of a DataFrame that have an object datatype to a more specific type (soft conversions).
For example, here's a DataFrame with two columns of object type. One holds actual integers and the other holds strings representing integers:
>>> df = pd.DataFrame({'a': [7, 1, 5], 'b': ['3','2','1']}, dtype='object')
>>> df.dtypes
a    object
b    object
dtype: object

Using infer_objects(), you can change the type of column 'a' to int64:
>>> df = df.infer_objects()
>>> df.dtypes
a     int64
b    object
dtype: object

Column 'b' has been left alone since its values were strings, not integers. If you wanted to force both columns to an integer type, you could use df.astype(int) instead.

4. convert_dtypes()
Version 1.0 and above includes a method convert_dtypes() to convert Series and DataFrame columns to the best possible dtype that supports the pd.NA missing value.
Here ""best possible"" means the type most suited to hold the values. For example, this a pandas integer type, if all of the values are integers (or missing values): an object column of Python integer objects are converted to Int64, a column of NumPy int32 values, will become the pandas dtype Int32.
With our object DataFrame df, we get the following result:
>>> df.convert_dtypes().dtypes                                             
a     Int64
b    string
dtype: object

Since column 'a' held integer values, it was converted to the Int64 type (which is capable of holding missing values, unlike int64).
Column 'b' contained string objects, so was changed to pandas' string dtype.
By default, this method will infer the type from object values in each column. We can change this by passing infer_objects=False:
>>> df.convert_dtypes(infer_objects=False).dtypes                          
a    object
b    string
dtype: object

Now column 'a' remained an object column: pandas knows it can be described as an 'integer' column (internally it ran infer_dtype) but didn't infer exactly what dtype of integer it should have so did not convert it. Column 'b' was again converted to 'string' dtype as it was recognised as holding 'string' values.
"
What are the differences between type() and isinstance()?,https://stackoverflow.com/questions/1549801/what-are-the-differences-between-type-and-isinstance,1573,python;oop;inheritance;types,"To summarize the contents of other (already good!) answers, isinstance caters for inheritance (an instance of a derived class is an instance of a base class, too), while checking for equality of type does not (it demands identity of types and rejects instances of subtypes, AKA subclasses).
Normally, in Python, you want your code to support inheritance, of course (since inheritance is so handy, it would be bad to stop code using yours from using it!), so isinstance is less bad than checking identity of types because it seamlessly supports inheritance.
It's not that isinstance is good, mind you—it's just less bad than checking equality of types.  The normal, Pythonic, preferred solution is almost invariably ""duck typing"": try using the argument as if it was of a certain desired type, do it in a try/except statement catching all exceptions that could arise if the argument was not in fact of that type (or any other type nicely duck-mimicking it;-), and in the except clause, try something else (using the argument ""as if"" it was of some other type).
basestring is, however, quite a special case—a builtin type that exists only to let you use isinstance (both str and unicode subclass basestring). Strings are sequences (you could loop over them, index them, slice them, ...), but you generally want to treat them as ""scalar"" types—it's somewhat incovenient (but a reasonably frequent use case) to treat all kinds of strings (and maybe other scalar types, i.e., ones you can't loop on) one way, all containers (lists, sets, dicts, ...) in another way, and basestring plus isinstance helps you do that—the overall structure of this idiom is something like:
if isinstance(x, basestring)
  return treatasscalar(x)
try:
  return treatasiter(iter(x))
except TypeError:
  return treatasscalar(x)

You could say that basestring is an Abstract Base Class (""ABC"")—it offers no concrete functionality to subclasses, but rather exists as a ""marker"", mainly for use with isinstance. The concept is obviously a growing one in Python, since PEP 3119, which introduces a generalization of it, was accepted and has been implemented starting with Python 2.6 and 3.0.
The PEP makes it clear that, while ABCs can often substitute for duck typing, there is generally no big pressure to do that (see here). ABCs as implemented in recent Python versions do however offer extra goodies: isinstance (and issubclass) can now mean more than just ""[an instance of] a derived class"" (in particular, any class can be ""registered"" with an ABC so that it will show as a subclass, and its instances as instances of the ABC); and ABCs can also offer extra convenience to actual subclasses in a very natural way via Template Method design pattern applications (see here and here [[part II]] for more on the TM DP, in general and specifically in Python, independent of ABCs).
For the underlying mechanics of ABC support as offered in Python 2.6, see here; for their 3.1 version, very similar, see here.  In both versions, standard library module collections (that's the 3.1 version—for the very similar 2.6 version, see here) offers several useful ABCs.
For the purpose of this answer, the key thing to retain about ABCs (beyond an arguably more natural placement for TM DP functionality, compared to the classic Python alternative of mixin classes such as UserDict.DictMixin) is that they make isinstance (and issubclass) much more attractive and pervasive (in Python 2.6 and going forward) than they used to be (in 2.5 and before), and therefore, by contrast, make checking type equality an even worse practice in recent Python versions than it already used to be.
"
Is there a built-in function to print all the current properties and values of an object?,https://stackoverflow.com/questions/192109/is-there-a-built-in-function-to-print-all-the-current-properties-and-values-of-a,1531,python;debugging;introspection;pretty-print;python-datamodel,"You are really mixing together two different things.
Use dir(), vars() or the inspect module to get what you are interested in (I use __builtins__ as an example; you can use any object instead).
>>> l = dir(__builtins__)
>>> d = __builtins__.__dict__

Print that dictionary however fancy you like:
>>> print l
['ArithmeticError', 'AssertionError', 'AttributeError',...

or
>>> from pprint import pprint
>>> pprint(l)
['ArithmeticError',
 'AssertionError',
 'AttributeError',
 'BaseException',
 'DeprecationWarning',
...

>>> pprint(d, indent=2)
{ 'ArithmeticError': <type 'exceptions.ArithmeticError'>,
  'AssertionError': <type 'exceptions.AssertionError'>,
  'AttributeError': <type 'exceptions.AttributeError'>,
...
  '_': [ 'ArithmeticError',
         'AssertionError',
         'AttributeError',
         'BaseException',
         'DeprecationWarning',
...

Pretty printing is also available in the interactive debugger as a command:
(Pdb) pp vars()
{'__builtins__': {'ArithmeticError': <type 'exceptions.ArithmeticError'>,
                  'AssertionError': <type 'exceptions.AssertionError'>,
                  'AttributeError': <type 'exceptions.AttributeError'>,
                  'BaseException': <type 'exceptions.BaseException'>,
                  'BufferError': <type 'exceptions.BufferError'>,
                  ...
                  'zip': <built-in function zip>},
 '__file__': 'pass.py',
 '__name__': '__main__'}

"
How to convert string to bytes in Python 3,https://stackoverflow.com/questions/7585435/how-to-convert-string-to-bytes-in-python-3,1527,python;string;character-encoding;python-3.x,"If you look at the docs for bytes, it points you to bytearray:

bytearray([source[, encoding[, errors]]])
Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Byte Array Methods.
The optional source parameter can be used to initialize the array in a few different ways:
If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode().
If it is an integer, the array will have that size and will be initialized with null bytes.
If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array.
If it is an iterable, it must be an iterable of integers in the range 0 <= x < 256, which are used as the initial contents of the array.
Without an argument, an array of size 0 is created.

So bytes can do much more than just encode a string. It's Pythonic that it would allow you to call the constructor with any type of source parameter that makes sense.
For  encoding a string, I think that some_string.encode(encoding) is more Pythonic than using the constructor, because it is the most self documenting -- ""take this string and encode it with this encoding"" is clearer than bytes(some_string, encoding) -- there is no explicit verb when you use the constructor.
I checked the Python source. If you pass a unicode string to bytes using CPython, it calls PyUnicode_AsEncodedString, which is the implementation of encode; so you're just skipping a level of indirection if you call encode yourself.
Also, see Serdalis' comment -- unicode_string.encode(encoding) is also more Pythonic because its inverse is byte_string.decode(encoding) and symmetry is nice.
"
How do I move a file in Python?,https://stackoverflow.com/questions/8858008/how-do-i-move-a-file-in-python,1517,python;file;file-handling;python-os,"os.rename(), os.replace(), or shutil.move()
All employ the same syntax:
import os
import shutil

os.rename(""path/to/current/file.foo"", ""path/to/new/destination/for/file.foo"")
os.replace(""path/to/current/file.foo"", ""path/to/new/destination/for/file.foo"")
shutil.move(""path/to/current/file.foo"", ""path/to/new/destination/for/file.foo"")


The filename (""file.foo"") must be included in both the source and destination arguments. If it differs between the two, the file will be renamed as well as moved.
The directory within which the new file is being created must already exist.
On Windows, a file with that name must not exist or an exception will be raised, but os.replace() will silently replace a file even in that occurrence.
shutil.move simply calls os.rename in most cases. However, if the destination is on a different disk than the source, it will instead copy and then delete the source file.

"
UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode character u&#39;\xa0&#39; in position 20: ordinal not in range(128),https://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20,1516,python;unicode;beautifulsoup;python-2.x;python-unicode,"Read the Python Unicode HOWTO. This error is the very first example.
Do not use str() to convert from unicode to encoded text / bytes.
Instead, use .encode() to encode the string:
p.agent_info = u' '.join((agent_contact, agent_telno)).encode('utf-8').strip()

or work entirely in unicode.
"
Removing duplicates in lists,https://stackoverflow.com/questions/7961363/removing-duplicates-in-lists,1512,python;algorithm;list;duplicates;intersection,"The common approach to get a unique collection of items is to use a set. Sets are unordered collections of distinct objects. To create a set from any iterable, you can simply pass it to the built-in set() function. If you later need a real list again, you can similarly pass the set to the list() function.
The following example should cover whatever you are trying to do:
>>> t = [1, 2, 3, 1, 2, 3, 5, 6, 7, 8]
>>> list(set(t))
[1, 2, 3, 5, 6, 7, 8]
>>> s = [1, 2, 3]
>>> list(set(t) - set(s))
[8, 5, 6, 7]

As you can see from the example result, the original order is not maintained. As mentioned above, sets themselves are unordered collections, so the order is lost. When converting a set back to a list, an arbitrary order is created.
Maintaining order
If order is important to you, then you will have to use a different mechanism. A very common solution for this is to rely on OrderedDict to keep the order of keys during insertion:
>>> from collections import OrderedDict
>>> list(OrderedDict.fromkeys(t))
[1, 2, 3, 5, 6, 7, 8]

Starting with Python 3.7, the built-in dictionary is guaranteed to maintain the insertion order as well, so you can also use that directly if you are on Python 3.7 or later (or CPython 3.6):
>>> list(dict.fromkeys(t))
[1, 2, 3, 5, 6, 7, 8]

Note that this may have some overhead of creating a dictionary first, and then creating a list from it. If you don’t actually need to preserve the order, you’re often better off using a set, especially because it gives you a lot more operations to work with. Check out this question for more details and alternative ways to preserve the order when removing duplicates.

Finally note that both the set as well as the OrderedDict/dict solutions require your items to be hashable. This usually means that they have to be immutable. If you have to deal with items that are not hashable (e.g. list objects), then you will have to use a slow approach in which you will basically have to compare every item with every other item in a nested loop.
"
What is the use of &quot;assert&quot; in Python?,https://stackoverflow.com/questions/5142418/what-is-the-use-of-assert-in-python,1511,python;exception;assert;assertion,"The assert statement exists in almost every programming language. It has two main uses:

It helps detect problems early in your program, where the cause is clear, rather than later when some other operation fails. A type error in Python, for example, can go through several layers of code before actually raising an Exception if not caught early on.

It works as documentation for other developers reading the code, who see the assert and can confidently say that its condition holds from now on.


When you do...
assert condition

... you're telling the program to test that condition, and immediately trigger an error if the condition is false.
In Python, it's roughly equivalent to this:
if not condition:
    raise AssertionError()

Try it in the Python shell:
>>> assert True # nothing happens
>>> assert False
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
AssertionError

Assertions can include an optional message, and you can disable them when running the interpreter.
To print a message if the assertion fails:
assert False, ""Oh no! This assertion failed!""

Do not use parenthesis to call assert like a function. It is a statement. If you do assert(condition, message) you'll be running the assert with a (condition, message) tuple as first parameter.
As for disabling them, when running python in optimized mode, where __debug__ is False, assert statements will be ignored. Just pass the -O flag:
python -O script.py

See here for the relevant documentation.
"
How do I get the full path of the current file&#39;s directory?,https://stackoverflow.com/questions/3430372/how-do-i-get-the-full-path-of-the-current-files-directory,1510,python;directory,"The special variable __file__ contains the path to the current file. From that we can get the directory using either pathlib or the os.path module.
Python 3
For the directory of the script being run:
import pathlib
pathlib.Path(__file__).parent.resolve()

For the current working directory:
import pathlib
pathlib.Path().resolve()

Python 2 and 3
For the directory of the script being run:
import os
os.path.dirname(os.path.abspath(__file__))

If you mean the current working directory:
import os
os.path.abspath(os.getcwd())

Note that before and after file is two underscores, not just one.
Also note that if you are running interactively or have loaded code from something other than a file (eg: a database or online resource), __file__ may not be set since there is no notion of ""current file"". The above answer assumes the most common scenario of running a python script that is in a file.
References

pathlib in the python documentation.
os.path - Python 2.7, os.path - Python 3
os.getcwd - Python 2.7, os.getcwd - Python 3
what does the __file__ variable mean/do?

"
How do I print an exception in Python?,https://stackoverflow.com/questions/1483429/how-do-i-print-an-exception-in-python,1508,python;exception;error-handling,"For Python 2.6 and later and Python 3.x:
except Exception as e: print(e)

For Python 2.5 and earlier, use:
except Exception,e: print str(e)

"
Null object in Python,https://stackoverflow.com/questions/3289601/null-object-in-python,1508,python;object;null,"In Python, the 'null' object is the singleton None.
To check if something is None, use the is identity operator:
if foo is None:
    ...

"
Why can&#39;t Python parse this JSON data?,https://stackoverflow.com/questions/2835559/why-cant-python-parse-this-json-data,1503,python;json;parsing,"Your data is not valid JSON format. You have [] when you should have {} for the ""masks"" and ""parameters"" elements:

[] are for JSON arrays, which are called list in Python
{} are for JSON objects, which are called dict in Python

Here's how your JSON file should look:
{
    ""maps"": [
        {
            ""id"": ""blabla"",
            ""iscategorical"": ""0""
        },
        {
            ""id"": ""blabla"",
            ""iscategorical"": ""0""
        }
    ],
    ""masks"": {
        ""id"": ""valore""
    },
    ""om_points"": ""value"",
    ""parameters"": {
        ""id"": ""valore""
    }
}

Then you can use your code:
import json
from pprint import pprint

with open('data.json') as f:
    data = json.load(f)

pprint(data)

With data, you can now also find values like so:
data[""maps""][0][""id""]
data[""masks""][""id""]
data[""om_points""]

Try those out and see if it starts to make sense.
"
How do I check which version of Python is running my script?,https://stackoverflow.com/questions/1093322/how-do-i-check-which-version-of-python-is-running-my-script,1499,python;version,"This information is available in the sys.version string in the sys module:
>>> import sys

Human readable:
>>> print(sys.version)  # parentheses necessary in python 3.       
2.5.2 (r252:60911, Jul 31 2008, 17:28:52) 
[GCC 4.2.3 (Ubuntu 4.2.3-2ubuntu7)]

For further processing, use sys.version_info or sys.hexversion:
>>> sys.version_info
(2, 5, 2, 'final', 0)
# or
>>> sys.hexversion
34014192

To ensure a script runs with a minimal version requirement of the Python interpreter add this to your code:
assert sys.version_info >= (2, 5)

This compares major and minor version information. Add micro (=0, 1, etc) and even releaselevel (='alpha','final', etc) to the tuple as you like. Note however, that it is almost always better to ""duck"" check if a certain feature is there, and if not, workaround (or bail out). Sometimes features go away in newer releases, being replaced by others.
"
How to make a class JSON serializable,https://stackoverflow.com/questions/3768895/how-to-make-a-class-json-serializable,1495,python;json;serialization,"Do you have an idea about the expected output? For example, will this do?
>>> f  = FileItem(""/foo/bar"")
>>> magic(f)
'{""fname"": ""/foo/bar""}'

In that case you can merely call json.dumps(f.__dict__).
If you want more customized output then you will have to subclass JSONEncoder and implement your own custom serialization.
For a trivial example, see below.
>>> from json import JSONEncoder
>>> class MyEncoder(JSONEncoder):
        def default(self, o):
            return o.__dict__
    
>>> MyEncoder().encode(f)
'{""fname"": ""/foo/bar""}'

Then you pass this class into the json.dumps() method as cls kwarg:
json.dumps(cls=MyEncoder)

If you also want to decode then you'll have to supply a custom object_hook to the JSONDecoder class. For example:
>>> def from_json(json_object):
        if 'fname' in json_object:
            return FileItem(json_object['fname'])
>>> f = JSONDecoder(object_hook = from_json).decode('{""fname"": ""/foo/bar""}')
>>> f
<__main__.FileItem object at 0x9337fac>
>>> 

"
Automatically create file &#39;requirements.txt&#39;,https://stackoverflow.com/questions/31684375/automatically-create-file-requirements-txt,1489,python;dependencies;python-import;requirements.txt,"Use Pipenv or other tools is recommended for improving your development flow.
pip3 freeze > requirements.txt  # Python3
pip freeze > requirements.txt  # Python2

If you do not use a virtual environment, pigar will be a good choice for you.
"
How to deal with SettingWithCopyWarning in Pandas,https://stackoverflow.com/questions/20625582/how-to-deal-with-settingwithcopywarning-in-pandas,1484,python;pandas;dataframe;chained-assignment;pandas-settingwithcopy-warning,"The SettingWithCopyWarning was created to flag potentially confusing ""chained"" assignments, such as the following, which does not always work as expected, particularly when the first selection returns a copy.  [see GH5390 and GH5597 for background discussion.]
df[df['A'] > 2]['B'] = new_val  # new_val not set in df

The warning offers a suggestion to rewrite as follows:
df.loc[df['A'] > 2, 'B'] = new_val

However, this doesn't fit your usage, which is equivalent to:
df = df[df['A'] > 2]
df['B'] = new_val

While it's clear that you don't care about writes making it back to the original frame (since you are overwriting the reference to it), unfortunately this pattern cannot be differentiated from the first chained assignment example. Hence the (false positive) warning. The potential for false positives is addressed in the docs on indexing, if you'd like to read further.  You can safely disable this new warning with the following assignment.
import pandas as pd
pd.options.mode.chained_assignment = None  # default='warn'


Other Resources

pandas User Guide: Indexing and selecting data
Python Data Science Handbook: Data Indexing and Selection
Real Python: SettingWithCopyWarning in Pandas: Views vs Copies
Dataquest: SettingwithCopyWarning: How to Fix This Warning in Pandas
Towards Data Science: Explaining the SettingWithCopyWarning in pandas

"
Running shell command and capturing the output,https://stackoverflow.com/questions/4760215/running-shell-command-and-capturing-the-output,1479,python;shell;subprocess,"In all officially maintained versions of Python, the simplest approach is to use the subprocess.check_output function:
>>> subprocess.check_output(['ls', '-l'])
b'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'

check_output runs a single program that takes only arguments as input.1 It returns the result exactly as printed to stdout. If you need to write input to stdin, skip ahead to the run or Popen sections. If you want to execute complex shell commands, see the note on shell=True at the end of this answer.
The check_output function works in all officially maintained versions of Python. But for more recent versions, a more flexible approach is available.
Modern versions of Python (3.5 or higher): run
If you're using Python 3.5+, and do not need backwards compatibility, the new run function is recommended by the official documentation for most tasks. It provides a very general, high-level API for the subprocess module. To capture the output of a program, pass the subprocess.PIPE flag to the stdout keyword argument. Then access the stdout attribute of the returned CompletedProcess object:
>>> import subprocess
>>> result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE)
>>> result.stdout
b'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'

The return value is a bytes object, so if you want a proper string, you'll need to decode it. Assuming the called process returns a UTF-8-encoded string:
>>> result.stdout.decode('utf-8')
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'

This can all be compressed to a one-liner if desired:
>>> subprocess.run(['ls', '-l'], stdout=subprocess.PIPE).stdout.decode('utf-8')
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'

If you want to pass input to the process's stdin, you can pass a bytes object to the input keyword argument:
>>> cmd = ['awk', 'length($0) > 5']
>>> ip = 'foo\nfoofoo\n'.encode('utf-8')
>>> result = subprocess.run(cmd, stdout=subprocess.PIPE, input=ip)
>>> result.stdout.decode('utf-8')
'foofoo\n'

You can capture errors by passing stderr=subprocess.PIPE (capture to result.stderr) or stderr=subprocess.STDOUT (capture to result.stdout along with regular output). If you want run to throw an exception when the process returns a nonzero exit code, you can pass check=True. (Or you can check the returncode attribute of result above.) When security is not a concern, you can also run more complex shell commands by passing shell=True as described at the end of this answer.
Later versions of Python streamline the above further. In Python 3.7+, the above one-liner can be spelled like this:
>>> subprocess.run(['ls', '-l'], capture_output=True, text=True).stdout
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'

Using run this way adds just a bit of complexity, compared to the old way of doing things. But now you can do almost anything you need to do with the run function alone.
Older versions of Python (3-3.4): more about check_output
If you are using an older version of Python, or need modest backwards compatibility, you can use the check_output function as briefly described above. It has been available since Python 2.7.
subprocess.check_output(*popenargs, **kwargs)  

It takes takes the same arguments as Popen (see below), and returns a string containing the program's output. The beginning of this answer has a more detailed usage example. In Python 3.5+, check_output is equivalent to executing run with check=True and stdout=PIPE, and returning just the stdout attribute.
You can pass stderr=subprocess.STDOUT to ensure that error messages are included in the returned output. When security is not a concern, you can also run more complex shell commands by passing shell=True as described at the end of this answer.
If you need to pipe from stderr or pass input to the process, check_output won't be up to the task. See the Popen examples below in that case.
Complex applications and legacy versions of Python (2.6 and below): Popen
If you need deep backwards compatibility, or if you need more sophisticated functionality than check_output or run provide, you'll have to work directly with Popen objects, which encapsulate the low-level API for subprocesses.
The Popen constructor accepts either a single command without arguments, or a list containing a command as its first item, followed by any number of arguments, each as a separate item in the list. shlex.split can help parse strings into appropriately formatted lists. Popen objects also accept a host of different arguments for process IO management and low-level configuration.
To send input and capture output, communicate is almost always the preferred method. As in:
output = subprocess.Popen([""mycmd"", ""myarg""], 
                          stdout=subprocess.PIPE).communicate()[0]

Or
>>> import subprocess
>>> p = subprocess.Popen(['ls', '-a'], stdout=subprocess.PIPE, 
...                                    stderr=subprocess.PIPE)
>>> out, err = p.communicate()
>>> print out
.
..
foo

If you set stdin=PIPE, communicate also allows you to pass data to the process via stdin:
>>> cmd = ['awk', 'length($0) > 5']
>>> p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
...                           stderr=subprocess.PIPE,
...                           stdin=subprocess.PIPE)
>>> out, err = p.communicate('foo\nfoofoo\n')
>>> print out
foofoo

Note Aaron Hall's answer, which indicates that on some systems, you may need to set stdout, stderr, and stdin all to PIPE (or DEVNULL) to get communicate to work at all.
In some rare cases, you may need complex, real-time output capturing. Vartec's answer suggests a way forward, but methods other than communicate are prone to deadlocks if not used carefully.
As with all the above functions, when security is not a concern, you can run more complex shell commands by passing shell=True.
Notes
1. Running shell commands: the shell=True argument
Normally, each call to run, check_output, or the Popen constructor executes a single program. That means no fancy bash-style pipes. If you want to run complex shell commands, you can pass shell=True, which all three functions support. For example:
>>> subprocess.check_output('cat books/* | wc', shell=True, text=True)
' 1299377 17005208 101299376\n'

However, doing this raises security concerns. If you're doing anything more than light scripting, you might be better off calling each process separately, and passing the output from each as an input to the next, via
run(cmd, [stdout=etc...], input=other_output)

Or
Popen(cmd, [stdout=etc...]).communicate(other_output)

The temptation to directly connect pipes is strong; resist it. Otherwise, you'll likely see deadlocks or have to do hacky things like this.
"
How can I overcome &quot;datetime.datetime not JSON serializable&quot;?,https://stackoverflow.com/questions/11875770/how-can-i-overcome-datetime-datetime-not-json-serializable,1477,python;json,"Updated for 2018
The original answer accommodated the way MongoDB ""date"" fields were represented as:
{""$date"": 1506816000000}
If you want a generic Python solution for serializing datetime to json, check out @jjmontes' answer for a quick solution which requires no dependencies.

As you are using mongoengine (per comments) and pymongo is a dependency, pymongo has built-in utilities to help with json serialization:
http://api.mongodb.org/python/1.10.1/api/bson/json_util.html
Example usage (serialization):
from bson import json_util
import json

json.dumps(anObject, default=json_util.default)

Example usage (deserialization):
json.loads(aJsonString, object_hook=json_util.object_hook)


Django
Django provides a native DjangoJSONEncoder serializer that deals with this kind of properly.
See https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoder
from django.core.serializers.json import DjangoJSONEncoder

return json.dumps(
  item,
  sort_keys=True,
  indent=1,
  cls=DjangoJSONEncoder
)

One difference I've noticed between DjangoJSONEncoder and using a custom default like this:
import datetime
import json

def default(o):
    if isinstance(o, (datetime.date, datetime.datetime)):
        return o.isoformat()

return json.dumps(
  item,
  sort_keys=True,
  indent=1,
  default=default
)

Is that Django strips a bit of the data:
 ""last_login"": ""2018-08-03T10:51:42.990"", # DjangoJSONEncoder 
 ""last_login"": ""2018-08-03T10:51:42.990239"", # default

So, you may need to be careful about that in some cases.
"
How to drop rows of Pandas DataFrame whose value in a certain column is NaN,https://stackoverflow.com/questions/13413590/how-to-drop-rows-of-pandas-dataframe-whose-value-in-a-certain-column-is-nan,1475,python;pandas;dataframe;indexing;nan,"Don't drop, just take the rows where EPS is not NA:
df = df[df['EPS'].notna()]

"
Display number with leading zeros,https://stackoverflow.com/questions/134934/display-number-with-leading-zeros,1470,python;integer;string-formatting,"In Python 2 (and Python 3) you can do:
number = 1
print(""%02d"" % (number,))

Basically % is like printf or sprintf (see docs).

For Python 3.+, the same behavior can also be achieved with format:
number = 1
print(""{:02d}"".format(number))


For Python 3.6+ the same behavior can be achieved with f-strings:
number = 1
print(f""{number:02d}"")

"
How do I find the location of my Python site-packages directory?,https://stackoverflow.com/questions/122327/how-do-i-find-the-location-of-my-python-site-packages-directory,1468,python,"There are two types of site-packages directories, global and per user.

Global site-packages (""dist-packages"") directories are listed in sys.path when you run:
 python -m site

For a more concise list run getsitepackages from the site module in Python code:
 python -c 'import site; print(site.getsitepackages())'

Caution: In virtual environments getsitepackages is not available with older versions of virtualenv, sys.path from above will list the virtualenv's site-packages directory correctly, though. In Python 3, you may use the sysconfig module instead:
 python3 -c 'import sysconfig; print(sysconfig.get_paths()[""purelib""])'


The per user site-packages directory (PEP 370) is where Python installs your local packages:
 python -m site --user-site

If this points to a non-existing directory check the exit status of Python and see python -m site --help for explanations.
Hint: Running pip list --user or pip freeze --user gives you a list of all installed per user site-packages.



Practical Tips

<package>.__path__ lets you identify the location(s) of a specific package: (details)
  $ python -c ""import setuptools as _; print(_.__path__)""
  ['/usr/lib/python2.7/dist-packages/setuptools']


<module>.__file__ lets you identify the location of a specific module: (difference)
  $ python3 -c ""import os as _; print(_.__file__)""
  /usr/lib/python3.6/os.py


Run pip show <package> to show Debian-style package information:
  $ pip show pytest
  Name: pytest
  Version: 3.8.2
  Summary: pytest: simple powerful testing with Python
  Home-page: https://docs.pytest.org/en/latest/
  Author: Holger Krekel, Bruno Oliveira, Ronny Pfannschmidt, Floris Bruynooghe, Brianna Laugher, Florian Bruhin and others
  Author-email: None
  License: MIT license
  Location: /home/peter/.local/lib/python3.4/site-packages
  Requires: more-itertools, atomicwrites, setuptools, attrs, pathlib2, six, py, pluggy



"
How do I create multiline comments in Python?,https://stackoverflow.com/questions/7696924/how-do-i-create-multiline-comments-in-python,1468,python;comments;documentation,"You can use triple-quoted strings. When they're not a docstring (the first thing in a class/function/module), they are ignored.
'''
This is a multiline
comment.
'''

(Make sure to indent the leading ''' appropriately to avoid an IndentationError.)
Guido van Rossum (creator of Python) tweeted this as a ""pro tip"".
However, Python's style guide, PEP8, favors using consecutive single-line comments, like this:
# This is a multiline
# comment.

...and this is also what you'll find in many projects. Text editors usually have a shortcut to do this easily.
"
String formatting: % vs. .format vs. f-string literal,https://stackoverflow.com/questions/5082452/string-formatting-vs-format-vs-f-string-literal,1468,python;performance;string-formatting;f-string,"To answer your first question... .format just seems more sophisticated in many ways. An annoying thing about % is also how it can either take a variable or a tuple. You'd think the following would always work:
""Hello %s"" % name

yet, if name happens to be (1, 2, 3), it will throw a TypeError. To guarantee that it always prints, you'd need to do
""Hello %s"" % (name,)   # supply the single argument as a single-item tuple

which is just ugly. .format doesn't have those issues. Also in the second example you gave, the .format example is much cleaner looking.
Only use it for backwards compatibility with Python 2.5.

To answer your second question, string formatting happens at the same time as any other operation - when the string formatting expression is evaluated. And Python, not being a lazy language, evaluates expressions before calling functions, so the expression log.debug(""some debug info: %s"" % some_info) will first evaluate the string to, e.g. ""some debug info: roflcopters are active"", then that string will be passed to log.debug().
"
Python: how to determine if an object is iterable?,https://stackoverflow.com/questions/1952464/python-how-to-determine-if-an-object-is-iterable,1462,python;iterable,"
Checking for __iter__ works on sequence types, but it would fail on e.g. strings in Python 2. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):
try:
    some_object_iterator = iter(some_object)
except TypeError as te:
    print(some_object, 'is not iterable')

The iter built-in checks for the __iter__ method or in the case of strings the __getitem__ method.

Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:

Pythonic programming style that determines an object's type by inspection of its method or attribute signature rather than by explicit relationship to some type object (""If it looks like a duck and quacks like a duck, it must be a duck."") By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming.
...
try:
   _ = (e for e in my_object)
except TypeError:
   print(my_object, 'is not iterable')



The collections module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:
from collections.abc import Iterable

if isinstance(e, Iterable):
    # e is iterable

However, this does not check for classes that are iterable through __getitem__.


"
Getting key with maximum value in dictionary?,https://stackoverflow.com/questions/268272/getting-key-with-maximum-value-in-dictionary,1460,python;dictionary;max,"You can use operator.itemgetter for that:
import operator
stats = {'a': 1000, 'b': 3000, 'c': 100}
max(stats.iteritems(), key=operator.itemgetter(1))[0]

And instead of building a new list in memory use stats.iteritems(). The key parameter to the max() function is a function that computes a key that is used to determine how to rank items.
Please note that if you were to have another key-value pair 'd': 3000 that this method will only return one of the two even though they both have the maximum value.
>>> import operator
>>> stats = {'a': 1000, 'b': 3000, 'c': 100, 'd': 3000}
>>> max(stats.iteritems(), key=operator.itemgetter(1))[0]
'b' 

If using Python3:
>>> max(stats.items(), key=operator.itemgetter(1))[0]
'b'

"
What does the &#39;b&#39; character do in front of a string literal?,https://stackoverflow.com/questions/6269765/what-does-the-b-character-do-in-front-of-a-string-literal,1458,python;string;unicode;binary,"To quote the Python 2.x documentation:

A prefix of 'b' or 'B' is ignored in
  Python 2; it indicates that the
  literal should become a bytes literal
  in Python 3 (e.g. when code is
  automatically converted with 2to3). A
  'u' or 'b' prefix may be followed by
  an 'r' prefix.

The Python 3 documentation states:

Bytes literals are always prefixed with 'b' or 'B'; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.

"
How do I create a constant in Python?,https://stackoverflow.com/questions/2682745/how-do-i-create-a-constant-in-python,1443,python;constants,"You cannot declare a variable or value as constant in Python.

To indicate to programmers that a variable is a constant, one usually writes it in upper case:
CONST_NAME = ""Name""


To raise exceptions when constants are changed, see Constants in Python by Alex Martelli. Note that this is not commonly used in practice.

As of Python 3.8, there's a typing.Final variable annotation that will tell static type checkers (like mypy) that your variable shouldn't be reassigned. This is the closest equivalent to Java's final. However, it does not actually prevent reassignment:
from typing import Final

a: Final[int] = 1

# Executes fine, but mypy will report an error if you run mypy on this:
a = 2

"
How do I terminate a script?,https://stackoverflow.com/questions/73663/how-do-i-terminate-a-script,1436,python;termination,"import sys
sys.exit()

details from the sys module documentation:

sys.exit([arg])
Exit from Python. This is implemented by raising the
SystemExit exception, so cleanup actions specified by finally clauses
of try statements are honored, and it is possible to intercept the
exit attempt at an outer level.
The optional argument arg can be an integer giving the exit status
(defaulting to zero), or another type of object. If it is an integer,
zero is considered “successful termination” and any nonzero value is
considered “abnormal termination” by shells and the like. Most systems
require it to be in the range 0-127, and produce undefined results
otherwise. Some systems have a convention for assigning specific
meanings to specific exit codes, but these are generally
underdeveloped; Unix programs generally use 2 for command line syntax
errors and 1 for all other kind of errors. If another type of object
is passed, None is equivalent to passing zero, and any other object is
printed to stderr and results in an exit code of 1. In particular,
sys.exit(""some error message"") is a quick way to exit a program when
an error occurs.
Since exit() ultimately “only” raises an exception, it will only exit
the process when called from the main thread, and the exception is not
intercepted.

Note that this is the 'nice' way to exit.  @glyphtwistedmatrix below points out that if you want a 'hard exit', you can use os._exit(*errorcode*), though it's likely os-specific to some extent (it might not take an errorcode under windows, for example), and it definitely is less friendly since it doesn't let the interpreter do any cleanup before the process dies.  On the other hand, it does kill the entire process, including all running threads, while sys.exit() (as it says in the docs) only exits if called from the main thread, with no other threads running.
"
Create a Pandas Dataframe by appending one row at a time,https://stackoverflow.com/questions/10715965/create-a-pandas-dataframe-by-appending-one-row-at-a-time,1424,python;pandas;dataframe;append,"You can use df.loc[i], where the row with index i will be what you specify it to be in the dataframe.
>>> import pandas as pd
>>> from numpy.random import randint

>>> df = pd.DataFrame(columns=['lib', 'qty1', 'qty2'])
>>> for i in range(5):
>>>     df.loc[i] = ['name' + str(i)] + list(randint(10, size=2))

>>> df
     lib qty1 qty2
0  name0    3    3
1  name1    2    4
2  name2    2    8
3  name3    2    1
4  name4    9    6

"
What is the difference between null=True and blank=True in Django?,https://stackoverflow.com/questions/8609192/what-is-the-difference-between-null-true-and-blank-true-in-django,1423,python;django;django-models;django-admin,"null=True sets NULL (versus NOT NULL) on the column in your DB. Blank values for Django field types such as DateTimeField or ForeignKey will be stored as NULL in the DB.
blank determines whether the field will be required in forms. This includes the admin and your custom forms. If blank=True then the field will not be required, whereas if it's False the field cannot be blank.
The combo of the two is so frequent because typically if you're going to allow a field to be blank in your form, you're going to also need your database to allow NULL values for that field. The exception is CharFields and TextFields, which in Django are never saved as NULL. Blank values are stored in the DB as an empty string ('').
A few examples:
models.DateTimeField(blank=True) # raises IntegrityError if blank

models.DateTimeField(null=True) # NULL allowed, but must be filled out in a form

Obviously, Those two options don't make logical sense to use (though there might be a use case for null=True, blank=False if you want a field to always be required in forms, optional when dealing with an object through something like the shell.)
models.CharField(blank=True) # No problem, blank is stored as ''

models.CharField(null=True) # NULL allowed, but will never be set as NULL

CHAR and TEXT types are never saved as NULL by Django, so null=True is unnecessary. However, you can manually set one of these fields to None to force set it as NULL. If you have a scenario where that might be necessary, you should still include null=True.
"
How does the @property decorator work in Python?,https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work-in-python,1420,python;properties;decorator;python-decorators;python-internals,"The property() function returns a special descriptor object:
>>> property()
<property object at 0x10ff07940>

It is this object that has extra methods:
>>> property().getter
<built-in method getter of property object at 0x10ff07998>
>>> property().setter
<built-in method setter of property object at 0x10ff07940>
>>> property().deleter
<built-in method deleter of property object at 0x10ff07998>

These act as decorators too. They return a new property object:
>>> property().getter(None)
<property object at 0x10ff079f0>

that is a copy of the old object, but with one of the functions replaced.
Remember, that the @decorator syntax is just syntactic sugar; the syntax:
@property
def foo(self): return self._foo

really means the same thing as
def foo(self): return self._foo
foo = property(foo)

so foo the function is replaced by property(foo), which we saw above is a special object. Then when you use @foo.setter(), what you are doing is call that property().setter method I showed you above, which returns a new copy of the property, but this time with the setter function replaced with the decorated method.
The following sequence also creates a full-on property, by using those decorator methods.
First we create some functions:
>>> def getter(self): print('Get!')
... 
>>> def setter(self, value): print('Set to {!r}!'.format(value))
... 
>>> def deleter(self): print('Delete!')
... 

Then, we create a property object with only a getter:
>>> prop = property(getter)
>>> prop.fget is getter
True
>>> prop.fset is None
True
>>> prop.fdel is None
True

Next we use the .setter() method to add a setter:
>>> prop = prop.setter(setter)
>>> prop.fget is getter
True
>>> prop.fset is setter
True
>>> prop.fdel is None
True

Last we add a deleter with the .deleter() method:
>>> prop = prop.deleter(deleter)
>>> prop.fget is getter
True
>>> prop.fset is setter
True
>>> prop.fdel is deleter
True

Last but not least, the property object acts as a descriptor object, so it has .__get__(), .__set__() and .__delete__() methods to hook into instance attribute getting, setting and deleting:
>>> class Foo: pass
... 
>>> prop.__get__(Foo(), Foo)
Get!
>>> prop.__set__(Foo(), 'bar')
Set to 'bar'!
>>> prop.__delete__(Foo())
Delete!

The Descriptor Howto includes a pure Python sample implementation of the property() type:

class Property:
    ""Emulate PyProperty_Type() in Objects/descrobject.c""

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError(""unreadable attribute"")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError(""can't set attribute"")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError(""can't delete attribute"")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)


"
How do I check if a variable exists?,https://stackoverflow.com/questions/843277/how-do-i-check-if-a-variable-exists,1417,python;exception;variables,"To check the existence of a local variable:
if 'myVar' in locals():
  # myVar exists.

To check the existence of a global variable:
if 'myVar' in globals():
  # myVar exists.

To check if an object has an attribute:
if hasattr(obj, 'attr_name'):
  # obj.attr_name exists.

"
How can I do a line break (line continuation) in Python (split up a long line of source code)?,https://stackoverflow.com/questions/53162/how-can-i-do-a-line-break-line-continuation-in-python-split-up-a-long-line-of,1412,python;syntax;line-breaks;long-lines,"What is the line?  You can just have arguments on the next line without any problems:
a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, 
            blahblah6, blahblah7)

Otherwise you can do something like this:
if (a == True and
    b == False):

or with explicit line break:
if a == True and \
   b == False:

Check the style guide for more information.
Using parentheses, your example can be written over multiple lines:
a = ('1' + '2' + '3' +
    '4' + '5')

The same effect can be obtained using explicit line break:
a = '1' + '2' + '3' + \
    '4' + '5'

Note that the style guide says that using the implicit continuation with parentheses is preferred, but in this particular case just adding parentheses around your expression is probably the wrong way to go.
"
How do I reverse a list or loop over it backwards?,https://stackoverflow.com/questions/3940128/how-do-i-reverse-a-list-or-loop-over-it-backwards,1404,python;list;reverse,"To get a new reversed list, apply the reversed function and collect the items into a list:
>>> xs = [0, 10, 20, 40]
>>> list(reversed(xs))
[40, 20, 10, 0]

To iterate backwards through a list:
>>> xs = [0, 10, 20, 40]
>>> for x in reversed(xs):
...     print(x)
40
20
10
0

"
How can I read a text file into a string variable and strip newlines?,https://stackoverflow.com/questions/8369219/how-can-i-read-a-text-file-into-a-string-variable-and-strip-newlines,1404,python;string,"You could use:
with open('data.txt', 'r') as file:
    data = file.read().replace('\n', '')

Or if the file content is guaranteed to be one line:
with open('data.txt', 'r') as file:
    data = file.read().rstrip()

"
What is a mixin and why is it useful?,https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-is-it-useful,1402,python;oop;multiple-inheritance;mixins;python-class,"A mixin is a special kind of multiple inheritance.  There are two main situations where mixins are used:

You want to provide a lot of optional features for a class.
You want to use one particular feature in a lot of different classes.

For an example of number one, consider werkzeug's request and response system.  I can make a plain old request object by saying:
from werkzeug import BaseRequest

class Request(BaseRequest):
    pass

If I want to add accept header support, I would make that
from werkzeug import BaseRequest, AcceptMixin

class Request(AcceptMixin, BaseRequest):
    pass

If I wanted to make a request object that supports accept headers, etags, authentication, and user agent support, I could do this:
from werkzeug import BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthenticationMixin

class Request(AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthenticationMixin, BaseRequest):
    pass

The difference is subtle, but in the above examples, the mixin classes weren't made to stand on their own.  In more traditional multiple inheritance, the AuthenticationMixin (for example) would probably be something more like Authenticator.  That is, the class would probably be designed to stand on its own.
"
Putting a simple if-then-else statement on one line,https://stackoverflow.com/questions/2802726/putting-a-simple-if-then-else-statement-on-one-line,1394,python;if-statement;syntax;conditional-operator,"That's more specifically a ternary operator expression than an if-then, here's the python syntax
value_when_true if condition else value_when_false

Better Example: (thanks Mr. Burns)
'Yes' if fruit == 'Apple' else 'No'

Now with assignment and contrast with if syntax
fruit = 'Apple'
isApple = True if fruit == 'Apple' else False

vs
fruit = 'Apple'
isApple = False
if fruit == 'Apple' : isApple = True

"
Get a list from Pandas DataFrame column headers,https://stackoverflow.com/questions/19482970/get-a-list-from-pandas-dataframe-column-headers,1388,python;pandas;dataframe;list;header,"You can get the values as a list by doing:
list(my_dataframe.columns.values)

Also you can simply use (as shown in Ed Chum's answer):
list(my_dataframe)

"
Use a list of values to select rows from a Pandas dataframe,https://stackoverflow.com/questions/12096252/use-a-list-of-values-to-select-rows-from-a-pandas-dataframe,1388,python;pandas;dataframe;indexing;filter,"You can use the isin method:
In [1]: df = pd.DataFrame({'A': [5,6,3,4], 'B': [1,2,3,5]})

In [2]: df
Out[2]:
   A  B
0  5  1
1  6  2
2  3  3
3  4  5

In [3]: df[df['A'].isin([3, 6])]
Out[3]:
   A  B
1  6  2
2  3  3

And to get the opposite use ~:
In [4]: df[~df['A'].isin([3, 6])]
Out[4]:
   A  B
0  5  1
3  4  5

"
Correct way to write line to file?,https://stackoverflow.com/questions/6159900/correct-way-to-write-line-to-file,1387,python;file-io,"This should be as simple as:
with open('somefile.txt', 'a') as the_file:
    the_file.write('Hello\n')

From The Documentation:

Do not use os.linesep as a line terminator when writing files opened in text mode (the default); use a single '\n' instead, on all platforms.

Some useful reading:

The with statement
open()

'a' is for append, or use
'w' to write with truncation


os (particularly os.linesep)

"
How do I remove all packages installed by pip?,https://stackoverflow.com/questions/11248073/how-do-i-remove-all-packages-installed-by-pip,1386,python;pip;virtualenv;python-packaging,"I've found this snippet as an alternative solution. It's a more graceful removal of libraries than remaking the virtualenv:
pip freeze | xargs pip uninstall -y


In case you have packages installed via VCS, you need to exclude those lines and remove the packages manually (elevated from the comments below):
pip freeze --exclude-editable | xargs pip uninstall -y


If you have packages installed directly from github/gitlab, those will have @.
Like:
django @ git+https://github.com/django.git@<sha>
You can add cut -d ""@"" -f1 to get just the package name that is required to uninstall it.
pip freeze | cut -d ""@"" -f1 | xargs pip uninstall -y

"
"Extract file name from path, no matter what the os/path format",https://stackoverflow.com/questions/8384737/extract-file-name-from-path-no-matter-what-the-os-path-format,1384,python;path,"Using os.path.split or os.path.basename as others suggest won't work in all cases: if you're running the script on Linux and attempt to process a classic windows-style path, it will fail.
Windows paths can use either backslash or forward slash as path separator. Therefore, the ntpath module (which is equivalent to os.path when running on windows) will work for all(1) paths on all platforms.
import ntpath
ntpath.basename(""a/b/c"")

Of course, if the file ends with a slash, the basename will be empty, so make your own function to deal with it:
def path_leaf(path):
    head, tail = ntpath.split(path)
    return tail or ntpath.basename(head)

Verification:
>>> paths = ['a/b/c/', 'a/b/c', '\\a\\b\\c', '\\a\\b\\c\\', 'a\\b\\c', 
...     'a/b/../../a/b/c/', 'a/b/../../a/b/c']
>>> [path_leaf(path) for path in paths]
['c', 'c', 'c', 'c', 'c', 'c', 'c']


(1) There's one caveat: Linux filenames may contain backslashes. So on linux, r'a/b\c' always refers to the file b\c in the a folder, while on Windows, it always refers to the c file in the b subfolder of the a folder. So when both forward and backward slashes are used in a path, you need to know the associated platform to be able to interpret it correctly. In practice it's usually safe to assume it's a windows path since backslashes are seldom used in Linux filenames, but keep this in mind when you code so you don't create accidental security holes.
"
How does Python&#39;s super() work with multiple inheritance?,https://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance,1380,python;multiple-inheritance,"This is detailed with a reasonable amount of detail by Guido himself in his blog post Method Resolution Order (including two earlier attempts).
In your example, Third() will call First.__init__. Python looks for each attribute in the class's parents as they are listed left to right. In this case, we are looking for __init__. So, if you define
class Third(First, Second):
    ...

Python will start by looking at First, and, if First doesn't have the attribute, then it will look at Second.
This situation becomes more complex when inheritance starts crossing paths (for example if First inherited from Second). Read the link above for more details, but, in a nutshell, Python will try to maintain the order in which each class appears on the inheritance list, starting with the child class itself.
So, for instance, if you had:
class First(object):
    def __init__(self):
        print ""first""

class Second(First):
    def __init__(self):
        print ""second""

class Third(First):
    def __init__(self):
        print ""third""

class Fourth(Second, Third):
    def __init__(self):
        super(Fourth, self).__init__()
        print ""that's it""

the MRO would be [Fourth, Second, Third, First].
By the way: if Python cannot find a coherent method resolution order, it'll raise an exception, instead of falling back to behavior which might surprise the user.
Example of an ambiguous MRO:
class First(object):
    def __init__(self):
        print ""first""
        
class Second(First):
    def __init__(self):
        print ""second""

class Third(First, Second):
    def __init__(self):
        print ""third""

Should Third's MRO be [First, Second] or [Second, First]? There's no obvious expectation, and Python will raise an error:
TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution order (MRO) for bases Second, First

Why do the examples above lack super() calls? The point of the examples is to show how the MRO is constructed. They are not intended to print ""first\nsecond\third"" or whatever. You can – and should, of course, play around with the example, add super() calls, see what happens, and gain a deeper understanding of Python's inheritance model. But my goal here is to keep it simple and show how the MRO is built. And it is built as I explained:
>>> Fourth.__mro__
(<class '__main__.Fourth'>,
 <class '__main__.Second'>, <class '__main__.Third'>,
 <class '__main__.First'>,
 <type 'object'>)

"
How do I trim whitespace from a string?,https://stackoverflow.com/questions/761804/how-do-i-trim-whitespace-from-a-string,1379,python;string;trim,"To remove all whitespace surrounding a string, use .strip(). Examples:
>>> ' Hello '.strip()
'Hello'
>>> ' Hello'.strip()
'Hello'
>>> 'Bob has a cat'.strip()
'Bob has a cat'
>>> '   Hello   '.strip()  # ALL consecutive spaces at both ends removed
'Hello'

Note that str.strip() removes all whitespace characters, including tabs and newlines. To remove only spaces, specify the specific character to remove as an argument to strip:
>>> ""  Hello\n  "".strip("" "")
'Hello\n'


To remove only one space at most:
def strip_one_space(s):
    if s.endswith("" ""): s = s[:-1]
    if s.startswith("" ""): s = s[1:]
    return s

>>> strip_one_space(""   Hello "")
'  Hello'

"
How do I return dictionary keys as a list in Python?,https://stackoverflow.com/questions/16819222/how-do-i-return-dictionary-keys-as-a-list-in-python,1370,python;python-3.x;list;dictionary,"This will convert the dict_keys object to a list:
list(newdict.keys())


On the other hand, you should ask yourself whether or not it matters. It is Pythonic to assume duck typing -- if it looks like a duck and it quacks like a duck, it is a duck. The dict_keys object can be iterated over just like a list. For instance:
for key in newdict.keys():
    print(key)

Note that dict_keys doesn't support insertion newdict[k] = v, though you may not need it.
"
How do I type hint a method with the type of the enclosing class?,https://stackoverflow.com/questions/33533148/how-do-i-type-hint-a-method-with-the-type-of-the-enclosing-class,1364,python;pycharm;python-typing,"I guess you got this exception:
NameError: name 'Position' is not defined

This is because in the original implementation of annotations, Position must be defined before you can use it in an annotation.
Python 3.14+: It'll just work
Python 3.14 has a new, lazily evaluated annotation implementation specified by PEP 749 and 649. Annotations will be compiled to special __annotate__ functions, executed when an object's __annotations__ dict is first accessed instead of at the point where the annotation itself occurs.
Thus, annotating your function as def __add__(self, other: Position) -> Position: no longer requires Position to already exist:
class Position:
    def __add__(self, other: Position) -> Position:
        ...

Python 3.7+, deprecated: from __future__ import annotations
from __future__ import annotations turns on an older solution to this problem, PEP 563, where all annotations are saved as strings instead of as __annotate__ functions or evaluated values. This was originally planned to become the default behavior, and almost became the default in 3.10 before being reverted.
With the acceptance of PEP 749, this will be deprecated in Python 3.14, and it will be removed in a future Python version. Still, it works for now:
from __future__ import annotations

class Position:
    def __add__(self, other: Position) -> Position:
        ...

Python 3+: Use a string
This is the original workaround, specified in PEP 484. Write your annotations as string literals containing the text of whatever expression you originally wanted to use as an annotation:
class Position:
    def __add__(self, other: 'Position') -> 'Position':
        ...

from __future__ import annotations effectively automates doing this for all annotations in a file.
typing.Self might sometimes be appropriate
Introduced in Python 3.11, typing.Self refers to the type of the current instance, even if that type is a subclass of the class the annotation appears in. So if you have the following code:
from typing import Self

class Parent:
    def me(self) -> Self:
        return self

class Child(Parent): pass

x: Child = Child().me()

then Child().me() is treated as returning Child, instead of Parent.
This isn't always what you want. But when it is, it's pretty convenient.
For Python versions < 3.11, if you have typing_extensions installed, you can use:
from typing_extensions import Self

Sources
The relevant parts of PEP 484, PEP 563, and PEP 649, to spare you the trip:

Forward references
When a type hint contains names that have not been defined yet, that definition may be expressed as a string literal, to be resolved later.
A situation where this occurs commonly is the definition of a container class, where the class being defined occurs in the signature of some of the methods. For example, the following code (the start of a simple binary tree implementation) does not work:
class Tree:
    def __init__(self, left: Tree, right: Tree):
        self.left = left
        self.right = right

To address this, we write:
class Tree:
    def __init__(self, left: 'Tree', right: 'Tree'):
        self.left = left
        self.right = right

The string literal should contain a valid Python expression (i.e., compile(lit, '', 'eval') should be a valid code object) and it should evaluate without errors once the module has been fully loaded. The local and global namespace in which it is evaluated should be the same namespaces in which default arguments to the same function would be evaluated.

and PEP 563, deprecated:

Implementation
In Python 3.10, function and variable annotations will no longer be evaluated at definition time. Instead, a string form will be preserved in the respective __annotations__ dictionary. Static type checkers will see no difference in behavior, whereas tools using annotations at runtime will have to perform postponed evaluation.
...
Enabling the future behavior in Python 3.7
The functionality described above can be enabled starting from Python 3.7 using the following special import:
from __future__ import annotations


and PEP 649:

Overview
This PEP adds a new dunder attribute to the objects that support annotations–functions, classes, and modules. The new attribute is called __annotate__, and is a reference to a function which computes and returns that object’s annotations dict.
At compile time, if the definition of an object includes annotations, the Python compiler will write the expressions computing the annotations into its own function. When run, the function will return the annotations dict. The Python compiler then stores a reference to this function in __annotate__ on the object.
Furthermore, __annotations__ is redefined to be a “data descriptor” which calls this annotation function once and caches the result.

Things that you may be tempted to do instead
A. Define a dummy Position
Before the class definition, place a dummy definition:
class Position(object):
    pass

class Position:

    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y

    def __add__(self, other: Position) -> Position:
        return Position(self.x + other.x, self.y + other.y)

This will get rid of the NameError and may even look OK:
>>> Position.__add__.__annotations__
{'other': __main__.Position, 'return': __main__.Position}

But is it?
>>> for k, v in Position.__add__.__annotations__.items():
...     print(k, 'is Position:', v is Position)                                                                                                                                                                                                                  
return is Position: False
other is Position: False

And mypy will report a pile of errors:
main.py:4: error: Name ""Position"" already defined on line 1  [no-redef]
main.py:11: error: Too many arguments for ""Position""  [call-arg]
main.py:11: error: ""Position"" has no attribute ""x""  [attr-defined]
main.py:11: error: ""Position"" has no attribute ""y""  [attr-defined]
Found 4 errors in 1 file (checked 1 source file)

B. Monkey-patch in order to add the annotations:
You may want to try some Python metaprogramming magic and write a decorator
to monkey-patch the class definition in order to add annotations:
class Position:
    ...
    def __add__(self, other):
        return self.__class__(self.x + other.x, self.y + other.y)

The decorator should be responsible for the equivalent of this:
Position.__add__.__annotations__['return'] = Position
Position.__add__.__annotations__['other'] = Position

It'll work right at runtime:
>>> for k, v in Position.__add__.__annotations__.items():
...     print(k, 'is Position:', v is Position)                                                                                                                                                                                                                  
return is Position: True
other is Position: True

But static analyzers like mypy won't understand it, and static analysis is the biggest use case of type annotations.
"
How do I get file creation and modification date/times?,https://stackoverflow.com/questions/237079/how-do-i-get-file-creation-and-modification-date-times,1363,python;file,"In Python 3.4 and above, you can use the object oriented pathlib module interface which includes wrappers for much of the os module.  Here is an example of getting the file stats.
>>> import pathlib
>>> fname = pathlib.Path('test.py')
>>> assert fname.exists(), f'No such file: {fname}'  # check that the file exists
>>> print(fname.stat())
os.stat_result(st_mode=33206, st_ino=5066549581564298, st_dev=573948050, st_nlink=1, st_uid=0, st_gid=0, st_size=413, st_atime=1523480272, st_mtime=1539787740, st_ctime=1523480272)

For more information about what os.stat_result contains, refer to the documentation. For the modification time you want fname.stat().st_mtime:
>>> import datetime
>>> mtime = datetime.datetime.fromtimestamp(fname.stat().st_mtime, tz=datetime.timezone.utc)
>>> print(mtime)
datetime.datetime(2018, 10, 17, 10, 49, 0, 249980)

If you want the creation time on Windows, or the most recent metadata change on Unix, you would use fname.stat().st_ctime:
>>> ctime = datetime.datetime.fromtimestamp(fname.stat().st_ctime, tz=datetime.timezone.utc)
>>> print(ctime)
datetime.datetime(2018, 4, 11, 16, 57, 52, 151953)

This article has more helpful info and examples for the pathlib module.
"
How to get the ASCII value of a character,https://stackoverflow.com/questions/227459/how-to-get-the-ascii-value-of-a-character,1359,python;ascii,"From here:

The function ord() gets the int value
of the char. And in case you want to
convert back after playing with the
number, function chr() does the trick.

>>> ord('a')
97
>>> chr(97)
'a'
>>> chr(ord('a') + 3)
'd'
>>>

In Python 2, there was also the unichr function, returning the Unicode character whose ordinal is the unichr argument:
>>> unichr(97)
u'a'
>>> unichr(1234)
u'\u04d2'

In Python 3 you can use chr instead of unichr.

ord() - Python 3.6.5rc1 documentation
ord() - Python 2.7.14 documentation
"
What is the purpose of the `self` parameter? Why is it needed?,https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-the-self-parameter-why-is-it-needed,1358,python;class;oop;self,"The reason you need to use self. is because Python does not use special syntax to refer to instance attributes. Python decided to do methods in a way that makes the instance to which the method belongs be passed automatically, but not received automatically: the first parameter of methods is the instance the method is called on. That makes methods entirely the same as functions, and leaves the actual name to use up to you (although self is the convention, and people will generally frown at you when you use something else.) self is not special to the code, it's just another object.
Python could have done something else to distinguish normal names from attributes -- special syntax like Ruby has, or requiring declarations like C++ and Java do, or perhaps something  yet more different -- but it didn't. Python's all for making things explicit, making it obvious what's what, and although it doesn't do it entirely everywhere, it does do it for instance attributes. That's why assigning to an instance attribute needs to know what instance to assign to, and that's why it needs self..
"
Count the number of occurrences of a character in a string,https://stackoverflow.com/questions/1155617/count-the-number-of-occurrences-of-a-character-in-a-string,1355,python;string;count,"
str.count(sub[, start[, end]])
Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.

>>> sentence = 'Mary had a little lamb'
>>> sentence.count('a')
4

"
"If Python is interpreted, what are .pyc files?",https://stackoverflow.com/questions/2998215/if-python-is-interpreted-what-are-pyc-files,1352,python;compiled;interpreted-language;pyc,"They contain byte code, which is what the Python interpreter compiles the source to. This code is then executed by Python's virtual machine.
Python's documentation explains the definition like this:

Python is an interpreted language, as
opposed to a compiled one, though the
distinction can be blurry because of
the presence of the bytecode compiler.
This means that source files can be
run directly without explicitly
creating an executable which is then
run.

"
Converting from a string to boolean in Python,https://stackoverflow.com/questions/715417/converting-from-a-string-to-boolean-in-python,1349,python;string;boolean,"Really, you just compare the string to whatever you expect to accept as representing true, so you can do this:
s == 'True'

Or to checks against a whole bunch of values:
s.lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']

Be cautious when using the following:
>>> bool(""foo"")
True
>>> bool(""False"") # beware!
True
>>> bool("""")
False

Empty strings evaluate to False, but everything else evaluates to True. So this should not be used for any kind of parsing purposes.
"
How to add a new column to an existing DataFrame,https://stackoverflow.com/questions/12555323/how-to-add-a-new-column-to-an-existing-dataframe,1341,python;pandas;dataframe;chained-assignment,"Edit 2017
As indicated in the comments and by @Alexander, currently the best method to add the values of a Series as a new column of a DataFrame could be using assign:
df1 = df1.assign(e=pd.Series(np.random.randn(sLength)).values)


Edit 2015
Some reported getting the SettingWithCopyWarning with this code.
However, the code still runs perfectly with the current pandas version 0.16.1.
>>> sLength = len(df1['a'])
>>> df1
          a         b         c         d
6 -0.269221 -0.026476  0.997517  1.294385
8  0.917438  0.847941  0.034235 -0.448948

>>> df1['e'] = pd.Series(np.random.randn(sLength), index=df1.index)
>>> df1
          a         b         c         d         e
6 -0.269221 -0.026476  0.997517  1.294385  1.757167
8  0.917438  0.847941  0.034235 -0.448948  2.228131

>>> pd.version.short_version
'0.16.1'

The SettingWithCopyWarning aims to inform of a possibly invalid assignment on a copy of the Dataframe. It doesn't necessarily say you did it wrong (it can trigger false positives) but from 0.13.0 it let you know there are more adequate methods for the same purpose. Then, if you get the warning, just follow its advise: Try using .loc[row_index,col_indexer] = value instead
>>> df1.loc[:,'f'] = pd.Series(np.random.randn(sLength), index=df1.index)
>>> df1
          a         b         c         d         e         f
6 -0.269221 -0.026476  0.997517  1.294385  1.757167 -0.050927
8  0.917438  0.847941  0.034235 -0.448948  2.228131  0.006109
>>> 

In fact, this is currently the more efficient method as described in pandas docs

Original answer:
Use the original df1 indexes to create the series:
df1['e'] = pd.Series(np.random.randn(sLength), index=df1.index)

"
How to create a GUID/UUID in Python,https://stackoverflow.com/questions/534839/how-to-create-a-guid-uuid-in-python,1334,python;uuid;guid;uniqueidentifier,"
The uuid module provides immutable UUID objects (the UUID class) and the functions uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5 UUIDs as specified in RFC 4122.


If all you want is a unique ID, you should probably call uuid1() or uuid4().
Note that uuid1() may compromise privacy since it creates a UUID containing the computer’s network address.
uuid4() creates a random UUID.

UUID versions 6, 7 and 8 - new Universally Unique Identifier (UUID) formats for use in modern applications and as database keys -  (draft) rfc - are available from https://pypi.org/project/uuid6/
Docs:

Python 2
Python 3

Examples (for both Python 2 and 3):
>>> import uuid

>>> # make a random UUID
>>> uuid.uuid4()
UUID('bd65600d-8669-4903-8a14-af88203add38')

>>> # Convert a UUID to a string of hex digits in standard form
>>> str(uuid.uuid4())
'f50ec0b7-f960-400d-91f0-c42a6d44e3d0'

>>> # Convert a UUID to a 32-character hexadecimal string
>>> uuid.uuid4().hex
'9fe2c4e93f654fdbb24c02b15259716c'

"
Why does comparing strings using either &#39;==&#39; or &#39;is&#39; sometimes produce a different result?,https://stackoverflow.com/questions/1504717/why-does-comparing-strings-using-either-or-is-sometimes-produce-a-differe,1331,python;string;comparison;identity;equality,"is is identity testing, and == is equality testing. What happens in your code would be emulated in the interpreter like this:
>>> a = 'pub'
>>> b = ''.join(['p', 'u', 'b'])
>>> a == b
True
>>> a is b
False

So, no wonder they're not the same, right?
In other words: a is b is the equivalent of id(a) == id(b)
"
How to get the line count of a large file cheaply in Python,https://stackoverflow.com/questions/845058/how-to-get-the-line-count-of-a-large-file-cheaply-in-python,1318,python;text-files;line-count,"You can't get any better than that.
After all, any solution will have to read the entire file, figure out how many \n you have, and return that result.
Do you have a better way of doing that without reading the entire file? Not sure... The best solution will always be I/O-bound, best you can do is make sure you don't use unnecessary memory, but it looks like you have that covered.
[Edit May 2023]
As commented in many other answers, in Python 3 there are better alternatives. The for loop is not the most efficient. For example, using mmap or buffers is more efficient.
"
How do I import other Python files?,https://stackoverflow.com/questions/2349991/how-do-i-import-other-python-files,1308,python;import;python-import;python-module;python-packaging,"importlib was added to Python 3 to programmatically import a module.
import importlib

moduleName = input('Enter module name:')
importlib.import_module(moduleName)

The .py extension should be removed from moduleName. The function also defines a package argument for relative imports.
In python 2.x:

Just import file without the .py extension
A folder can be marked as a package, by adding an empty __init__.py file
You can use the __import__ function, which takes the module name (without extension) as a string extension

pmName = input('Enter module name:')
pm = __import__(pmName)
print(dir(pm))

Type help(__import__) for more details.
"
How do I get a list of locally installed Python modules?,https://stackoverflow.com/questions/739993/how-do-i-get-a-list-of-locally-installed-python-modules,1306,python;module;pip,"Solution
Do not use with pip > 10.0!
My 50 cents for getting a pip freeze-like list from a Python script:
import pip
installed_packages = pip.get_installed_distributions()
installed_packages_list = sorted([""%s==%s"" % (i.key, i.version)
     for i in installed_packages])
print(installed_packages_list)

As a (too long) one liner:
sorted([""%s==%s"" % (i.key, i.version) for i in pip.get_installed_distributions()])

Giving:
['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24',
 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3',
 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0',
 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1',
 'werkzeug==0.9.4']

Scope
This solution applies to the system scope or to a virtual environment scope, and covers packages installed by setuptools, pip and (god forbid) easy_install.
My use case
I added the result of this call to my Flask server, so when I call it with http://example.com/exampleServer/environment I get the list of packages installed on the server's virtualenv. It makes debugging a whole lot easier.
Caveats
I have noticed a strange behaviour of this technique - when the Python interpreter is invoked in the same directory as a setup.py file, it does not list the package installed by setup.py.
Steps to reproduce:
Create a virtual environment
$ cd /tmp
$ virtualenv test_env
New python executable in test_env/bin/python
Installing setuptools, pip...done.
$ source test_env/bin/activate
(test_env) $

Clone a Git repository with setup.py
(test_env) $ git clone https://github.com/behave/behave.git
Cloning into 'behave'...
remote: Reusing existing pack: 4350, done.
remote: Total 4350 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (4350/4350), 1.85 MiB | 418.00 KiB/s, done.
Resolving deltas: 100% (2388/2388), done.
Checking connectivity... done.

We have behave's setup.py in /tmp/behave:
(test_env) $ ls /tmp/behave/setup.py
    /tmp/behave/setup.py

Install the Python package from the Git repository
(test_env) $ cd /tmp/behave && pip install .
running install
...
Installed /private/tmp/test_env/lib/python2.7/site-packages/enum34-1.0-py2.7.egg
Finished processing dependencies for behave==1.2.5a1

If we run the aforementioned solution from /tmp
>>> import pip
>>> sorted([""%s==%s"" % (i.key, i.version) for i in pip.get_installed_distributions()])
['behave==1.2.5a1', 'enum34==1.0', 'parse-type==0.3.4', 'parse==1.6.4', 'six==1.6.1']
>>> import os
>>> os.getcwd()
'/private/tmp'

If we run the aforementioned solution from /tmp/behave
>>> import pip
>>> sorted([""%s==%s"" % (i.key, i.version) for i in pip.get_installed_distributions()])
['enum34==1.0', 'parse-type==0.3.4', 'parse==1.6.4', 'six==1.6.1']
>>> import os
>>> os.getcwd()
'/private/tmp/behave'

behave==1.2.5a1 is missing from the second example, because the working directory contains behave's setup.py file.
I could not find any reference to this issue in the documentation. Perhaps I shall open a bug for it.
"
Get the data received in a Flask request,https://stackoverflow.com/questions/10434599/get-the-data-received-in-a-flask-request,1300,python;flask;werkzeug,"The docs describe the attributes available on the request object (from flask import request) during a request. In most common cases request.data will be empty because it's used as a fallback:

request.data Contains the incoming request data as string in case it came with a mimetype Flask does not handle.


request.args: the key/value pairs in the URL query string
request.form: the key/value pairs in the body, from a HTML post form, or JavaScript request that isn't JSON encoded
request.files: the files in the body, which Flask keeps separate from form. HTML forms must use enctype=multipart/form-data or files will not be uploaded.
request.values: combined args and form, preferring args if keys overlap
request.json: parsed JSON data. The request must have the application/json content type, or use request.get_json(force=True) to ignore the content type.

All of these are MultiDict instances (except for json). You can access values using:

request.form['name']: use indexing if you know the key exists
request.form.get('name'): use get if the key might not exist
request.form.getlist('name'): use getlist if the key is sent multiple times and you want a list of values. get only returns the first value.

"
Maximum and Minimum values for ints,https://stackoverflow.com/questions/7604966/maximum-and-minimum-values-for-ints,1300,python;integer,"Python 3
In Python 3, this question doesn't apply. The plain int type is unbounded.
However, you might actually be looking for information about the current interpreter's word size, which will be the same as the machine's word size in most cases. That information is still available in Python 3 as sys.maxsize, which is the maximum value representable by a signed word. Equivalently, it's the size of the largest possible list or in-memory sequence.
Generally, the maximum value representable by an unsigned word will be sys.maxsize * 2 + 1, and the number of bits in a word will be math.log2(sys.maxsize * 2 + 2). See this answer for more information.
Python 2
In Python 2, the maximum value for plain int values is available as sys.maxint:
>>> sys.maxint  # on my system, 2**63-1
9223372036854775807

You can calculate the minimum value with -sys.maxint - 1 as shown in the docs.
Python seamlessly switches from plain to long integers once you exceed this value. So most of the time, you won't need to know it.
"
How do I iterate through two lists in parallel?,https://stackoverflow.com/questions/1663807/how-do-i-iterate-through-two-lists-in-parallel,1298,python;list;for-loop;iterator,"Python 3
for f, b in zip(foo, bar):
    print(f, b)

zip stops when the shorter of foo or bar stops.
In Python 3, zip
returns an iterator of tuples, like itertools.izip in Python2.  To get a list
of tuples, use list(zip(foo, bar)). And to zip until both iterators are
exhausted, you would use
itertools.zip_longest.
Python 2
In Python 2, zip
returns a list of tuples. This is fine when foo and bar are not massive. If they are both massive then forming zip(foo,bar) is an unnecessarily massive
temporary variable, and should be replaced by itertools.izip or
itertools.izip_longest, which returns an iterator instead of a list.
import itertools
for f,b in itertools.izip(foo,bar):
    print(f,b)
for f,b in itertools.izip_longest(foo,bar):
    print(f,b)

izip stops when either foo or bar is exhausted.
izip_longest stops when both foo and bar are exhausted.
When the shorter iterator(s) are exhausted, izip_longest yields a tuple with None in the position corresponding to that iterator. You can also set a different fillvalue besides None if you wish. See here for the full story.

Note also that zip and its zip-like brethen can accept an arbitrary number of iterables as arguments. For example,
for num, cheese, color in zip([1,2,3], ['manchego', 'stilton', 'brie'], 
                              ['red', 'blue', 'green']):
    print('{} {} {}'.format(num, color, cheese))

prints
1 red manchego
2 blue stilton
3 green brie

"
How to print a number using commas as thousands separators,https://stackoverflow.com/questions/1823058/how-to-print-a-number-using-commas-as-thousands-separators,1296,python;number-formatting,"Locale-agnostic: use _ as the thousand separator
f'{value:_}'          # For Python ≥3.6

Note that this will NOT format in the user's current locale and will always use _ as the thousand separator, so for example:
1234567 ⟶ 1_234_567

English style: use , as the thousand separator
'{:,}'.format(value)  # For Python ≥2.7
f'{value:,}'          # For Python ≥3.6

Locale-aware
import locale
locale.setlocale(locale.LC_ALL, '')  # Use '' for auto, or force e.g. to 'en_US.UTF-8'

'{:n}'.format(value)  # For Python ≥2.7
f'{value:n}'          # For Python ≥3.6

Reference
Per Format Specification Mini-Language,

The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead.

and:

The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits.

"
How do I install a Python package with a .whl file?,https://stackoverflow.com/questions/27885397/how-do-i-install-a-python-package-with-a-whl-file,1296,python;pip;python-wheel,"I just used the following which was quite simple. First open a console then cd to where you've downloaded your file like some-package.whl and use
pip install some-package.whl

Note: if pip.exe is not recognized, you may find it in the ""Scripts"" directory from where python has been installed. If pip is not installed, this page can help:
How do I install pip on Windows?
Note: for clarification
If you copy the *.whl file to your local drive (ex. C:\some-dir\some-file.whl) use the following command line parameters --  
pip install C:/some-dir/some-file.whl

"
Fastest way to check if a value exists in a list,https://stackoverflow.com/questions/7571635/fastest-way-to-check-if-a-value-exists-in-a-list,1286,python;list;performance;membership,"7 in a

Clearest and fastest way to do it.
You can also consider using a set, but constructing that set from your list may take more time than faster membership testing will save. The only way to be certain is to benchmark well. (this also depends on what operations you require)
"
Usage of __slots__?,https://stackoverflow.com/questions/472000/usage-of-slots,1286,python;oop;python-internals;slots,"
In Python, what is the purpose of __slots__ and what are the cases one should avoid this?

TLDR:
The special attribute __slots__ allows you to explicitly state which instance attributes you expect your object instances to have, with the expected results:

faster attribute access.
space savings in memory.

The space savings is from

Storing value references in slots instead of __dict__.
Denying __dict__ and __weakref__ creation if parent classes deny them and you declare __slots__.

Quick Caveats
Small caveat, you should only declare a particular slot one time in an inheritance tree. For example:
class Base:
    __slots__ = 'foo', 'bar'

class Right(Base):
    __slots__ = 'baz', 

class Wrong(Base):
    __slots__ = 'foo', 'bar', 'baz'        # redundant foo and bar

Python doesn't object when you get this wrong (it probably should), problems might not otherwise manifest, but your objects will take up more space than they otherwise should. Python 3.8:
>>> from sys import getsizeof
>>> getsizeof(Right()), getsizeof(Wrong())
(56, 72)

This is because the Base's slot descriptor has a slot separate from the Wrong's. This shouldn't usually come up, but it could:
>>> w = Wrong()
>>> w.foo = 'foo'
>>> Base.foo.__get__(w)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
AttributeError: foo
>>> Wrong.foo.__get__(w)
'foo'

The biggest caveat is for multiple inheritance - multiple ""parent classes with nonempty slots"" cannot be combined.
To accommodate this restriction, follow best practices: Factor out all but one or all parents' abstraction which their concrete class respectively and your new concrete class collectively will inherit from - giving the abstraction(s) empty slots (just like abstract base classes in the standard library).
See section on multiple inheritance below for an example.
Requirements:

To have attributes named in __slots__ to actually be stored in slots instead of a __dict__, a class must inherit from object (automatic in Python 3, but must be explicit in Python 2).

To prevent the creation of a __dict__, you must inherit from object and all classes in the inheritance must declare __slots__ and none of them can have a '__dict__' entry.


There are a lot of details if you wish to keep reading.
Why use __slots__: Faster attribute access.
The creator of Python, Guido van Rossum, states that he actually created __slots__ for faster attribute access.
It is trivial to demonstrate measurably significant faster access:
import timeit

class Foo(object): __slots__ = 'foo',

class Bar(object): pass

slotted = Foo()
not_slotted = Bar()

def get_set_delete_fn(obj):
    def get_set_delete():
        obj.foo = 'foo'
        obj.foo
        del obj.foo
    return get_set_delete

and
>>> min(timeit.repeat(get_set_delete_fn(slotted)))
0.2846834529991611
>>> min(timeit.repeat(get_set_delete_fn(not_slotted)))
0.3664822799983085

The slotted access is almost 30% faster in Python 3.5 on Ubuntu.
>>> 0.3664822799983085 / 0.2846834529991611
1.2873325658284342

In Python 2 on Windows I have measured it about 15% faster.
Why use __slots__:  Memory Savings
Another purpose of __slots__ is to reduce the space in memory that each object instance takes up.
My own contribution to the documentation clearly states the reasons behind this:

The space saved over using __dict__ can be significant.

SQLAlchemy attributes a lot of memory savings to __slots__.
To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux, with guppy.hpy (aka heapy) and sys.getsizeof, the size of a class instance without __slots__ declared, and nothing else, is 64 bytes. That does not include the __dict__. Thank you Python for lazy evaluation again, the __dict__ is apparently not called into existence until it is referenced, but classes without data are usually useless. When called into existence, the __dict__ attribute is a minimum of 280 bytes additionally.
In contrast, a class instance with __slots__ declared to be () (no data) is only 16 bytes, and 56 total bytes with one item in slots, 64 with two.
For 64 bit Python, I illustrate the memory consumption in bytes in Python 2.7 and 3.6, for __slots__ and __dict__ (no slots defined) for each point where the dict grows in 3.6 (except for 0, 1, and 2 attributes):
       Python 2.7             Python 3.6
attrs  __slots__  __dict__*   __slots__  __dict__* | *(no slots defined)
none   16         56 + 272†   16         56 + 112† | †if __dict__ referenced
one    48         56 + 272    48         56 + 112
two    56         56 + 272    56         56 + 112
six    88         56 + 1040   88         56 + 152
11     128        56 + 1040   128        56 + 240
22     216        56 + 3344   216        56 + 408     
43     384        56 + 3344   384        56 + 752

So, in spite of smaller dicts in Python 3, we see how nicely __slots__ scale for instances to save us memory, and that is a major reason you would want to use __slots__.
Just for completeness of my notes, note that there is a one-time cost per slot in the class's namespace of 64 bytes in Python 2, and 72 bytes in Python 3, because slots use data descriptors like properties, called ""members"".
>>> Foo.foo
<member 'foo' of 'Foo' objects>
>>> type(Foo.foo)
<class 'member_descriptor'>
>>> getsizeof(Foo.foo)
72

Demonstration of __slots__:
To deny the creation of a __dict__, you must subclass object. Everything subclasses object in Python 3, but in Python 2 you had to be explicit:
class Base(object): 
    __slots__ = ()

now:
>>> b = Base()
>>> b.a = 'a'
Traceback (most recent call last):
  File ""<pyshell#38>"", line 1, in <module>
    b.a = 'a'
AttributeError: 'Base' object has no attribute 'a'

Or subclass another class that defines __slots__
class Child(Base):
    __slots__ = ('a',)

and now:
c = Child()
c.a = 'a'

but:
>>> c.b = 'b'
Traceback (most recent call last):
  File ""<pyshell#42>"", line 1, in <module>
    c.b = 'b'
AttributeError: 'Child' object has no attribute 'b'

To allow __dict__ creation while subclassing slotted objects, just add '__dict__' to the __slots__ (note that slots are ordered, and you shouldn't repeat slots that are already in parent classes):
class SlottedWithDict(Child): 
    __slots__ = ('__dict__', 'b')

swd = SlottedWithDict()
swd.a = 'a'
swd.b = 'b'
swd.c = 'c'

and
>>> swd.__dict__
{'c': 'c'}

Or you don't even need to declare __slots__ in your subclass, and you will still use slots from the parents, but not restrict the creation of a __dict__:
class NoSlots(Child): pass
ns = NoSlots()
ns.a = 'a'
ns.b = 'b'

And:
>>> ns.__dict__
{'b': 'b'}

However, __slots__ may cause problems for multiple inheritance:
class BaseA(object): 
    __slots__ = ('a',)

class BaseB(object): 
    __slots__ = ('b',)

Because creating a child class from parents with both non-empty slots fails:
>>> class Child(BaseA, BaseB): __slots__ = ()
Traceback (most recent call last):
  File ""<pyshell#68>"", line 1, in <module>
    class Child(BaseA, BaseB): __slots__ = ()
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict

If you run into this problem, You could just remove __slots__ from the parents, or if you have control of the parents, give them empty slots, or refactor to abstractions:
from abc import ABC

class AbstractA(ABC):
    __slots__ = ()

class BaseA(AbstractA): 
    __slots__ = ('a',)

class AbstractB(ABC):
    __slots__ = ()

class BaseB(AbstractB): 
    __slots__ = ('b',)

class Child(AbstractA, AbstractB): 
    __slots__ = ('a', 'b')

c = Child() # no problem!

Add '__dict__' to __slots__ to get dynamic assignment:
class Foo(object):
    __slots__ = 'bar', 'baz', '__dict__'

and now:
>>> foo = Foo()
>>> foo.boink = 'boink'

So with '__dict__' in slots we lose some of the size benefits with the upside of having dynamic assignment and still having slots for the names we do expect.
When you inherit from an object that isn't slotted, you get the same sort of semantics when you use __slots__ - names that are in __slots__ point to  slotted values, while any other values are put in the instance's __dict__.
Avoiding __slots__ because you want to be able to add attributes on the fly is actually not a good reason - just add ""__dict__"" to your __slots__ if this is required.
You can similarly add __weakref__ to __slots__ explicitly if you need that feature.
Set to empty tuple when subclassing a namedtuple:
The namedtuple builtin make immutable instances that are very lightweight (essentially, the size of tuples) but to get the benefits, you need to do it yourself if you subclass them:
from collections import namedtuple
class MyNT(namedtuple('MyNT', 'bar baz')):
    """"""MyNT is an immutable and lightweight object""""""
    __slots__ = ()

usage:
>>> nt = MyNT('bar', 'baz')
>>> nt.bar
'bar'
>>> nt.baz
'baz'

And trying to assign an unexpected attribute raises an AttributeError because we have prevented the creation of __dict__:
>>> nt.quux = 'quux'
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
AttributeError: 'MyNT' object has no attribute 'quux'

You can allow __dict__ creation by leaving off __slots__ = (), but you can't use non-empty __slots__ with subtypes of tuple.
Biggest Caveat: Multiple inheritance
Even when non-empty slots are the same for multiple parents, they cannot be used together:
class Foo(object): 
    __slots__ = 'foo', 'bar'
class Bar(object):
    __slots__ = 'foo', 'bar' # alas, would work if empty, i.e. ()

>>> class Baz(Foo, Bar): pass
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict

Using an empty __slots__ in the parent seems to provide the most flexibility, allowing the child to choose to prevent or allow (by adding '__dict__' to get dynamic assignment, see section above) the creation of a __dict__:
class Foo(object): __slots__ = ()
class Bar(object): __slots__ = ()
class Baz(Foo, Bar): __slots__ = ('foo', 'bar')
b = Baz()
b.foo, b.bar = 'foo', 'bar'

You don't have to have slots - so if you add them, and remove them later, it shouldn't cause any problems.
Going out on a limb here: If you're composing mixins or using abstract base classes, which aren't intended to be instantiated, an empty __slots__ in those parents seems to be the best way to go in terms of flexibility for subclassers.
To demonstrate, first, let's create a class with code we'd like to use under multiple inheritance
class AbstractBase:
    __slots__ = ()
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __repr__(self):
        return f'{type(self).__name__}({repr(self.a)}, {repr(self.b)})'

We could use the above directly by inheriting and declaring the expected slots:
class Foo(AbstractBase):
    __slots__ = 'a', 'b'

But we don't care about that, that's trivial single inheritance, we need another class we might also inherit from, maybe with a noisy attribute:
class AbstractBaseC:
    __slots__ = ()
    @property
    def c(self):
        print('getting c!')
        return self._c
    @c.setter
    def c(self, arg):
        print('setting c!')
        self._c = arg

Now if both bases had nonempty slots, we couldn't do the below. (In fact, if we wanted, we could have given AbstractBase nonempty slots a and b, and left them out of the below declaration - leaving them in would be wrong):
class Concretion(AbstractBase, AbstractBaseC):
    __slots__ = 'a b _c'.split()

And now we have functionality from both via multiple inheritance, and can still deny __dict__ and __weakref__ instantiation:
>>> c = Concretion('a', 'b')
>>> c.c = c
setting c!
>>> c.c
getting c!
Concretion('a', 'b')
>>> c.d = 'd'
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
AttributeError: 'Concretion' object has no attribute 'd'

Other cases to avoid slots:

Avoid them when you want to perform __class__ assignment with another class that doesn't have them (and you can't add them) unless the slot layouts are identical. (I am very interested in learning who is doing this and why.)
Avoid them if you want to subclass variable length builtins like long, tuple, or str, and you want to add attributes to them.
Avoid them if you insist on providing default values via class attributes for instance variables.

You may be able to tease out further caveats from the rest of the __slots__ documentation (the 3.7 dev docs are the most current), which I have made significant recent contributions to.
Critiques of other answers
The current top answers cite outdated information and are quite hand-wavy and miss the mark in some important ways.
Do not ""only use __slots__ when instantiating lots of objects""
I quote:

""You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class.""

Abstract Base Classes, for example, from the collections module, are not instantiated, yet __slots__ are declared for them.
Why?
If a user wishes to deny __dict__ or __weakref__ creation, those things must not be available in the parent classes.
__slots__ contributes to reusability when creating interfaces or mixins.
It is true that many Python users aren't writing for reusability, but when you are, having the option to deny unnecessary space usage is valuable.
__slots__ doesn't break pickling
When pickling a slotted object, you may find it complains with a misleading TypeError:
>>> pickle.loads(pickle.dumps(f))
TypeError: a class that defines __slots__ without defining __getstate__ cannot be pickled

This is actually incorrect. This message comes from the oldest protocol, which is the default. You can select the latest protocol with the -1 argument. In Python 2.7 this would be 2 (which was introduced in 2.3), and in 3.6 it is 4.
>>> pickle.loads(pickle.dumps(f, -1))
<__main__.Foo object at 0x1129C770>

in Python 2.7:
>>> pickle.loads(pickle.dumps(f, 2))
<__main__.Foo object at 0x1129C770>

in Python 3.6
>>> pickle.loads(pickle.dumps(f, 4))
<__main__.Foo object at 0x1129C770>

So I would keep this in mind, as it is a solved problem.
Critique of the (until Oct 2, 2016) accepted answer
The first paragraph is half short explanation, half predictive. Here's the only part that actually answers the question

The proper use of __slots__ is to save space in objects. Instead of having a dynamic dict that allows adding attributes to objects at anytime, there is a static structure which does not allow additions after creation. This saves the overhead of one dict for every object that uses slots

The second half is wishful thinking, and off the mark:

While this is sometimes a useful optimization, it would be completely unnecessary if the Python interpreter was dynamic enough so that it would only require the dict when there actually were additions to the object.

Python actually does something similar to this, only creating the __dict__ when it is accessed, but creating lots of objects with no data is fairly ridiculous.
The second paragraph oversimplifies and misses actual reasons to avoid __slots__. The below is not a real reason to avoid slots (for actual reasons, see the rest of my answer above.):

They change the behavior of the objects that have slots in a way that can be abused by control freaks and static typing weenies.

It then goes on to discuss other ways of accomplishing that perverse goal with Python, not discussing anything to do with __slots__.
The third paragraph is more wishful thinking. Together it is mostly off-the-mark content that the answerer didn't even author and contributes to ammunition for critics of the site.
Memory usage evidence
Create some normal objects and slotted objects:
>>> class Foo(object): pass
>>> class Bar(object): __slots__ = ()

Instantiate a million of them:
>>> foos = [Foo() for f in xrange(1000000)]
>>> bars = [Bar() for b in xrange(1000000)]

Inspect with guppy.hpy().heap():
>>> guppy.hpy().heap()
Partition of a set of 2028259 objects. Total size = 99763360 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0 1000000  49 64000000  64  64000000  64 __main__.Foo
     1     169   0 16281480  16  80281480  80 list
     2 1000000  49 16000000  16  96281480  97 __main__.Bar
     3   12284   1   987472   1  97268952  97 str
...

Access the regular objects and their __dict__ and inspect again:
>>> for f in foos:
...     f.__dict__
>>> guppy.hpy().heap()
Partition of a set of 3028258 objects. Total size = 379763480 bytes.
 Index  Count   %      Size    % Cumulative  % Kind (class / dict of class)
     0 1000000  33 280000000  74 280000000  74 dict of __main__.Foo
     1 1000000  33  64000000  17 344000000  91 __main__.Foo
     2     169   0  16281480   4 360281480  95 list
     3 1000000  33  16000000   4 376281480  99 __main__.Bar
     4   12284   0    987472   0 377268952  99 str
...

This is consistent with the history of Python, from Unifying types and classes in Python 2.2

If you subclass a built-in type, extra space is automatically added to the instances to accomodate __dict__ and __weakrefs__. (The __dict__ is not initialized until you use it though, so you shouldn't worry about the space occupied by an empty dictionary for each instance you create.) If you don't need this extra space, you can add the phrase ""__slots__ = []"" to your class.

"
How do I sort a list of objects based on an attribute of the objects?,https://stackoverflow.com/questions/403421/how-do-i-sort-a-list-of-objects-based-on-an-attribute-of-the-objects,1280,python;list;sorting;reverse,"To sort the list in place:
orig_list.sort(key=lambda x: x.count, reverse=True)

To return a new list, use sorted:
new_list = sorted(orig_list, key=lambda x: x.count, reverse=True)

Explanation:

key=lambda x: x.count sorts by count.
reverse=True sorts in descending order.

More on sorting by keys.
"
"Should I put #! (shebang) in Python scripts, and what form should it take?",https://stackoverflow.com/questions/6908143/should-i-put-shebang-in-python-scripts-and-what-form-should-it-take,1280,python;shell;python-3.x;shebang,"The shebang line in any script determines the script's ability to be executed like a standalone executable without typing python beforehand in the terminal or when double clicking it in a file manager (when configured properly). It isn't necessary but generally put there so when someone sees the file opened in an editor, they immediately know what they're looking at. However, which shebang line you use is important.
Correct usage for (defaults to version 3.latest) Python 3 scripts is:
#!/usr/bin/env python3

Correct usage for (defaults to version 2.latest) Python 2 scripts is:
#!/usr/bin/env python2

The following should not be used (except for the rare case that you are writing code which is compatible with both Python 2.x and 3.x):
#!/usr/bin/env python

The reason for these recommendations, given in PEP 394, is that python can refer either to python2 or python3 on different systems.
Also, do not use:
#!/usr/local/bin/python


""python may be installed at /usr/bin/python or /bin/python in those
cases, the above #! will fail.""

―""#!/usr/bin/env python"" vs ""#!/usr/local/bin/python""
"
Remove all whitespace in a string,https://stackoverflow.com/questions/8270092/remove-all-whitespace-in-a-string,1278,python;string;trim;removing-whitespace,"If you want to remove leading and ending whitespace, use str.strip():
>>> ""  hello  apple  "".strip()
'hello  apple'

If you want to remove all space characters, use str.replace() (NB this only removes the “normal” ASCII space character ' ' U+0020 but not any other whitespace):
>>> ""  hello  apple  "".replace("" "", """")
'helloapple'

If you want to remove all whitespace and then leave a single space character between words, use str.split() followed by str.join():
>>> "" "".join(""  hello  apple  "".split())
'hello apple'

If you want to remove all whitespace then change the above leading "" "" to """":
>>> """".join(""  hello  apple  "".split())
'helloapple'

"
Get difference between two lists with Unique Entries,https://stackoverflow.com/questions/3462143/get-difference-between-two-lists-with-unique-entries,1268,python;performance;list;set;set-difference,"To get elements which are in temp1 but not in temp2 (assuming uniqueness of the elements in each list):
In [5]: list(set(temp1) - set(temp2))
Out[5]: ['Four', 'Three']

Beware that it is asymmetric :
In [5]: set([1, 2]) - set([2, 3])
Out[5]: set([1]) 

where you might expect/want it to equal set([1, 3]). If you do want set([1, 3]) as your answer, you can use set([1, 2]).symmetric_difference(set([2, 3])).
"
How do you test that a Python function throws an exception?,https://stackoverflow.com/questions/129507/how-do-you-test-that-a-python-function-throws-an-exception,1267,python;unit-testing;exception,"Use TestCase.assertRaises from the unittest module, for example:
import mymod

class MyTestCase(unittest.TestCase):
    def test1(self):
        self.assertRaises(SomeCoolException, mymod.myfunc)

"
Pretty-print an entire Pandas Series / DataFrame,https://stackoverflow.com/questions/19124601/pretty-print-an-entire-pandas-series-dataframe,1259,python;pandas;dataframe,"You can also use the option_context, with one or more options:
with pd.option_context('display.max_rows', None, 'display.max_columns', None):  # more options can be specified also
    print(df)

This will automatically return the options to their previous values.
If you are working on jupyter-notebook, using display(df) instead of print(df) will use jupyter rich display logic (like so).
"
How do I trim whitespace?,https://stackoverflow.com/questions/1185524/how-do-i-trim-whitespace,1253,python;string;whitespace;trim;strip,"For whitespace on both sides, use str.strip:
s = ""  \t a string example\t  ""
s = s.strip()

For whitespace on the right side, use str.rstrip:
s = s.rstrip()

For whitespace on the left side, use str.lstrip:
s = s.lstrip()

You can provide an argument to strip arbitrary characters to any of these functions, like this:
s = s.strip(' \t\n\r')

This will strip any space, \t, \n, or \r characters from both sides of the string.
The examples above only remove strings from the left-hand and right-hand sides of strings. If you want to also remove characters from the middle of a string, try re.sub:
import re
print(re.sub('[\s+]', '', s))

That should print out:
astringexample

"
What is a cross-platform way to get the home directory?,https://stackoverflow.com/questions/4028904/what-is-a-cross-platform-way-to-get-the-home-directory,1252,python;cross-platform;home-directory,"On Python 3.5+ you can use pathlib.Path.home():
from pathlib import Path
home = Path.home()

# example usage:
with open(home / "".ssh"" / ""known_hosts"") as f:
    lines = f.readlines()

to get a pathlib.PosixPath object. Use str() to convert to a string if necessary.

On older Python versions, you can use os.path.expanduser.
from os.path import expanduser
home = expanduser(""~"")

"
How to concatenate (join) items in a list to a single string,https://stackoverflow.com/questions/12453580/how-to-concatenate-join-items-in-a-list-to-a-single-string,1251,python;string;list;concatenation,"Use str.join:
>>> words = ['this', 'is', 'a', 'sentence']
>>> '-'.join(words)
'this-is-a-sentence'
>>> ' '.join(words)
'this is a sentence'

"
What are &quot;named tuples&quot; in Python?,https://stackoverflow.com/questions/2970608/what-are-named-tuples-in-python,1250,python;types;tuples;terminology;namedtuple,"Named tuples are basically easy-to-create, lightweight object types.  Named tuple instances can be referenced using object-like variable dereferencing or the standard tuple syntax.  They can be used similarly to struct or other common record types, except that they are immutable.  They were added in Python 2.6 and Python 3.0, although there is a recipe for implementation in Python 2.4.
For example, it is common to represent a point as a tuple (x, y).  This leads to code like the following:
pt1 = (1.0, 5.0)
pt2 = (2.5, 1.5)

from math import sqrt
line_length = sqrt((pt1[0]-pt2[0])**2 + (pt1[1]-pt2[1])**2)

Using a named tuple it becomes more readable:
from collections import namedtuple
Point = namedtuple('Point', 'x y')
pt1 = Point(1.0, 5.0)
pt2 = Point(2.5, 1.5)

from math import sqrt
line_length = sqrt((pt1.x-pt2.x)**2 + (pt1.y-pt2.y)**2)

However, named tuples are still backwards compatible with normal tuples, so the following will still work:
Point = namedtuple('Point', 'x y')
pt1 = Point(1.0, 5.0)
pt2 = Point(2.5, 1.5)

from math import sqrt
# use index referencing
line_length = sqrt((pt1[0]-pt2[0])**2 + (pt1[1]-pt2[1])**2)
 # use tuple unpacking
x1, y1 = pt1

Thus, you should use named tuples instead of tuples anywhere you think object notation will make your code more pythonic and more easily readable.  I personally have started using them to represent very simple value types, particularly when passing them as parameters to functions.  It makes the functions more readable, without seeing the context of the tuple packing.
Furthermore, you can also replace ordinary immutable classes that have no functions, only fields with them.  You can even use your named tuple types as base classes:
class Point(namedtuple('Point', 'x y')):
    [...]

However, as with tuples, attributes in named tuples are immutable:
>>> Point = namedtuple('Point', 'x y')
>>> pt1 = Point(1.0, 5.0)
>>> pt1.x = 2.0
AttributeError: can't set attribute

If you want to be able change the values, you need another type.  There is a handy recipe for mutable recordtypes which allow you to set new values to attributes.
>>> from rcdtype import *
>>> Point = recordtype('Point', 'x y')
>>> pt1 = Point(1.0, 5.0)
>>> pt1 = Point(1.0, 5.0)
>>> pt1.x = 2.0
>>> print(pt1[0])
    2.0

I am not aware of any form of ""named list"" that lets you add new fields, however.  You may just want to use a dictionary in this situation. Named tuples can be converted to dictionaries using pt1._asdict() which returns {'x': 1.0, 'y': 5.0} and can be operated upon with all the usual dictionary functions.  
As already noted, you should check the documentation for more information from which these examples were constructed.
"
Find which version of package is installed with pip,https://stackoverflow.com/questions/10214827/find-which-version-of-package-is-installed-with-pip,1231,python;pip,"As of pip 1.3, there is a pip show command.
$ pip show Jinja2
---
Name: Jinja2
Version: 2.7.3
Location: /path/to/virtualenv/lib/python2.7/site-packages
Requires: markupsafe

In older versions, pip freeze and grep should do the job nicely.
$ pip freeze | grep Jinja2
Jinja2==2.7.3

"
Has Django served an excess of 100k daily visits?,https://stackoverflow.com/questions/886221/has-django-served-an-excess-of-100k-daily-visits,1223,python;django;web-applications;scalability,"
""What are the largest sites built on Django today?""
There isn't any single place that collects information about traffic on Django built sites, so I'll have to take a stab at it using data from various locations.  First, we have a list of Django sites on the front page of the main Django project page and then a list of Django built sites at djangosites.org.  Going through the lists and picking some that I know have decent traffic we see:

Instagram: What Powers Instagram: Hundreds of Instances, Dozens of Technologies.
Pinterest: Alexa rank 37 (21.4.2015) and 70 Million users in 2013
Bitbucket: 200TB of Code and 2.500.000 Users
Disqus: Serving 400 million people with Python.
curse.com: 600k daily visits.
tabblo.com: 44k daily visits, see Ned Batchelder's posts Infrastructure for modern web sites.
chesspark.com: Alexa rank about 179k.
pownce.com (no longer active): alexa rank about 65k.
Mike Malone of Pownce, in his EuroDjangoCon presentation on Scaling Django Web Apps says ""hundreds of hits per second"".  This is a very good presentation on how to scale Django, and makes some good points including (current) shortcomings in Django scalability.
HP had a site built with Django 1.5: ePrint center. However, as for novemer/2015 the entire website was migrated and this link is just a redirect. This website was a world-wide service attending subscription to Instant Ink and related services HP offered (*).

""Can Django deal with 100,000 users daily, each visiting the site for a couple of hours?""
Yes, see above.
""Could a site like Stack Overflow run on Django?""
My gut feeling is yes but, as others answered and Mike Malone mentions in his presentation, database design is critical. Strong proof might also be found at www.cnprog.com if we can find any reliable traffic stats. Anyway, it's not just something that will happen by throwing together a bunch of Django models :)

There are, of course, many more sites and bloggers of interest, but I have got to stop somewhere!

Blog post about Using Django to build high-traffic site michaelmoore.com described as a top 10,000 website.  Quantcast stats and compete.com stats.

(*) The author of the edit, including such reference, used to work as outsourced developer in that project.
"
How to subtract a day from a date?,https://stackoverflow.com/questions/441147/how-to-subtract-a-day-from-a-date,1221,python;date;datetime;timedelta,"You can use a timedelta object:
from datetime import datetime, timedelta
    
d = datetime.today() - timedelta(days=days_to_subtract)

"
pip install from git repo branch,https://stackoverflow.com/questions/20101834/pip-install-from-git-repo-branch,1220,python;git;pip,"Prepend the url prefix git+ (See VCS Support):
pip install git+https://github.com/tangentlabs/django-oscar-paypal.git@issue/34/oscar-0.6

And specify the branch name without the leading /.
"
Is there a simple way to delete a list element by value?,https://stackoverflow.com/questions/2793324/is-there-a-simple-way-to-delete-a-list-element-by-value,1213,python;list,"To remove the first occurrence of an element, use list.remove:
>>> xs = ['a', 'b', 'c', 'd']
>>> xs.remove('b')
>>> print(xs)
['a', 'c', 'd']

To remove all occurrences of an element, use a list comprehension:
>>> xs = ['a', 'b', 'c', 'd', 'b', 'b', 'b', 'b']
>>> xs = [x for x in xs if x != 'b']
>>> print(xs)
['a', 'c', 'd']

"
Convert list of dictionaries to a pandas DataFrame,https://stackoverflow.com/questions/20638006/convert-list-of-dictionaries-to-a-pandas-dataframe,1212,python;dictionary;pandas;dataframe,"If ds is a list of dicts:
df = pd.DataFrame(ds)

Note: this does not work with nested data.
"
"Difference between del, remove, and pop on lists in Python",https://stackoverflow.com/questions/11520492/difference-between-del-remove-and-pop-on-lists-in-python,1211,python;list,"The effects of the three different methods to remove an element from a list:
remove removes the first matching value, not a specific index:
>>> a = [0, 2, 3, 2]
>>> a.remove(2)
>>> a
[0, 3, 2]

del removes the item at a specific index:
>>> a = [9, 8, 7, 6]
>>> del a[1]
>>> a
[9, 7, 6]

and pop removes the item at a specific index and returns it.
>>> a = [4, 3, 5]
>>> a.pop(1)
3
>>> a
[4, 5]

Their error modes are different too:
>>> a = [4, 5, 6]
>>> a.remove(7)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: list.remove(x): x not in list
>>> del a[7]
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
IndexError: list assignment index out of range
>>> a.pop(7)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
IndexError: pop index out of range

"
Convert a String representation of a Dictionary to a dictionary,https://stackoverflow.com/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary,1210,python;string;dictionary;type-conversion,"You can use the built-in ast.literal_eval:
>>> import ast
>>> ast.literal_eval(""{'muffin' : 'lolz', 'foo' : 'kitty'}"")
{'muffin': 'lolz', 'foo': 'kitty'}

This is safer than using eval.  As its own docs say:

>>> help(ast.literal_eval)
Help on function literal_eval in module ast:

literal_eval(node_or_string)
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
    and None.

For example:
>>> eval(""shutil.rmtree('mongo')"")
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""<string>"", line 1, in <module>
  File ""/opt/Python-2.6.1/lib/python2.6/shutil.py"", line 208, in rmtree
    onerror(os.listdir, path, sys.exc_info())
  File ""/opt/Python-2.6.1/lib/python2.6/shutil.py"", line 206, in rmtree
    names = os.listdir(path)
OSError: [Errno 2] No such file or directory: 'mongo'
>>> ast.literal_eval(""shutil.rmtree('mongo')"")
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""/opt/Python-2.6.1/lib/python2.6/ast.py"", line 68, in literal_eval
    return _convert(node_or_string)
  File ""/opt/Python-2.6.1/lib/python2.6/ast.py"", line 67, in _convert
    raise ValueError('malformed string')
ValueError: malformed string

"
How can I write a `try`/`except` block that catches all exceptions?,https://stackoverflow.com/questions/4990718/how-can-i-write-a-try-except-block-that-catches-all-exceptions,1203,python;exception,"You can but you probably shouldn't:
try:
    do_something()
except:
    print(""Caught it!"")

However, this will also catch exceptions like KeyboardInterrupt and you usually don't want that, do you? Unless you re-raise the exception right away - see the following example from the docs:
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError as (errno, strerror):
    print(""I/O error({0}): {1}"".format(errno, strerror))
except ValueError:
    print(""Could not convert data to an integer."")
except:
    print(""Unexpected error:"", sys.exc_info()[0])
    raise

"
How do I check file size in Python?,https://stackoverflow.com/questions/2104080/how-do-i-check-file-size-in-python,1200,python;file,"You need the st_size property of the object returned by os.stat. You can get it by either using pathlib (Python 3.4+):
>>> from pathlib import Path
>>> Path('somefile.txt').stat()
os.stat_result(st_mode=33188, st_ino=6419862, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=1564, st_atime=1584299303, st_mtime=1584299400, st_ctime=1584299400)
>>> Path('somefile.txt').stat().st_size
1564

or using os.stat:
>>> import os
>>> os.stat('somefile.txt')
os.stat_result(st_mode=33188, st_ino=6419862, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=1564, st_atime=1584299303, st_mtime=1584299400, st_ctime=1584299400)
>>> os.stat('somefile.txt').st_size
1564

Output is in bytes.
"
&quot;Large data&quot; workflows using pandas,https://stackoverflow.com/questions/14262433/large-data-workflows-using-pandas,1187,python;mongodb;pandas;hdf5;large-data,"I routinely use tens of gigabytes of data in just this fashion
e.g. I have tables on disk that I read via queries, create data and append back.
It's worth reading the docs and late in this thread for several suggestions for how to store your data.
Details which will affect how you store your data, like:
Give as much detail as you can; and I can help you develop a structure.

Size of data, # of rows, columns, types of columns; are you appending
rows, or just columns? 
What will typical operations look like. E.g. do a query on columns to select a bunch of rows and specific columns, then do an operation (in-memory), create new columns, save these.
(Giving a toy example could enable us to offer more specific recommendations.)
After that processing, then what do you do? Is step 2 ad hoc, or repeatable?
Input flat files: how many, rough total size in Gb. How are these organized e.g. by records? Does each one contains different fields, or do they have some records per file with all of the fields in each file?
Do you ever select subsets of rows (records) based on criteria (e.g. select the rows with field A > 5)? and then do something, or do you just select fields A, B, C with all of the records (and then do something)?
Do you 'work on' all of your columns (in groups), or are there a good proportion that you may only use for reports (e.g. you want to keep the data around, but don't need to pull in that column explicity until final results time)?

Solution
Ensure you have pandas at least 0.10.1 installed.
Read iterating files chunk-by-chunk and multiple table queries.
Since pytables is optimized to operate on row-wise (which is what you query on), we will create a table for each group of fields. This way it's easy to select a small group of fields (which will work with a big table, but it's more efficient to do it this way... I think I may be able to fix this limitation in the future... this is more intuitive anyhow):
(The following is pseudocode.)
import numpy as np
import pandas as pd

# create a store
store = pd.HDFStore('mystore.h5')

# this is the key to your storage:
#    this maps your fields to a specific group, and defines 
#    what you want to have as data_columns.
#    you might want to create a nice class wrapping this
#    (as you will want to have this map and its inversion)  
group_map = dict(
    A = dict(fields = ['field_1','field_2',.....], dc = ['field_1',....,'field_5']),
    B = dict(fields = ['field_10',......        ], dc = ['field_10']),
    .....
    REPORTING_ONLY = dict(fields = ['field_1000','field_1001',...], dc = []),

)

group_map_inverted = dict()
for g, v in group_map.items():
    group_map_inverted.update(dict([ (f,g) for f in v['fields'] ]))

Reading in the files and creating the storage (essentially doing what append_to_multiple does):
for f in files:
   # read in the file, additional options may be necessary here
   # the chunksize is not strictly necessary, you may be able to slurp each 
   # file into memory in which case just eliminate this part of the loop 
   # (you can also change chunksize if necessary)
   for chunk in pd.read_table(f, chunksize=50000):
       # we are going to append to each table by group
       # we are not going to create indexes at this time
       # but we *ARE* going to create (some) data_columns

       # figure out the field groupings
       for g, v in group_map.items():
             # create the frame for this group
             frame = chunk.reindex(columns = v['fields'], copy = False)    

             # append it
             store.append(g, frame, index=False, data_columns = v['dc'])

Now you have all of the tables in the file (actually you could store them in separate files if you wish, you would prob have to add the filename to the group_map, but probably this isn't necessary).
This is how you get columns and create new ones:
frame = store.select(group_that_I_want)
# you can optionally specify:
# columns = a list of the columns IN THAT GROUP (if you wanted to
#     select only say 3 out of the 20 columns in this sub-table)
# and a where clause if you want a subset of the rows

# do calculations on this frame
new_frame = cool_function_on_frame(frame)

# to 'add columns', create a new group (you probably want to
# limit the columns in this new_group to be only NEW ones
# (e.g. so you don't overlap from the other tables)
# add this info to the group_map
store.append(new_group, new_frame.reindex(columns = new_columns_created, copy = False), data_columns = new_columns_created)

When you are ready for post_processing:
# This may be a bit tricky; and depends what you are actually doing.
# I may need to modify this function to be a bit more general:
report_data = store.select_as_multiple([groups_1,groups_2,.....], where =['field_1>0', 'field_1000=foo'], selector = group_1)

About data_columns, you don't actually need to define ANY data_columns; they allow you to sub-select rows based on the column. E.g. something like:
store.select(group, where = ['field_1000=foo', 'field_1001>0'])

They may be most interesting to you in the final report generation stage (essentially a data column is segregated from other columns, which might impact efficiency somewhat if you define a lot).
You also might want to:

create a function which takes a list of fields, looks up the groups in the groups_map, then selects these and concatenates the results so you get the resulting frame (this is essentially what select_as_multiple does). This way the structure would be pretty transparent to you.
indexes on certain data columns (makes row-subsetting much faster).
enable compression.

Let me know when you have questions!
"
Checking whether a variable is an integer or not,https://stackoverflow.com/questions/3501382/checking-whether-a-variable-is-an-integer-or-not,1183,python;integer,"If you need to do this, do
isinstance(<var>, int)

unless you are in Python 2.x in which case you want
isinstance(<var>, (int, long))

Do not use type. It is almost never the right answer in Python, since it blocks all the flexibility of polymorphism. For instance, if you subclass int, your new class should register as an int, which type will not do:
class Spam(int): pass
x = Spam(0)
type(x) == int # False
isinstance(x, int) # True

This adheres to Python's strong polymorphism: you should allow any object that behaves like an int, instead of mandating that it be one.
BUT
The classical Python mentality, though, is that it's easier to ask forgiveness than permission. In other words, don't check whether x is an integer; assume that it is and catch the exception results if it isn't:
try:
    x += 1
except TypeError:
    ...

This mentality is slowly being overtaken by the use of abstract base classes, which let you register exactly what properties your object should have (adding? multiplying? doubling?) by making it inherit from a specially-constructed class. That would be the best solution, since it will permit exactly those objects with the necessary and sufficient attributes, but you will have to read the docs on how to use it.
"
How to download a file over HTTP?,https://stackoverflow.com/questions/22676/how-to-download-a-file-over-http,1178,python;http;urllib,"Use urllib.request.urlopen():
import urllib.request
with urllib.request.urlopen('http://www.example.com/') as f:
    html = f.read().decode('utf-8')

This is the most basic way to use the library, minus any error handling. You can also do more complex stuff such as changing headers.
On Python 2, the method is in urllib2:
import urllib2
response = urllib2.urlopen('http://www.example.com/')
html = response.read()

"
Parsing boolean values with argparse,https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse,1168,python;boolean;argparse;command-line-arguments,"Simplest & most correct way is:
from distutils.util import strtobool

parser.add_argument('--feature', dest='feature', 
                    type=lambda x: bool(strtobool(x)))

Do note that True values are y, yes, t, true, on and 1;
false values are n, no, f, false, off and 0. Raises ValueError if val is anything else.
"
How can I parse XML and get instances of a particular node attribute?,https://stackoverflow.com/questions/1912434/how-can-i-parse-xml-and-get-instances-of-a-particular-node-attribute,1167,python;xml,"I suggest ElementTree.  There are other compatible implementations of the same API, such as lxml, and cElementTree in the Python standard library itself; but, in this context, what they chiefly add is even more speed -- the ease of programming part depends on the API, which ElementTree defines.
First build an Element instance root from the XML, e.g. with the XML function, or by parsing a file with something like:
import xml.etree.ElementTree as ET
root = ET.parse('thefile.xml').getroot()

Or any of the many other ways shown at ElementTree. Then do something like:
for type_tag in root.findall('bar/type'):
    value = type_tag.get('foobar')
    print(value)

Output:
1
2

"
Why dict.get(key) instead of dict[key]?,https://stackoverflow.com/questions/11041405/why-dict-getkey-instead-of-dictkey,1165,python;dictionary;lookup,"It allows you to provide a default value if the key is missing:
dictionary.get(""bogus"", default_value)

returns default_value (whatever you choose it to be), whereas
dictionary[""bogus""]

would raise a KeyError.  
If omitted, default_value is None, such that
dictionary.get(""bogus"")  # <-- No default specified -- defaults to None

returns None just like 
dictionary.get(""bogus"", None)

would. 
"
List comprehension vs. lambda + filter,https://stackoverflow.com/questions/3013449/list-comprehension-vs-lambda-filter,1164,python;list;functional-programming;filter;lambda,"It is strange how much beauty varies for different people. I find the list comprehension much clearer than filter+lambda, but use whichever you find easier.
There are two things that may slow down your use of filter.
The first is the function call overhead: as soon as you use a Python function (whether created by def or lambda) it is likely that filter will be slower than the list comprehension. It almost certainly is not enough to matter, and you shouldn't think much about performance until you've timed your code and found it to be a bottleneck, but the difference will be there.
The other overhead that might apply is that the lambda is being forced to access a scoped variable (value). That is slower than accessing a local variable and in Python 2.x the list comprehension only accesses local variables. If you are using Python 3.x the list comprehension runs in a separate function so it will also be accessing value through a closure and this difference won't apply.
The other option to consider is to use a generator instead of a list comprehension:
def filterbyvalue(seq, value):
   for el in seq:
       if el.attribute==value: yield el

Then in your main code (which is where readability really matters) you've replaced both list comprehension and filter with a hopefully meaningful function name.
"
What&#39;s the difference between lists and tuples?,https://stackoverflow.com/questions/626759/whats-the-difference-between-lists-and-tuples,1161,python;list;tuples,"Apart from tuples being immutable there is also a semantic distinction that should guide their usage. Tuples are heterogeneous data structures (i.e., their entries have different meanings), while lists are homogeneous sequences. Tuples have structure, lists have order.
Using this distinction makes code more explicit and understandable.
One example would be pairs of page and line number to reference locations in a book, e.g.:
my_location = (42, 11)  # page number, line number

You can then use this as a key in a dictionary to store notes on locations. A list on the other hand could be used to store multiple locations. Naturally one might want to add or remove locations from the list, so it makes sense that lists are mutable. On the other hand it doesn't make sense to add or remove items from an existing location - hence tuples are immutable.
There might be situations where you want to change items within an existing location tuple, for example when iterating through the lines of a page. But tuple immutability forces you to create a new location tuple for each new value. This seems inconvenient on the face of it, but using immutable data like this is a cornerstone of value types and functional programming techniques, which can have substantial advantages.
There are some interesting articles on this issue, e.g. ""Python Tuples are Not Just Constant Lists"" or ""Understanding tuples vs. lists in Python"". The official Python documentation also mentions this

""Tuples are immutable, and usually contain an heterogeneous sequence ..."".

In a statically typed language like Haskell the values in a tuple generally have different types and the length of the tuple must be fixed. In a list the values all have the same type and the length is not fixed. So the difference is very obvious.
Finally there is the namedtuple in Python, which makes sense because a tuple is already supposed to have structure. This underlines the idea that tuples are a light-weight alternative to classes and instances.
"
Writing a pandas DataFrame to CSV file,https://stackoverflow.com/questions/16923281/writing-a-pandas-dataframe-to-csv-file,1160,python;pandas;dataframe;csv;file-io,"To delimit by a tab you can use the sep argument of to_csv:
df.to_csv(file_name, sep='\t')

To use a specific encoding (e.g. 'utf-8') use the encoding argument:
df.to_csv(file_name, sep='\t', encoding='utf-8')

In many cases you will want to remove the index and add a header:
df.to_csv(file_name, sep='\t', encoding='utf-8', index=False, header=True)

"
Importing modules from parent folder,https://stackoverflow.com/questions/714063/importing-modules-from-parent-folder,1155,python;module;path;directory;python-import,"It seems that the problem is not related to the module being in a parent directory or anything like that.
You need to add the directory that contains ptdraft to PYTHONPATH
You said that import nib worked with you, that probably means that you added ptdraft itself (not its parent) to PYTHONPATH.
"
How can I parse a YAML file in Python,https://stackoverflow.com/questions/1773805/how-can-i-parse-a-yaml-file-in-python,1154,python;yaml,"The easiest and purest method without relying on C headers is PyYaml (documentation), which can be installed via pip install pyyaml:
import yaml

with open(""example.yaml"") as stream:
    try:
        print(yaml.safe_load(stream))
    except yaml.YAMLError as exc:
        print(exc)

And that's it. A plain yaml.load() function also exists, but yaml.safe_load() should always be preferred to avoid introducing the possibility for arbitrary code execution. So unless you explicitly need the arbitrary object serialization/deserialization use safe_load.
Note the PyYaml project supports versions up through the YAML 1.1 specification. If YAML 1.2 specification support is needed, see ruamel.yaml as noted in this answer.
Also, you could also use a drop in replacement for pyyaml, that keeps your yaml file ordered the same way you had it, called oyaml. View synk of oyaml here
"
How to retrieve a module&#39;s path?,https://stackoverflow.com/questions/247770/how-to-retrieve-a-modules-path,1153,python;module;inotify,"import a_module
print(a_module.__file__)

Will actually give you the path to the .pyc file that was loaded, at least on Mac OS X. So I guess you can do:
import os
path = os.path.abspath(a_module.__file__)

You can also try:
path = os.path.dirname(a_module.__file__)

To get the module's directory.
"
How can I make a Python script standalone executable to run without any dependency?,https://stackoverflow.com/questions/5458048/how-can-i-make-a-python-script-standalone-executable-to-run-without-any-dependen,1146,python;executable,"You can use py2exe as already answered and use Cython to convert your key .py files in .pyc, C compiled files, like .dll in Windows and .so on Linux.
It is much harder to revert than common .pyo and .pyc files (and also gain in performance!).
"
UnicodeDecodeError: &#39;charmap&#39; codec can&#39;t decode byte X in position Y: character maps to &lt;undefined&gt;,https://stackoverflow.com/questions/9233027/unicodedecodeerror-charmap-codec-cant-decode-byte-x-in-position-y-character,1144,python;python-3.x;unicode;file-io;decode,"The file in question is not using the CP1252 encoding. It's using another encoding. Which one you have to figure out yourself. Common ones are Latin-1 and UTF-8. Since 0x90 doesn't actually mean anything in Latin-1, UTF-8 (where 0x90 is a continuation byte) is more likely.
You specify the encoding when you open the file:
file = open(filename, encoding=""utf8"")

"
How do I unload (reload) a Python module?,https://stackoverflow.com/questions/437589/how-do-i-unload-reload-a-python-module,1142,python;module;reload;python-import,"You can reload a module when it has already been imported by using importlib.reload():
from importlib import reload  # Python 3.4+
import foo

while True:
    # Do some things.
    if is_changed(foo):
        foo = reload(foo)

In Python 2, reload was a builtin. In Python 3, it was moved to the imp module. In 3.4, imp was deprecated in favor of importlib. When targeting 3 or later, either reference the appropriate module when calling reload or import it.
I think that this is what you want. Web servers like Django's development server use this so that you can see the effects of your code changes without restarting the server process itself.
To quote from the docs:


Python module’s code is recompiled and the module-level code re-executed, defining a new set of objects which are bound to names in the module’s dictionary by reusing the loader which originally loaded the module. The init function of extension modules is not called a second time.
As with all other objects in Python the old objects are only reclaimed after their reference counts drop to zero.
The names in the module namespace are updated to point to any new or changed objects.
Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired.


As you noted in your question, you'll have to reconstruct Foo objects if the Foo class resides in the foo module.
"
How can I represent an &#39;Enum&#39; in Python?,https://stackoverflow.com/questions/36932/how-can-i-represent-an-enum-in-python,1140,python;python-3.x;enums,"Enums have been added to Python 3.4 as described in PEP 435.  It has also been backported to 3.3, 3.2, 3.1, 2.7, 2.6, 2.5, and 2.4 on pypi.
For more advanced Enum techniques try the aenum library (2.7, 3.3+, same author as enum34. Code is not perfectly compatible between py2 and py3, e.g. you'll need __order__ in python 2).

To use enum34, do $ pip install enum34
To use aenum, do $ pip install aenum

Installing enum (no numbers) will install a completely different and incompatible version.

from enum import Enum     # for enum34, or the stdlib version
# from aenum import Enum  # for the aenum version
Animal = Enum('Animal', 'ant bee cat dog')

Animal.ant  # returns <Animal.ant: 1>
Animal['ant']  # returns <Animal.ant: 1> (string lookup)
Animal.ant.name  # returns 'ant' (inverse lookup)

or equivalently:
class Animal(Enum):
    ant = 1
    bee = 2
    cat = 3
    dog = 4


In earlier versions, one way of accomplishing enums is:
def enum(**enums):
    return type('Enum', (), enums)

which is used like so:
>>> Numbers = enum(ONE=1, TWO=2, THREE='three')
>>> Numbers.ONE
1
>>> Numbers.TWO
2
>>> Numbers.THREE
'three'

You can also easily support automatic enumeration with something like this:
def enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type('Enum', (), enums)

and used like so:
>>> Numbers = enum('ZERO', 'ONE', 'TWO')
>>> Numbers.ZERO
0
>>> Numbers.ONE
1

Support for converting the values back to names can be added this way:
def enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    reverse = dict((value, key) for key, value in enums.iteritems())
    enums['reverse_mapping'] = reverse
    return type('Enum', (), enums)

This overwrites anything with that name, but it is useful for rendering your enums in output. It will throw a KeyError if the reverse mapping doesn't exist. With the first example:
>>> Numbers.reverse_mapping['three']
'THREE'


If you are using MyPy another way to express ""enums"" is with typing.Literal.
For example:
from typing import Literal #python >=3.8
from typing_extensions import Literal #python 2.7, 3.4-3.7


Animal = Literal['ant', 'bee', 'cat', 'dog']

def hello_animal(animal: Animal):
    print(f""hello {animal}"")

hello_animal('rock') # error
hello_animal('bee') # passes


"
How do I remove/delete/replace a folder that is not empty?,https://stackoverflow.com/questions/303200/how-do-i-remove-delete-replace-a-folder-that-is-not-empty,1139,python;file,"import shutil

shutil.rmtree('/folder_name')

Standard Library Reference: shutil.rmtree.
By design, rmtree fails on folder trees containing read-only files. If you want the folder to be deleted regardless of whether it contains read-only files, then use
shutil.rmtree('/folder_name', ignore_errors=True)

"
How do I check the versions of Python modules?,https://stackoverflow.com/questions/20180543/how-do-i-check-the-versions-of-python-modules,1138,python,"Use pip instead of easy_install.
With pip, list all installed packages and their versions via:
pip freeze

On most Linux systems, you can pipe this to grep (or findstr on Windows) to find the row for the particular package you're interested in.

Linux:
pip freeze | grep lxml


lxml==2.3

Windows:
pip freeze | findstr lxml


lxml==2.3


For an individual module, you can try the __version__ attribute. However, there are modules without it:
python -c ""import requests; print(requests.__version__)""
2.14.2

python -c ""import lxml; print(lxml.__version__)""


Traceback (most recent call last): 
File ""<string>"", line 1, in <module> 
AttributeError: 'module' object has no attribute '__version__'

Lastly, as the commands in your question are prefixed with sudo, it appears you're installing to the global python environment. I strongly advise to take look into Python virtual environment managers, for example virtualenvwrapper.
"
What are the most common Python docstring formats?,https://stackoverflow.com/questions/3898572/what-are-the-most-common-python-docstring-formats,1135,python;coding-style;documentation;docstring,"Formats
Python docstrings can be written following several formats as the other posts showed. However the default Sphinx docstring format was not mentioned and is based on reStructuredText (reST). You can get some information about the main formats in this blog post.
Note that the reST is recommended by the PEP 287
There follows the main used formats for docstrings.
- Epytext
Historically a javadoc like style was prevalent, so it was taken as a base for Epydoc (with the called Epytext format) to generate documentation.
Example:
""""""
This is a javadoc style.

@param param1: this is a first param
@param param2: this is a second param
@return: this is a description of what is returned
@raise keyError: raises an exception
""""""

- reST
Nowadays, the probably more prevalent format is the reStructuredText (reST) format that is used by Sphinx to generate documentation.
Note: it is used by default in JetBrains PyCharm (type triple quotes after defining a method and hit enter). It is also used by default as output format in Pyment.
Example:
""""""
This is a reST style.

:param param1: this is a first param
:param param2: this is a second param
:returns: this is a description of what is returned
:raises keyError: raises an exception
""""""

- Google
Google has their own format that is often used. It also can be interpreted by Sphinx (ie. using Napoleon plugin). 
Example:
""""""
This is an example of Google style.

Args:
    param1: This is the first param.
    param2: This is a second param.

Returns:
    This is a description of what is returned.

Raises:
    KeyError: Raises an exception.
""""""

Even more examples
- Numpydoc
Note that Numpy recommend to follow their own numpydoc based on Google format and usable by Sphinx.
""""""
My numpydoc description of a kind
of very exhautive numpydoc format docstring.

Parameters
----------
first : array_like
    the 1st param name `first`
second :
    the 2nd param
third : {'value', 'other'}, optional
    the 3rd param, by default 'value'

Returns
-------
string
    a value in a string

Raises
------
KeyError
    when a key error
OtherError
    when an other error
""""""

Converting/Generating
It is possible to use a tool like Pyment to automatically generate docstrings to a Python project not yet documented, or to convert existing docstrings (can be mixing several formats) from a format to an other one.
Note: The examples are taken from the Pyment documentation
"
Should I use &#39;has_key()&#39; or &#39;in&#39; on Python dicts?,https://stackoverflow.com/questions/1323410/should-i-use-has-key-or-in-on-python-dicts,1133,python;dictionary,"in is definitely more pythonic.
In fact has_key() was removed in Python 3.x.
"
What is the difference between pip and Conda?,https://stackoverflow.com/questions/20994716/what-is-the-difference-between-pip-and-conda,1133,python;pip;ipython;package-managers;conda,"Quoting from the Conda blog:

Having been involved in the python world for so long, we are all aware of pip, easy_install, and virtualenv, but these tools did not meet all of our specific requirements. The main problem is that they are focused around Python, neglecting non-Python library dependencies, such as HDF5, MKL, LLVM, etc., which do not have a setup.py in their source code and also do not install files into Python’s site-packages directory.

So Conda is a packaging tool and installer that aims to do more than what pip does; handle library dependencies outside of the Python packages as well as the Python packages themselves. Conda also creates a virtual environment, like virtualenv does.
As such, Conda should be compared to Buildout perhaps, another tool that lets you handle both Python and non-Python installation tasks.
Because Conda introduces a new packaging format, you cannot use pip and Conda interchangeably;  pip cannot install the Conda package format. You can use the two tools side by side (by installing pip with conda install pip) but they do not interoperate either.
Since writing this answer, Anaconda has published a new page on Understanding Conda and Pip, which echoes this as well:

This highlights a key difference between conda and pip. Pip installs Python packages whereas conda installs packages which may contain software written in any language. For example, before using pip, a Python interpreter must be installed via a system package manager or by downloading and running an installer. Conda on the other hand can install Python packages as well as the Python interpreter directly.

and further on

Occasionally a package is needed which is not available as a conda package but is available on PyPI and can be installed with pip. In these cases, it makes sense to try to use both conda and pip.

"
What is the difference between old style and new style classes in Python?,https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python,1132,python;class;oop;types;new-style-class,"From New-style and classic classes:

Up to Python 2.1, old-style classes were the only flavour available to the user.
The concept of (old-style) class is unrelated to the concept of type:
  if x is an instance of an old-style class, then x.__class__
  designates the class of x, but type(x) is always <type
  'instance'>. 
This reflects the fact that all old-style instances, independently of
  their class, are implemented with a single built-in type, called
  instance.
New-style classes were introduced in Python 2.2 to unify the concepts of class and type. 
  A new-style class is simply a user-defined type, no more, no less.
If x is an instance of a new-style class, then type(x) is typically
  the same as x.__class__ (although this is not guaranteed – a
  new-style class instance is permitted to override the value returned
  for x.__class__).
The major motivation for introducing new-style classes is to provide a unified object model with a full meta-model. 
It also has a number of immediate benefits, like the ability to
  subclass most built-in types, or the introduction of ""descriptors"",
  which enable computed properties.
For compatibility reasons, classes are still old-style by default. 
New-style classes are created by specifying another new-style class
  (i.e. a type) as a parent class, or the ""top-level type"" object if no
  other parent is needed. 
The behaviour of new-style classes differs from that of old-style
  classes in a number of important details in addition to what type
  returns. 
Some of these changes are fundamental to the new object model, like
  the way special methods are invoked. Others are ""fixes"" that could not
  be implemented before for compatibility concerns, like the method
  resolution order in case of multiple inheritance.
Python 3 only has new-style classes. 
No matter if you subclass from object or not, classes are new-style
  in Python 3.

"
What is the naming convention in Python for variables and functions?,https://stackoverflow.com/questions/159720/what-is-the-naming-convention-in-python-for-variables-and-functions,1127,python;naming-conventions;camelcasing;pascalcasing;snakecasing,"See Python PEP 8: Function and Variable Names:

Function names should be lowercase, with words separated by underscores as necessary to improve readability.
Variable names follow the same convention as function names.
mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility.

"
How to POST JSON data with Python Requests?,https://stackoverflow.com/questions/9733638/how-to-post-json-data-with-python-requests,1121,python;json;python-requests;cherrypy,"Starting with Requests version 2.4.2, you can use the json= parameter (which takes a dictionary) instead of data= (which takes a string) in the call:
>>> import requests
>>> r = requests.post('http://httpbin.org/post', json={""key"": ""value""})
>>> r.status_code
200
>>> r.json()
{'args': {},
 'data': '{""key"": ""value""}',
 'files': {},
 'form': {},
 'headers': {'Accept': '*/*',
             'Accept-Encoding': 'gzip, deflate',
             'Connection': 'close',
             'Content-Length': '16',
             'Content-Type': 'application/json',
             'Host': 'httpbin.org',
             'User-Agent': 'python-requests/2.4.3 CPython/3.4.0',
             'X-Request-Id': 'xx-xx-xx'},
 'json': {'key': 'value'},
 'origin': 'x.x.x.x',
 'url': 'http://httpbin.org/post'}

"
How to emulate a do-while loop?,https://stackoverflow.com/questions/743164/how-to-emulate-a-do-while-loop,1121,python;while-loop;do-while,"I am not sure what you are trying to do. You can implement a do-while loop like this:
while True:
  stuff()
  if fail_condition:
    break

Or:
stuff()
while not fail_condition:
  stuff()

What are you doing trying to use a do while loop to print the stuff in the list? Why not just use:
for i in l:
  print i
print ""done""

Update:
So do you have a list of lines? And you want to keep iterating through it? How about: 
for s in l: 
  while True: 
    stuff() 
    # use a ""break"" instead of s = i.next()

Does that seem like something close to what you would want? With your code example, it would be:
for s in some_list:
  while True:
    if state is STATE_CODE:
      if ""//"" in s:
        tokens.add( TOKEN_COMMENT, s.split( ""//"" )[1] )
        state = STATE_COMMENT
      else :
        tokens.add( TOKEN_CODE, s )
    if state is STATE_COMMENT:
      if ""//"" in s:
        tokens.append( TOKEN_COMMENT, s.split( ""//"" )[1] )
        break # get next s
      else:
        state = STATE_CODE
        # re-evaluate same line
        # continues automatically

"
How to get a function name as a string?,https://stackoverflow.com/questions/251464/how-to-get-a-function-name-as-a-string,1118,python;string;function,"my_function.__name__

Using __name__ is the preferred method as it applies uniformly. Unlike func_name, it works on built-in functions as well:
>>> import time
>>> time.time.func_name
Traceback (most recent call last):
  File ""<stdin>"", line 1, in ?
AttributeError: 'builtin_function_or_method' object has no attribute 'func_name'
>>> time.time.__name__ 
'time'

Also the double underscores indicate to the reader this is a special attribute. As a bonus, classes and modules have a __name__ attribute too, so you only have remember one special name.
"
Traverse a list in reverse order in Python,https://stackoverflow.com/questions/529424/traverse-a-list-in-reverse-order-in-python,1113,python;loops;reverse,"Use the built-in reversed() function:
>>> a = [""foo"", ""bar"", ""baz""]
>>> for i in reversed(a):
...     print(i)
... 
baz
bar
foo

To also access the original index, use enumerate() on your list before passing it to reversed():
>>> for i, e in reversed(list(enumerate(a))):
...     print(i, e)
... 
2 baz
1 bar
0 foo

Since enumerate() returns a generator and generators can't be reversed, you need to convert it to a list first.
"
What is Python&#39;s equivalent of &amp;&amp; (logical-and) in an if-statement?,https://stackoverflow.com/questions/2485466/what-is-pythons-equivalent-of-logical-and-in-an-if-statement,1113,python;logical-and,"Use and instead of &&.
"
Reverse / invert a dictionary mapping,https://stackoverflow.com/questions/483666/reverse-invert-a-dictionary-mapping,1092,python;dictionary;mapping;reverse,"Python 3+:
inv_map = {v: k for k, v in my_map.items()}

Python 2:
inv_map = {v: k for k, v in my_map.iteritems()}

"
How do I remove the first item from a list?,https://stackoverflow.com/questions/4426663/how-do-i-remove-the-first-item-from-a-list,1088,python;list,"You can find a short collection of useful list functions here.
list.pop(index)
>>> l = ['a', 'b', 'c', 'd']
>>> l.pop(0)
'a'
>>> l
['b', 'c', 'd']
>>> 

del list[index]
>>> l = ['a', 'b', 'c', 'd']
>>> del l[0]
>>> l
['b', 'c', 'd']
>>> 

These both modify your original list.
Others have suggested using slicing:

Copies the list
Can return a subset

Also, if you are performing many pop(0), you should look at collections.deque
from collections import deque
>>> l = deque(['a', 'b', 'c', 'd'])
>>> l.popleft()
'a'
>>> l
deque(['b', 'c', 'd'])


Provides higher performance popping from left end of the list

"
"How do I remove duplicates from a list, while preserving order?",https://stackoverflow.com/questions/480214/how-do-i-remove-duplicates-from-a-list-while-preserving-order,1080,python;list;duplicates;list-comprehension;unique,"Here you have some alternatives: http://www.peterbe.com/plog/uniqifiers-benchmark
Fastest one:
def f7(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]

Why assign seen.add to seen_add instead of just calling seen.add? Python is a dynamic language, and resolving seen.add each iteration is more costly than resolving a local variable. seen.add could have changed between iterations, and the runtime isn't smart enough to rule that out. To play it safe, it has to check the object each time.
If you plan on using this function a lot on the same dataset, perhaps you would be better off with an ordered set: http://code.activestate.com/recipes/528878/
O(1) insertion, deletion and member-check per operation.
(Small additional note: seen.add() always returns None, so the or above is there only as a way to attempt a set update, and not as an integral part of the logical test.)
"
Behaviour of increment and decrement operators in Python,https://stackoverflow.com/questions/1485841/behaviour-of-increment-and-decrement-operators-in-python,1079,python;operators;increment;decrement,"++ is not an operator. It is two + operators. The + operator is the identity operator, which does nothing. (Clarification: the + and - unary operators only work on numbers, but I presume that you wouldn't expect a hypothetical ++ operator to work on strings.)
++count

Parses as
+(+count)

Which translates to
count

You have to use the slightly longer += operator to do what you want to do:
count += 1

I suspect the ++ and -- operators were left out for consistency and simplicity. I don't know the exact argument Guido van Rossum gave for the decision, but I can imagine a few arguments:

Simpler parsing. Technically, parsing ++count is ambiguous, as it could be +, +, count (two unary + operators) just as easily as it could be ++, count (one unary ++ operator). It's not a significant syntactic ambiguity, but it does exist.
Simpler language. ++ is nothing more than a synonym for += 1. It was a shorthand invented because C compilers were stupid and didn't know how to optimize a += 1 into the inc instruction most computers have. In this day of optimizing compilers and bytecode interpreted languages, adding operators to a language to allow programmers to optimize their code is usually frowned upon, especially in a language like Python that is designed to be consistent and readable.
Confusing side-effects. One common newbie error in languages with ++ operators is mixing up the differences (both in precedence and in return value) between the pre- and post-increment/decrement operators, and Python likes to eliminate language ""gotcha""-s. The precedence issues of pre-/post-increment in C are pretty hairy, and incredibly easy to mess up.

"
How to get an absolute file path in Python,https://stackoverflow.com/questions/51520/how-to-get-an-absolute-file-path-in-python,1075,python;path;relative-path;absolute-path,">>> import os
>>> os.path.abspath(""mydir/myfile.txt"")
'C:/example/cwd/mydir/myfile.txt'

Also works if it is already an absolute path:
>>> import os
>>> os.path.abspath(""C:/example/cwd/mydir/myfile.txt"")
'C:/example/cwd/mydir/myfile.txt'

"
"What are the differences between the urllib, urllib2, urllib3 and requests module?",https://stackoverflow.com/questions/2018026/what-are-the-differences-between-the-urllib-urllib2-urllib3-and-requests-modul,1071,python;python-requests;urllib;urllib2;urllib3,"I know it's been said already, but I'd highly recommend the requests Python package.
If you've used languages other than python, you're probably thinking urllib and urllib2 are easy to use, not much code, and highly capable, that's how I used to think.  But the requests package is so unbelievably useful and short that everyone should be using it.
First, it supports a fully restful API, and is as easy as:
import requests

resp = requests.get('http://www.mywebsite.com/user')
resp = requests.post('http://www.mywebsite.com/user')
resp = requests.put('http://www.mywebsite.com/user/put')
resp = requests.delete('http://www.mywebsite.com/user/delete')

Regardless of whether GET / POST, you never have to encode parameters again, it simply takes a dictionary as an argument and is good to go:
userdata = {""firstname"": ""John"", ""lastname"": ""Doe"", ""password"": ""jdoe123""}
resp = requests.post('http://www.mywebsite.com/user', data=userdata)

Plus it even has a built in JSON decoder (again, I know json.loads() isn't a lot more to write, but this sure is convenient):
resp.json()

Or if your response data is just text, use:
resp.text

This is just the tip of the iceberg. This is the list of features from the requests site:

International Domains and URLs
Keep-Alive & Connection Pooling
Sessions with Cookie Persistence
Browser-style SSL Verification
Basic/Digest Authentication
Elegant Key/Value Cookies
Automatic Decompression
Unicode Response Bodies
Multipart File Uploads
Connection Timeouts
.netrc support
List item
Python 2.7, 3.6—3.9
Thread-safe.

"
Deleting DataFrame row in Pandas based on column value,https://stackoverflow.com/questions/18172851/deleting-dataframe-row-in-pandas-based-on-column-value,1059,python;pandas;dataframe;performance;delete-row,"If I'm understanding correctly, it should be as simple as:
df = df[df.line_race != 0]

"
Multiprocessing vs Threading Python,https://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python,1055,python;multithreading;multiprocessing,"The threading module uses threads, the multiprocessing module uses processes. The difference is that threads run in the same memory space, while processes have separate memory. This makes it a bit harder to share objects between processes with multiprocessing. Since threads use the same memory, precautions have to be taken or two threads will write to the same memory at the same time. This is what the global interpreter lock is for.
Spawning processes is a bit slower than spawning threads.
"
Getting today&#39;s date in YYYY-MM-DD in Python?,https://stackoverflow.com/questions/32490629/getting-todays-date-in-yyyy-mm-dd-in-python,1053,python;date;datetime;formatting;python-datetime,"Use strftime:
>>> from datetime import datetime
>>> datetime.today().strftime('%Y-%m-%d')
'2021-01-26'

To also include a zero-padded Hour:Minute:Second at the end:
>>> datetime.today().strftime('%Y-%m-%d %H:%M:%S')
'2021-01-26 16:50:03'

To get the UTC date and time:
>>> datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
'2021-01-27 00:50:03'

"
mkdir -p functionality in Python,https://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python,1052,python;path;directory-structure;mkdir,"For Python ≥ 3.5, use pathlib.Path.mkdir:
import pathlib
pathlib.Path(""/tmp/path/to/desired/directory"").mkdir(parents=True, exist_ok=True)

The exist_ok parameter was added in Python 3.5.

For Python ≥ 3.2, os.makedirs has an optional third argument exist_ok that, when True, enables the mkdir -p functionality—unless mode is provided and the existing directory has different permissions than the intended ones; in that case, OSError is raised as previously:
import os
os.makedirs(""/tmp/path/to/desired/directory"", exist_ok=True)


For even older versions of Python, you can use os.makedirs and ignore the error:
import errno    
import os

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python ≥ 2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        # possibly handle other errno cases here, otherwise finally:
        else:
            raise

"
How to use to find files recursively?,https://stackoverflow.com/questions/2186525/how-to-use-to-find-files-recursively,1051,python;path;filesystems;glob;fnmatch,"There are a couple of ways:
pathlib.Path().rglob()
Use pathlib.Path().rglob() from the pathlib module, which was introduced in Python 3.5.
from pathlib import Path

for path in Path('src').rglob('*.c'):
    print(path.name)

glob.glob()
If you don't want to use pathlib, use glob.glob():
from glob import glob

for filename in glob('src/**/*.c', recursive=True):
    print(filename)   

For cases where matching files beginning with a dot (.); like files in the current directory or hidden files on Unix based system, use the os.walk() solution below.
os.walk()
For older Python versions, use os.walk() to recursively walk a directory and fnmatch.filter() to match against a simple expression:
import fnmatch
import os

matches = []
for root, dirnames, filenames in os.walk('src'):
    for filename in fnmatch.filter(filenames, '*.c'):
        matches.append(os.path.join(root, filename))

This version should also be faster depending on how many files you have, as the pathlib module has a bit of overhead over os.walk().
"
How do I convert a datetime to date?,https://stackoverflow.com/questions/3743222/how-do-i-convert-a-datetime-to-date,1051,python;datetime,"Use the date() method:
datetime.datetime.now().date()

"
What does functools.wraps do?,https://stackoverflow.com/questions/308999/what-does-functools-wraps-do,1046,python;decorator;functools,"When you use a decorator, you're replacing one function with another.  In other words, if you have a decorator
def logged(func):
    def with_logging(*args, **kwargs):
        print(func.__name__ + "" was called"")
        return func(*args, **kwargs)
    return with_logging

then when you say
@logged
def f(x):
   """"""does some math""""""
   return x + x * x

it's exactly the same as saying
def f(x):
    """"""does some math""""""
    return x + x * x
f = logged(f)

and your function f is replaced with the function with_logging.  Unfortunately, this means that if you then say
print(f.__name__)

it will print with_logging because that's the name of your new function.  In fact, if you look at the docstring for f, it will be blank because with_logging has no docstring, and so the docstring you wrote won't be there anymore.  Also, if you look at the pydoc result for that function, it won't be listed as taking one argument x; instead it'll be listed as taking *args and **kwargs because that's what with_logging takes.
If using a decorator always meant losing this information about a function, it would be a serious problem.  That's why we have functools.wraps.  This takes a function used in a decorator and adds the functionality of copying over the function name, docstring, arguments list, etc.  And since wraps is itself a decorator, the following code does the correct thing:
from functools import wraps
def logged(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + "" was called"")
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
    """"""does some math""""""
    return x + x * x

print(f.__name__)  # prints 'f'
print(f.__doc__)   # prints 'does some math'

"
How do I expand the output display to see more columns of a Pandas DataFrame?,https://stackoverflow.com/questions/11707586/how-do-i-expand-the-output-display-to-see-more-columns-of-a-pandas-dataframe,1043,python;pandas;printing;column-width,"(For Pandas versions before 0.23.4, see at bottom.)
Use pandas.set_option(optname, val), or equivalently pd.options.<opt.hierarchical.name> = val. Like:
import pandas as pd

pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)

Pandas will try to autodetect the size of your terminal window if you set pd.options.display.width = 0.
Here is the help for set_option:

set_option(pat,value) - Sets the value of the specified option

Available options:
display.[chop_threshold, colheader_justify, column_space, date_dayfirst,
         date_yearfirst, encoding, expand_frame_repr, float_format, height,
         line_width, max_columns, max_colwidth, max_info_columns, max_info_rows,
         max_rows, max_seq_items, mpl_style, multi_sparse, notebook_repr_html,
         pprint_nest_depth, precision, width]
mode.[sim_interactive, use_inf_as_null]

Parameters
----------
pat - str/regexp which should match a single option.

Note: partial matches are supported for convenience, but unless you use the
full option name (e.g., *x.y.z.option_name*), your code may break in future
versions if new options with similar names are introduced.

value - new value of option.

Returns
-------
None

Raises
------
KeyError if no such option exists

display.chop_threshold: [default: None] [currently: None]
: float or None
        if set to a float value, all float values smaller then the given threshold
        will be displayed as exactly 0 by repr and friends.
display.colheader_justify: [default: right] [currently: right]
: 'left'/'right'
        Controls the justification of column headers. used by DataFrameFormatter.
display.column_space: [default: 12] [currently: 12]No description available.

display.date_dayfirst: [default: False] [currently: False]
: boolean
        When True, prints and parses dates with the day first, eg 20/01/2005
display.date_yearfirst: [default: False] [currently: False]
: boolean
        When True, prints and parses dates with the year first, e.g., 2005/01/20
display.encoding: [default: UTF-8] [currently: UTF-8]
: str/unicode
        Defaults to the detected encoding of the console.
        Specifies the encoding to be used for strings returned by to_string,
        these are generally strings meant to be displayed on the console.
display.expand_frame_repr: [default: True] [currently: True]
: boolean
        Whether to print out the full DataFrame repr for wide DataFrames
        across multiple lines, `max_columns` is still respected, but the output will
        wrap-around across multiple ""pages"" if it's width exceeds `display.width`.
display.float_format: [default: None] [currently: None]
: callable
        The callable should accept a floating point number and return
        a string with the desired format of the number. This is used
        in some places like SeriesFormatter.
        See core.format.EngFormatter for an example.
display.height: [default: 60] [currently: 1000]
: int
        Deprecated.
        (Deprecated, use `display.height` instead.)

display.line_width: [default: 80] [currently: 1000]
: int
        Deprecated.
        (Deprecated, use `display.width` instead.)

display.max_columns: [default: 20] [currently: 500]
: int
        max_rows and max_columns are used in __repr__() methods to decide if
        to_string() or info() is used to render an object to a string.  In case
        python/IPython is running in a terminal this can be set to 0 and Pandas
        will correctly auto-detect the width the terminal and swap to a smaller
        format in case all columns would not fit vertically. The IPython notebook,
        IPython qtconsole, or IDLE do not run in a terminal and hence it is not
        possible to do correct auto-detection.
        'None' value means unlimited.
display.max_colwidth: [default: 50] [currently: 50]
: int
        The maximum width in characters of a column in the repr of
        a Pandas data structure. When the column overflows, a ""...""
        placeholder is embedded in the output.
display.max_info_columns: [default: 100] [currently: 100]
: int
        max_info_columns is used in DataFrame.info method to decide if
        per column information will be printed.
display.max_info_rows: [default: 1690785] [currently: 1690785]
: int or None
        max_info_rows is the maximum number of rows for which a frame will
        perform a null check on its columns when repr'ing To a console.
        The default is 1,000,000 rows. So, if a DataFrame has more
        1,000,000 rows there will be no null check performed on the
        columns and thus the representation will take much less time to
        display in an interactive session. A value of None means always
        perform a null check when repr'ing.
display.max_rows: [default: 60] [currently: 500]
: int
        This sets the maximum number of rows Pandas should output when printing
        out various output. For example, this value determines whether the repr()
        for a dataframe prints out fully or just a summary repr.
        'None' value means unlimited.
display.max_seq_items: [default: None] [currently: None]
: int or None

        when pretty-printing a long sequence, no more then `max_seq_items`
        will be printed. If items are ommitted, they will be denoted by the addition
        of ""..."" to the resulting string.

        If set to None, the number of items to be printed is unlimited.
display.mpl_style: [default: None] [currently: None]
: bool

        Setting this to 'default' will modify the rcParams used by matplotlib
        to give plots a more pleasing visual style by default.
        Setting this to None/False restores the values to their initial value.
display.multi_sparse: [default: True] [currently: True]
: boolean
        ""sparsify"" MultiIndex display (don't display repeated
        elements in outer levels within groups)
display.notebook_repr_html: [default: True] [currently: True]
: boolean
        When True, IPython notebook will use html representation for
        Pandas objects (if it is available).
display.pprint_nest_depth: [default: 3] [currently: 3]
: int
        Controls the number of nested levels to process when pretty-printing
display.precision: [default: 7] [currently: 7]
: int
        Floating point output precision (number of significant digits). This is
        only a suggestion
display.width: [default: 80] [currently: 1000]
: int
        Width of the display in characters. In case python/IPython is running in
        a terminal this can be set to None and Pandas will correctly auto-detect the
        width.
        Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a
        terminal and hence it is not possible to correctly detect the width.
mode.sim_interactive: [default: False] [currently: False]
: boolean
        Whether to simulate interactive mode for purposes of testing
mode.use_inf_as_null: [default: False] [currently: False]
: boolean
        True means treat None, NaN, INF, -INF as null (old way),
        False means None and NaN are null, but INF, -INF are not null
        (new way).
Call def:   pd.set_option(self, *args, **kwds)


Older version information
Much of this has been deprecated.
As @bmu mentioned, Pandas auto detects (by default) the size of the display area, a summary view will be used when an object repr does not fit on the display. You mentioned resizing the IDLE window, to no effect. If you do print df.describe().to_string() does it fit on the IDLE window?
The terminal size is determined by pandas.util.terminal.get_terminal_size() (deprecated and removed), this returns a tuple containing the (width, height) of the display. Does the output match the size of your IDLE window? There might be an issue (there was one before when running a terminal in Emacs).
Note that it is possible to bypass the autodetect, pandas.set_printoptions(max_rows=200, max_columns=10) will never switch to summary view if number of rows, columns does not exceed the given limits.

The max_colwidth option helps in seeing untruncated form of each column.

"
Python `if x is not None` or `if not x is None`?,https://stackoverflow.com/questions/2710940/python-if-x-is-not-none-or-if-not-x-is-none,1042,python;nonetype;boolean-expression;pep8,"There's no performance difference, as they compile to the same bytecode:
>>> import dis
>>> dis.dis(""not x is None"")
  1           0 LOAD_NAME                0 (x)
              2 LOAD_CONST               0 (None)
              4 COMPARE_OP               9 (is not)
              6 RETURN_VALUE
>>> dis.dis(""x is not None"")
  1           0 LOAD_NAME                0 (x)
              2 LOAD_CONST               0 (None)
              4 COMPARE_OP               9 (is not)
              6 RETURN_VALUE

Stylistically, I try to avoid not x is y, a human reader might misunderstand it as (not x) is y. If I write x is not y then there is no ambiguity.
"
Find all files in a directory with extension .txt in Python,https://stackoverflow.com/questions/3964681/find-all-files-in-a-directory-with-extension-txt-in-python,1041,python;file-io,"You can use glob:
import glob, os
os.chdir(""/mydir"")
for file in glob.glob(""*.txt""):
    print(file)

or simply os.listdir:
import os
for file in os.listdir(""/mydir""):
    if file.endswith("".txt""):
        print(os.path.join(""/mydir"", file))

or if you want to traverse directory, use os.walk:
import os
for root, dirs, files in os.walk(""/mydir""):
    for file in files:
        if file.endswith("".txt""):
             print(os.path.join(root, file))

"
Convert date to datetime in Python,https://stackoverflow.com/questions/1937622/convert-date-to-datetime-in-python,1041,python;datetime;date,"You can use datetime.combine(date, time); for the time, you create a datetime.time object initialized to midnight.
from datetime import date
from datetime import datetime

dt = datetime.combine(date.today(), datetime.min.time())

"
Python integer incrementing with ++,https://stackoverflow.com/questions/2632677/python-integer-incrementing-with,1032,python;syntax;increment,"Python doesn't support ++, but you can do:
number += 1

"
Running unittest with typical test directory structure,https://stackoverflow.com/questions/1896918/running-unittest-with-typical-test-directory-structure,1029,python;unit-testing,"The best solution in my opinion is to use the unittest command line interface which will add the directory to the sys.path so you don't have to (done in the TestLoader class).
For example for a directory structure like this:
new_project
├── antigravity.py
└── test_antigravity.py

You can just run:
$ cd new_project
$ python -m unittest test_antigravity

For a directory structure like yours:
new_project
├── antigravity
│   ├── __init__.py         # make it a package
│   └── antigravity.py
└── test
    ├── __init__.py         # also make test a package
    └── test_antigravity.py

And in the test modules inside the test package, you can import the antigravity package and its modules as usual:
# import the package
import antigravity

# import the antigravity module
from antigravity import antigravity

# or an object inside the antigravity module
from antigravity.antigravity import my_object

Running a single test module:
To run a single test module, in this case test_antigravity.py:
$ cd new_project
$ python -m unittest test.test_antigravity

Just reference the test module the same way you import it.
Running a single test case or test method:
Also you can run a single TestCase or a single test method:
$ python -m unittest test.test_antigravity.GravityTestCase
$ python -m unittest test.test_antigravity.GravityTestCase.test_method

Running all tests:
You can also use test discovery which will discover and run all the tests for you, they must be modules or packages named test*.py (can be changed with the -p, --pattern flag):
$ cd new_project
$ python -m unittest discover
$ # Also works without discover for Python 3
$ # as suggested by @Burrito in the comments
$ python -m unittest

This will run all the test*.py modules inside the test package.
Here you can find the updated official documentation of discovery.
"
How do you get the logical xor of two variables in Python?,https://stackoverflow.com/questions/432842/how-do-you-get-the-logical-xor-of-two-variables-in-python,1026,python;logical-operators,"If you're already normalizing the inputs to booleans, then != is xor.
bool(a) != bool(b)

"
How do I use a decimal step value for range()?,https://stackoverflow.com/questions/477486/how-do-i-use-a-decimal-step-value-for-range,1024,python;floating-point;range,"Rather than using a decimal step directly, it's much safer to express this in terms of how many points you want. Otherwise, floating-point rounding error is likely to give you a wrong result.
Use the linspace function from the NumPy library (which isn't part of the standard library but is relatively easy to obtain). linspace takes a number of points to return, and also lets you specify whether or not to include the right endpoint:
>>> np.linspace(0,1,11)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])
>>> np.linspace(0,1,10,endpoint=False)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])

If you really want to use a floating-point step value, use numpy.arange:
>>> import numpy as np
>>> np.arange(0.0, 1.0, 0.1)
array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])

Floating-point rounding error will cause problems, though. Here's a simple case where rounding error causes arange to produce a length-4 array when it should only produce 3 numbers:
>>> numpy.arange(1, 1.3, 0.1)
array([1. , 1.1, 1.2, 1.3])

"
Is there any way to kill a Thread?,https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread,1024,python;multithreading;python-multithreading;kill;terminate,"It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:

the thread is holding a critical resource that must be closed properly
the thread has created several other threads that must be killed as well.

The nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.
For example:
import threading

class StoppableThread(threading.Thread):
    """"""Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition.""""""

    def __init__(self,  *args, **kwargs):
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

In this code, you should call stop() on the thread when you want it to exit, and wait for the thread to exit properly using join(). The thread should check the stop flag at regular intervals.
There are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.
The following code allows (with some restrictions) to raise an Exception in a Python thread:
def _async_raise(tid, exctype):
    '''Raises an exception in the threads with id tid'''
    if not inspect.isclass(exctype):
        raise TypeError(""Only types can be raised (not instances)"")
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),
                                                     ctypes.py_object(exctype))
    if res == 0:
        raise ValueError(""invalid thread id"")
    elif res != 1:
        # ""if it returns a number greater than one, you're in trouble,
        # and you should call it again with exc=NULL to revert the effect""
        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), None)
        raise SystemError(""PyThreadState_SetAsyncExc failed"")

class ThreadWithExc(threading.Thread):
    '''A thread class that supports raising an exception in the thread from
       another thread.
    '''
    def _get_my_tid(self):
        """"""determines this (self's) thread id

        CAREFUL: this function is executed in the context of the caller
        thread, to get the identity of the thread represented by this
        instance.
        """"""
        if not self.is_alive(): # Note: self.isAlive() on older version of Python
            raise threading.ThreadError(""the thread is not active"")

        # do we have it cached?
        if hasattr(self, ""_thread_id""):
            return self._thread_id

        # no, look for it in the _active dict
        for tid, tobj in threading._active.items():
            if tobj is self:
                self._thread_id = tid
                return tid

        # TODO: in python 2.6, there's a simpler way to do: self.ident

        raise AssertionError(""could not determine the thread's id"")

    def raise_exc(self, exctype):
        """"""Raises the given exception type in the context of this thread.

        If the thread is busy in a system call (time.sleep(),
        socket.accept(), ...), the exception is simply ignored.

        If you are sure that your exception should terminate the thread,
        one way to ensure that it works is:

            t = ThreadWithExc( ... )
            ...
            t.raise_exc( SomeException )
            while t.isAlive():
                time.sleep( 0.1 )
                t.raise_exc( SomeException )

        If the exception is to be caught by the thread, you need a way to
        check that your thread has caught it.

        CAREFUL: this function is executed in the context of the
        caller thread, to raise an exception in the context of the
        thread represented by this instance.
        """"""
        _async_raise( self._get_my_tid(), exctype )

(Based on Killable Threads by Tomer Filiba. The quote about the return value of PyThreadState_SetAsyncExc appears to be from an old version of Python.)
As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.
A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.
"
Convert hex string to integer in Python,https://stackoverflow.com/questions/209513/convert-hex-string-to-integer-in-python,1014,python;string;hex,"Without the 0x prefix, you need to specify the base explicitly, otherwise there's no way to tell:
x = int(""deadbeef"", 16)

With the 0x prefix, Python can distinguish hex and decimal automatically:
>>> print(int(""0xdeadbeef"", 0))
3735928559
>>> print(int(""10"", 0))
10

(You must specify 0 as the base in order to invoke this prefix-guessing behavior; if you omit the second parameter, int() will assume base-10.)
"
Getting a list of all subdirectories in the current directory,https://stackoverflow.com/questions/973473/getting-a-list-of-all-subdirectories-in-the-current-directory,1007,python;directory;subdirectory,"Do you mean immediate subdirectories, or every directory right down the tree? 
Either way, you could use os.walk to do this:
os.walk(directory)

will yield a tuple for each subdirectory. Ths first entry in the 3-tuple is a directory name, so
[x[0] for x in os.walk(directory)]

should give you all of the subdirectories, recursively.
Note that the second entry in the tuple is the list of child directories of the entry in the first position, so you could use this instead, but it's not likely to save you much.
However, you could use it just to give you the immediate child directories:
next(os.walk('.'))[1]

Or see the other solutions already posted, using os.listdir and os.path.isdir, including those at ""How to get all of the immediate subdirectories in Python"".
"
How do I do a not equal in Django queryset filtering?,https://stackoverflow.com/questions/687295/how-do-i-do-a-not-equal-in-django-queryset-filtering,1006,python;django;django-models;django-queryset,"You can use Q objects for this. They can be negated with the ~ operator and combined much like normal Python expressions:
from myapp.models import Entry
from django.db.models import Q

Entry.objects.filter(~Q(id=3))

will return all entries except the one(s) with 3 as their ID:
[<Entry: Entry object>, <Entry: Entry object>, <Entry: Entry object>, ...]

"
"Writing a list to a file with Python, with newlines",https://stackoverflow.com/questions/899103/writing-a-list-to-a-file-with-python-with-newlines,1005,python;file;list;file-io;newline,"Use a loop:
with open('your_file.txt', 'w') as f:
    for line in lines:
        f.write(f""{line}\n"")

For Python <3.6:
with open('your_file.txt', 'w') as f:
    for line in lines:
        f.write(""%s\n"" % line)

For Python 2, one may also use:
with open('your_file.txt', 'w') as f:
    for line in lines:
        print >> f, line

If you're keen on a single function call, at least remove the square brackets [], so that the strings to be printed get made one at a time (a genexp rather than a listcomp) -- no reason to take up all the memory required to materialize the whole list of strings.
"
Peak detection in a 2D array,https://stackoverflow.com/questions/3684484/peak-detection-in-a-2d-array,1003,python;image-processing,"I detected the peaks using a local maximum filter. Here is the result on your first dataset of 4 paws:

I also ran it on the second dataset of 9 paws and it worked as well.
Here is how you do it:
import numpy as np
from scipy.ndimage.filters import maximum_filter
from scipy.ndimage.morphology import generate_binary_structure, binary_erosion
import matplotlib.pyplot as pp

#for some reason I had to reshape. Numpy ignored the shape header.
paws_data = np.loadtxt(""paws.txt"").reshape(4,11,14)

#getting a list of images
paws = [p.squeeze() for p in np.vsplit(paws_data,4)]


def detect_peaks(image):
    """"""
    Takes an image and detect the peaks usingthe local maximum filter.
    Returns a boolean mask of the peaks (i.e. 1 when
    the pixel's value is the neighborhood maximum, 0 otherwise)
    """"""

    # define an 8-connected neighborhood
    neighborhood = generate_binary_structure(2,2)

    #apply the local maximum filter; all pixel of maximal value 
    #in their neighborhood are set to 1
    local_max = maximum_filter(image, footprint=neighborhood)==image
    #local_max is a mask that contains the peaks we are 
    #looking for, but also the background.
    #In order to isolate the peaks we must remove the background from the mask.

    #we create the mask of the background
    background = (image==0)

    #a little technicality: we must erode the background in order to 
    #successfully subtract it form local_max, otherwise a line will 
    #appear along the background border (artifact of the local maximum filter)
    eroded_background = binary_erosion(background, structure=neighborhood, border_value=1)

    #we obtain the final mask, containing only peaks, 
    #by removing the background from the local_max mask (xor operation)
    detected_peaks = local_max ^ eroded_background

    return detected_peaks


#applying the detection and plotting results
for i, paw in enumerate(paws):
    detected_peaks = detect_peaks(paw)
    pp.subplot(4,2,(2*i+1))
    pp.imshow(paw)
    pp.subplot(4,2,(2*i+2) )
    pp.imshow(detected_peaks)

pp.show()

All you need to do after is use scipy.ndimage.measurements.label on the mask to label all distinct objects. Then you'll be able to play with them individually.
Note that the method works well because the background is not noisy. If it were, you would detect a bunch of other unwanted peaks in the background. Another important factor is the size of the neighborhood. You will need to adjust it if the peak size changes (the should remain roughly proportional).
"
Is there a list of Pytz Timezones?,https://stackoverflow.com/questions/13866926/is-there-a-list-of-pytz-timezones,1002,python;django;datetime;timezone;pytz,"You can list all the available timezones with pytz.all_timezones:
In [40]: import pytz
In [41]: pytz.all_timezones
Out[42]: 
['Africa/Abidjan',
 'Africa/Accra',
 'Africa/Addis_Ababa',
 ...]

There is also pytz.common_timezones:
In [45]: len(pytz.common_timezones)
Out[45]: 403

In [46]: len(pytz.all_timezones)
Out[46]: 563

"
How are iloc and loc different?,https://stackoverflow.com/questions/31593201/how-are-iloc-and-loc-different,1000,python;pandas;dataframe;indexing;pandas-loc,"Label vs. Location
The main distinction between the two methods is:

loc gets rows (and/or columns) with particular labels.

iloc gets rows (and/or columns) at integer locations.


To demonstrate, consider a series s of characters with a non-monotonic integer index:
>>> s = pd.Series(list(""abcdef""), index=[49, 48, 47, 0, 1, 2]) 
49    a
48    b
47    c
0     d
1     e
2     f

>>> s.loc[0]    # value at index label 0
'd'

>>> s.iloc[0]   # value at index location 0
'a'

>>> s.loc[0:1]  # rows at index labels between 0 and 1 (inclusive)
0    d
1    e

>>> s.iloc[0:1] # rows at index location between 0 and 1 (exclusive)
49    a

Here are some of the differences/similarities between s.loc and s.iloc when passed various objects:




<object>
description
s.loc[<object>]
s.iloc[<object>]




0
single item
Value at index label 0 (the string 'd')
Value at index location 0 (the string 'a')


0:1
slice
Two rows (labels 0 and 1)
One row (first row at location 0)


1:47
slice with out-of-bounds end
Zero rows (empty Series)
Five rows (location 1 onwards)


1:47:-1
slice with negative step
three rows (labels 1 back to 47)
Zero rows (empty Series)


[2, 0]
integer list
Two rows with given labels
Two rows with given locations


s > 'e'
Bool series (indicating which values have the property)
One row (containing 'f')
NotImplementedError


(s>'e').values
Bool array
One row (containing 'f')
Same as loc


999
int object not in index
KeyError
IndexError (out of bounds)


-1
int object not in index
KeyError
Returns last value in s


lambda x: x.index[3]
callable applied to series (here returning 3rd item in index)
s.loc[s.index[3]]
s.iloc[s.index[3]]




loc's label-querying capabilities extend well-beyond integer indexes and it's worth highlighting a couple of additional examples.
Here's a Series where the index contains string objects:
>>> s2 = pd.Series(s.index, index=s.values)
>>> s2
a    49
b    48
c    47
d     0
e     1
f     2

Since loc is label-based, it can fetch the first value in the Series using s2.loc['a']. It can also slice with non-integer objects:
>>> s2.loc['c':'e']  # all rows lying between 'c' and 'e' (inclusive)
c    47
d     0
e     1

For DateTime indexes, we don't need to pass the exact date/time to fetch by label. For example:
>>> s3 = pd.Series(list('abcde'), pd.date_range('now', periods=5, freq='M')) 
>>> s3
2021-01-31 16:41:31.879768    a
2021-02-28 16:41:31.879768    b
2021-03-31 16:41:31.879768    c
2021-04-30 16:41:31.879768    d
2021-05-31 16:41:31.879768    e

Then to fetch the row(s) for March/April 2021 we only need:
>>> s3.loc['2021-03':'2021-04']
2021-03-31 17:04:30.742316    c
2021-04-30 17:04:30.742316    d

Rows and Columns
loc and iloc work the same way with DataFrames as they do with Series. It's useful to note that both methods can address columns and rows together.
When given a tuple, the first element is used to index the rows and, if it exists, the second element is used to index the columns.
Consider the DataFrame defined below:
>>> import numpy as np 
>>> df = pd.DataFrame(np.arange(25).reshape(5, 5),  
                      index=list('abcde'), 
                      columns=['x','y','z', 8, 9])
>>> df
    x   y   z   8   9
a   0   1   2   3   4
b   5   6   7   8   9
c  10  11  12  13  14
d  15  16  17  18  19
e  20  21  22  23  24

Then for example:
>>> df.loc['c': , :'z']  # rows 'c' and onwards AND columns up to 'z'
    x   y   z
c  10  11  12
d  15  16  17
e  20  21  22

>>> df.iloc[:, 3]        # all rows, but only the column at index location 3
a     3
b     8
c    13
d    18
e    23

Sometimes we want to mix label and positional indexing methods for the rows and columns, somehow combining the capabilities of loc and iloc.
For example, consider the following DataFrame. How best to slice the rows up to and including 'c' and take the first four columns?
>>> import numpy as np 
>>> df = pd.DataFrame(np.arange(25).reshape(5, 5),  
                      index=list('abcde'), 
                      columns=['x','y','z', 8, 9])
>>> df
    x   y   z   8   9
a   0   1   2   3   4
b   5   6   7   8   9
c  10  11  12  13  14
d  15  16  17  18  19
e  20  21  22  23  24

We can achieve this result using iloc and the help of another method:
>>> df.iloc[:df.index.get_loc('c') + 1, :4]
    x   y   z   8
a   0   1   2   3
b   5   6   7   8
c  10  11  12  13

get_loc() is an index method meaning ""get the position of the label in this index"". Note that since slicing with iloc is exclusive of its endpoint, we must add 1 to this value if we want row 'c' as well.
"
Fixed digits after decimal with f-strings,https://stackoverflow.com/questions/45310254/fixed-digits-after-decimal-with-f-strings,998,python;python-3.x;f-string,"Include the type specifier in your format expression:
>>> a = 10.1234
>>> f'{a:.2f}'
'10.12'

"
Remove empty strings from a list of strings,https://stackoverflow.com/questions/3845423/remove-empty-strings-from-a-list-of-strings,996,python;string;list,"I would use filter:
str_list = filter(None, str_list)
str_list = filter(bool, str_list)
str_list = filter(len, str_list)
str_list = filter(lambda item: item, str_list)

Python 3 returns an iterator from filter, so should be wrapped in a call to list()
str_list = list(filter(None, str_list))

"
How to identify which OS Python is running on,https://stackoverflow.com/questions/1854/how-to-identify-which-os-python-is-running-on,996,python;operating-system;cross-platform;platform-agnostic,">>> import os

>>> os.name
'posix'

>>> import platform

>>> platform.system()
'Linux'

>>> platform.release()
'2.6.22-15-generic'

The output of platform.system() is as follows:

Linux: Linux
Mac: Darwin
Windows: Windows

See: platform — Access to underlying platform’s identifying data
"
List comprehension vs map,https://stackoverflow.com/questions/1247486/list-comprehension-vs-map,995,python;list-comprehension;map-function,"map may be microscopically faster in some cases (when you're not making a lambda for the purpose, but using the same function in map and a list comprehension). List comprehensions may be faster in other cases and most (not all) Pythonistas consider them more direct and clearer.
An example of the tiny speed advantage of map when using exactly the same function:
$ python -m timeit -s'xs=range(10)' 'map(hex, xs)'
100000 loops, best of 3: 4.86 usec per loop

$ python -m timeit -s'xs=range(10)' '[hex(x) for x in xs]'
100000 loops, best of 3: 5.58 usec per loop

An example of how performance comparison gets completely reversed when map needs a lambda:
$ python -m timeit -s'xs=range(10)' 'map(lambda x: x+2, xs)'
100000 loops, best of 3: 4.24 usec per loop

$ python -m timeit -s'xs=range(10)' '[x+2 for x in xs]'
100000 loops, best of 3: 2.32 usec per loop

"
Get key by value in dictionary,https://stackoverflow.com/questions/8023306/get-key-by-value-in-dictionary,991,python;dictionary,"There is none. dict is not intended to be used this way.
dictionary = {'george': 16, 'amber': 19}
search_age = input(""Provide age"")
for name, age in dictionary.items():  # for name, age in dictionary.iteritems():  (for Python 2.x)
    if age == search_age:
        print(name)

"
How do I update/upgrade pip itself from inside my virtual environment?,https://stackoverflow.com/questions/15221473/how-do-i-update-upgrade-pip-itself-from-inside-my-virtual-environment,990,python;upgrade;virtualenv;pip;package-managers,"pip is just a PyPI package like any other; you could use it to upgrade itself the same way you would upgrade any package:
pip install --upgrade pip

On Windows the recommended command is:
py -m pip install --upgrade pip

"
What does -&gt; mean in Python function definitions?,https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions,989,python;python-typing;grammar;function-definition,"It's a function annotation.
In more detail, Python 2.x has docstrings, which allow you to attach a metadata string to various types of object. This is amazingly handy, so Python 3 extends the feature by allowing you to attach metadata to functions describing their parameters and return values.
There's no preconceived use case, but the PEP suggests several. One very handy one is to allow you to annotate parameters with their expected types; it would then be easy to write a decorator that verifies the annotations or coerces the arguments to the right type. Another is to allow parameter-specific documentation instead of encoding it into the docstring.
"
How can I use Python to get the system hostname?,https://stackoverflow.com/questions/4271740/how-can-i-use-python-to-get-the-system-hostname,987,python;hostname,"Use socket and its gethostname() functionality. This will get the hostname of the computer where the Python interpreter is running:
import socket
print(socket.gethostname())

"
How are lambdas useful?,https://stackoverflow.com/questions/890128/how-are-lambdas-useful,986,python;function;lambda;closures,"Are you talking about lambda expressions? Like
lambda x: x**2 + 2*x - 5

Those things are actually quite useful.  Python supports a style of programming called functional programming where you can pass functions to other functions to do stuff. Example:
mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])

sets mult3 to [3, 6, 9], those elements of the original list that are multiples of 3. This is shorter (and, one could argue, clearer) than
def filterfunc(x):
    return x % 3 == 0
mult3 = filter(filterfunc, [1, 2, 3, 4, 5, 6, 7, 8, 9])

Of course, in this particular case, you could do the same thing as a list comprehension:
mult3 = [x for x in [1, 2, 3, 4, 5, 6, 7, 8, 9] if x % 3 == 0]

(or even as range(3,10,3)), but there are many other, more sophisticated use cases where you can't use a list comprehension and a lambda function may be the shortest way to write something out.

Returning a function from another function
  >>> def transform(n):
  ...     return lambda x: x + n
  ...
  >>> f = transform(3)
  >>> f(4)
  7

This is often used to create function wrappers, such as Python's decorators.

Combining elements of an iterable sequence with reduce()
  >>> reduce(lambda a, b: '{}, {}'.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])
  '1, 2, 3, 4, 5, 6, 7, 8, 9'


Sorting by an alternate key
  >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))
  [5, 4, 6, 3, 7, 2, 8, 1, 9]



I use lambda functions on a regular basis. It took me a while to get used to them, but eventually I came to understand that they're a very valuable part of the language.
"
What is the best project structure for a Python application?,https://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application,984,python;directory-structure;organization;project-structure,"Doesn't too much matter.  Whatever makes you happy will work.  There aren't a lot of silly rules because Python projects can be simple.

/scripts or /bin for that kind of command-line interface stuff
/tests for your tests
/lib for your C-language libraries
/doc for most documentation
/apidoc for the Epydoc-generated API docs.

And the top-level directory can contain README's, Config's and whatnot.
The hard choice is whether or not to use a /src tree.  Python doesn't have a distinction between /src, /lib, and /bin like Java or C has.
Since a top-level /src directory is seen by some as meaningless, your top-level directory can be the top-level architecture of your application.

/foo
/bar
/baz

I recommend putting all of this under the ""name-of-my-product"" directory.  So, if you're writing an application named quux, the directory that contains all this stuff is named  /quux.
Another project's PYTHONPATH, then, can include /path/to/quux/foo to reuse the QUUX.foo module.  
In my case, since I use Komodo Edit, my IDE cuft is a single .KPF file.  I actually put that in the top-level /quux directory, and omit adding it to SVN.
"
How can I open multiple files using &quot;with open&quot; in Python?,https://stackoverflow.com/questions/4617034/how-can-i-open-multiple-files-using-with-open-in-python,982,python;file-io,
How do I detect whether a variable is a function?,https://stackoverflow.com/questions/624926/how-do-i-detect-whether-a-variable-is-a-function,981,python,
open() in Python does not create a file if it doesn&#39;t exist,https://stackoverflow.com/questions/2967194/open-in-python-does-not-create-a-file-if-it-doesnt-exist,980,python;linux;file-io;file-permissions,
Why use pip over easy_install?,https://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install,979,python;pip;setuptools;easy-install;pypi,
What is a clean &quot;pythonic&quot; way to implement multiple constructors?,https://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-implement-multiple-constructors,977,python;class;constructor,
What does the &quot;at&quot; (@) symbol do in Python?,https://stackoverflow.com/questions/6392739/what-does-the-at-symbol-do-in-python,976,python;syntax,
Find a value in a list,https://stackoverflow.com/questions/9542738/find-a-value-in-a-list,968,python;list;find,
How to properly ignore exceptions,https://stackoverflow.com/questions/730764/how-to-properly-ignore-exceptions,968,python;exception;try-except,
python exception message capturing,https://stackoverflow.com/questions/4690600/python-exception-message-capturing,967,python;exception;logging;except;python-logging,
List of lists changes reflected across sublists unexpectedly,https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly,967,python;list;nested-lists;mutable,
How to import the class within the same directory or sub directory?,https://stackoverflow.com/questions/4142151/how-to-import-the-class-within-the-same-directory-or-sub-directory,966,python;python-import,
How to see normal stdout/stderr console print() output from code during a pytest run?,https://stackoverflow.com/questions/14405063/how-to-see-normal-stdout-stderr-console-print-output-from-code-during-a-pytest,964,python;pytest;stdout;flags,
"Saving UTF-8 texts with json.dumps as UTF-8, not as a \u escape sequence",https://stackoverflow.com/questions/18337407/saving-utf-8-texts-with-json-dumps-as-utf-8-not-as-a-u-escape-sequence,962,python;json;unicode;utf-8;escaping,
How can I iterate over files in a given directory?,https://stackoverflow.com/questions/10377998/how-can-i-iterate-over-files-in-a-given-directory,958,python;iterator;directory,
How to disable Python warnings?,https://stackoverflow.com/questions/14463277/how-to-disable-python-warnings,957,python;suppress-warnings,
Shuffling a list of objects,https://stackoverflow.com/questions/976882/shuffling-a-list-of-objects,956,python;list;random;shuffle,
How to make IPython notebook matplotlib plot inline,https://stackoverflow.com/questions/19410042/how-to-make-ipython-notebook-matplotlib-plot-inline,955,python;matplotlib;jupyter-notebook;ipython;data-visualization,
pip install mysql-python fails with EnvironmentError: mysql_config not found,https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found,954,python;pip;mysql-python,
Python setup.py uninstall,https://stackoverflow.com/questions/1550226/python-setup-py-uninstall,949,python;setup.py;pypi,
Print string to text file,https://stackoverflow.com/questions/5214578/print-string-to-text-file,948,python;string;text;file-io,
not None test in Python,https://stackoverflow.com/questions/3965104/not-none-test-in-python,946,python;nonetype,
Pandas Merging 101,https://stackoverflow.com/questions/53645882/pandas-merging-101,946,python;pandas;join;merge;concatenation,
"What is __future__ in Python used for and how/when to use it, and how it works",https://stackoverflow.com/questions/7075082/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works,946,python;python-2.x,
Why is python setup.py saying invalid command &#39;bdist_wheel&#39; on Travis CI?,https://stackoverflow.com/questions/34819221/why-is-python-setup-py-saying-invalid-command-bdist-wheel-on-travis-ci,940,python;travis-ci;setup.py;pypi,
Why does Python code run faster in a function?,https://stackoverflow.com/questions/11241523/why-does-python-code-run-faster-in-a-function,938,python;performance;profiling;benchmarking;cpython,
How to sort a list/tuple of lists/tuples by the element at a given index,https://stackoverflow.com/questions/3121979/how-to-sort-a-list-tuple-of-lists-tuples-by-the-element-at-a-given-index,935,python;list;sorting;tuples,
How to change the font size on a matplotlib plot,https://stackoverflow.com/questions/3899980/how-to-change-the-font-size-on-a-matplotlib-plot,932,python;matplotlib;font-size,
How do I get the day of week given a date?,https://stackoverflow.com/questions/9847213/how-do-i-get-the-day-of-week-given-a-date,932,python;date;datetime;time;weekday,
How to remove items from a list while iterating?,https://stackoverflow.com/questions/1207406/how-to-remove-items-from-a-list-while-iterating,931,python;iteration,
How do I set the figure title and axes labels font size?,https://stackoverflow.com/questions/12444716/how-do-i-set-the-figure-title-and-axes-labels-font-size,931,python;matplotlib;axis-labels;yaxis;x-axis,
Get the last day of the month,https://stackoverflow.com/questions/42950/get-the-last-day-of-the-month,928,python;date,
Create an empty list with certain size in Python,https://stackoverflow.com/questions/10712002/create-an-empty-list-with-certain-size-in-python,927,python;list,
Argparse optional positional arguments?,https://stackoverflow.com/questions/4480075/argparse-optional-positional-arguments,927,python;command-line-arguments;argparse,
How to use multiprocessing pool.map with multiple arguments,https://stackoverflow.com/questions/5442910/how-to-use-multiprocessing-pool-map-with-multiple-arguments,924,python;multiprocessing;python-multiprocessing,
How to convert string representation of list to a list,https://stackoverflow.com/questions/1894269/how-to-convert-string-representation-of-list-to-a-list,923,python;string;list;text-parsing,
"How do I print the full NumPy array, without truncation?",https://stackoverflow.com/questions/1987694/how-do-i-print-the-full-numpy-array-without-truncation,922,python;arrays;numpy;output-formatting,
How to create a zip archive of a directory?,https://stackoverflow.com/questions/1855095/how-to-create-a-zip-archive-of-a-directory,921,python;zip;archive;python-zipfile,
"&quot;TypeError: a bytes-like object is required, not &#39;str&#39;&quot; when handling file content in Python 3",https://stackoverflow.com/questions/33054527/typeerror-a-bytes-like-object-is-required-not-str-when-handling-file-conte,921,python;python-3.x;string;file;byte,
"What exactly do &quot;u&quot; and &quot;r&quot; string prefixes do, and what are raw string literals?",https://stackoverflow.com/questions/2081640/what-exactly-do-u-and-r-string-prefixes-do-and-what-are-raw-string-literals,921,python;unicode;python-2.x;rawstring,
How to define a two-dimensional array?,https://stackoverflow.com/questions/6667201/how-to-define-a-two-dimensional-array,919,python;list;multidimensional-array,
"Creating an empty Pandas DataFrame, and then filling it",https://stackoverflow.com/questions/13784192/creating-an-empty-pandas-dataframe-and-then-filling-it,918,python;pandas;dataframe,
How do I properly assert that an exception gets raised in pytest?,https://stackoverflow.com/questions/23337471/how-do-i-properly-assert-that-an-exception-gets-raised-in-pytest,911,python;unit-testing;exception;testing;pytest,
Can I force pip to reinstall the current version?,https://stackoverflow.com/questions/19548957/can-i-force-pip-to-reinstall-the-current-version,911,python;pip;package,
What is monkey patching?,https://stackoverflow.com/questions/5626193/what-is-monkey-patching,911,python;terminology;monkeypatching,
Unzipping files in Python,https://stackoverflow.com/questions/3451111/unzipping-files-in-python,909,python;zip;unzip;python-zipfile,
"Difference between modes a, a+, w, w+, and r+ in built-in open function",https://stackoverflow.com/questions/1466000/difference-between-modes-a-a-w-w-and-r-in-built-in-open-function,908,python;file,
How to list all available package versions with pip?,https://stackoverflow.com/questions/4888027/how-to-list-all-available-package-versions-with-pip,907,python;pip,
Styling multi-line conditions in &#39;if&#39; statements?,https://stackoverflow.com/questions/181530/styling-multi-line-conditions-in-if-statements,901,python;if-statement,
Shuffle DataFrame rows,https://stackoverflow.com/questions/29576430/shuffle-dataframe-rows,898,python;pandas;dataframe;permutation;shuffle,
How to filter Pandas dataframe using &#39;in&#39; and &#39;not in&#39; like in SQL,https://stackoverflow.com/questions/19960077/how-to-filter-pandas-dataframe-using-in-and-not-in-like-in-sql,895,python;pandas;dataframe;indexing;filter,
"Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()",https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o,895,python;pandas;filter;conditional-statements;valueerror,
What does the Ellipsis object do?,https://stackoverflow.com/questions/772124/what-does-the-ellipsis-object-do,893,python;ellipsis,
How to check if a string is a substring of items in a list of strings,https://stackoverflow.com/questions/4843158/how-to-check-if-a-string-is-a-substring-of-items-in-a-list-of-strings,889,python;string;list,
Using Python 3 in virtualenv,https://stackoverflow.com/questions/23842713/using-python-3-in-virtualenv,888,python;python-3.x;virtualenv,
How do I remove/delete a virtualenv?,https://stackoverflow.com/questions/11005457/how-do-i-remove-delete-a-virtualenv,882,python;virtualenv;python-venv;virtualenv-commands,
How can I capitalize the first letter of each word in a string?,https://stackoverflow.com/questions/1549641/how-can-i-capitalize-the-first-letter-of-each-word-in-a-string,879,python;capitalization;capitalize,
How do I generate all permutations of a list?,https://stackoverflow.com/questions/104420/how-do-i-generate-all-permutations-of-a-list,873,python;algorithm;permutation;combinatorics,
What is the intended use of the optional &quot;else&quot; clause of the &quot;try&quot; statement in Python?,https://stackoverflow.com/questions/855759/what-is-the-intended-use-of-the-optional-else-clause-of-the-try-statement-in,873,python;exception,
"Constructing DataFrame from values in variables yields &quot;ValueError: If using all scalar values, you must pass an index&quot;",https://stackoverflow.com/questions/17839973/constructing-dataframe-from-values-in-variables-yields-valueerror-if-using-all,867,python;pandas;dataframe;constructor;valueerror,
Adding a method to an existing object instance in Python,https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object-instance-in-python,867,python;oop;methods;monkeypatching,
What&#39;s the difference between a module and package in Python?,https://stackoverflow.com/questions/7948494/whats-the-difference-between-a-module-and-package-in-python,864,python;module;package;terminology;difference,
What is the difference between range and xrange functions in Python 2.X?,https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x,863,python;loops;range;python-2.x;xrange,
Best way to strip punctuation from a string,https://stackoverflow.com/questions/265960/best-way-to-strip-punctuation-from-a-string,862,python;string;punctuation,
How do I change the working directory in Python?,https://stackoverflow.com/questions/431684/how-do-i-change-the-working-directory-in-python,862,python;path;cd,
How to delete the contents of a folder?,https://stackoverflow.com/questions/185936/how-to-delete-the-contents-of-a-folder,861,python;file,
How can I temporarily disable a foreign key constraint in MySQL?,https://stackoverflow.com/questions/15501673/how-can-i-temporarily-disable-a-foreign-key-constraint-in-mysql,860,python;sql;mysql;django;django-models,
How to update/upgrade a package using pip?,https://stackoverflow.com/questions/47071256/how-to-update-upgrade-a-package-using-pip,860,python;pip,
Split Strings into words with multiple word boundary delimiters,https://stackoverflow.com/questions/1059559/split-strings-into-words-with-multiple-word-boundary-delimiters,859,python;string;split,
What is the purpose and use of **kwargs?,https://stackoverflow.com/questions/1769403/what-is-the-purpose-and-use-of-kwargs,859,python;keyword-argument,
How to make a datetime object aware (not naive)?,https://stackoverflow.com/questions/7065164/how-to-make-a-datetime-object-aware-not-naive,858,python;timezone;python-datetime;python-2.6;pytz,
How to convert index of a pandas dataframe into a column,https://stackoverflow.com/questions/20461165/how-to-convert-index-of-a-pandas-dataframe-into-a-column,858,python;pandas;dataframe;join;indexing,
Why are Python&#39;s &#39;private&#39; methods not actually private?,https://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private,855,python;encapsulation;information-hiding,
How to fix &quot;Attempted relative import in non-package&quot; even with __init__.py,https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py,853,python;package;python-import;importerror;init,
How to test multiple variables for equality against a single value?,https://stackoverflow.com/questions/15112125/how-to-test-multiple-variables-for-equality-against-a-single-value,851,python;if-statement;comparison;match;boolean-logic,
How to print instances of a class using print()?,https://stackoverflow.com/questions/1535327/how-to-print-instances-of-a-class-using-print,847,python;class;printing;object,
Convert int to binary string in Python,https://stackoverflow.com/questions/699866/convert-int-to-binary-string-in-python,846,python;binary;string.format,
How to find out the number of CPUs using python,https://stackoverflow.com/questions/1006289/how-to-find-out-the-number-of-cpus-using-python,846,python;system-information,
Which exception should I raise on bad/illegal argument combinations in Python?,https://stackoverflow.com/questions/256222/which-exception-should-i-raise-on-bad-illegal-argument-combinations-in-python,844,python;exception;arguments,
What is the Python equivalent of static variables inside a function?,https://stackoverflow.com/questions/279561/what-is-the-python-equivalent-of-static-variables-inside-a-function,842,python;static,
What is the best way to remove accents (normalize) in a Python unicode string?,https://stackoverflow.com/questions/517923/what-is-the-best-way-to-remove-accents-normalize-in-a-python-unicode-string,842,python;python-3.x;unicode;python-2.x;diacritics,
How do I call a parent class&#39;s method from a child class in Python?,https://stackoverflow.com/questions/805066/how-do-i-call-a-parent-classs-method-from-a-child-class-in-python,841,python;class;oop;object;inheritance,
How do you round UP a number?,https://stackoverflow.com/questions/2356501/how-do-you-round-up-a-number,840,python;floating-point;integer;rounding,
How can I read and process (parse) command line arguments?,https://stackoverflow.com/questions/1009860/how-can-i-read-and-process-parse-command-line-arguments,840,python;command-line;command-line-arguments,
How do I call a function from another .py file?,https://stackoverflow.com/questions/20309456/how-do-i-call-a-function-from-another-py-file,839,python;file;function;import,
How to combine multiple QuerySets in Django?,https://stackoverflow.com/questions/431628/how-to-combine-multiple-querysets-in-django,837,python;django;search;django-queryset;django-q,
How to serve static files in Flask,https://stackoverflow.com/questions/20646822/how-to-serve-static-files-in-flask,836,python;flask;static-files,
How do I get indices of N maximum values in a NumPy array?,https://stackoverflow.com/questions/6910641/how-do-i-get-indices-of-n-maximum-values-in-a-numpy-array,835,python;numpy;max;numpy-ndarray,
Collections.defaultdict difference with normal dict,https://stackoverflow.com/questions/5900578/collections-defaultdict-difference-with-normal-dict,835,python;dictionary;default-value;defaultdict,
How to state in requirements.txt a direct github source,https://stackoverflow.com/questions/16584552/how-to-state-in-requirements-txt-a-direct-github-source,834,python;github;pip;requirements.txt,
How can I pass a list as a command-line argument with argparse?,https://stackoverflow.com/questions/15753701/how-can-i-pass-a-list-as-a-command-line-argument-with-argparse,832,python;argparse,
How do I get the current time in milliseconds in Python?,https://stackoverflow.com/questions/5998245/how-do-i-get-the-current-time-in-milliseconds-in-python,832,python;datetime;time,
How to urlencode a querystring in Python?,https://stackoverflow.com/questions/5607551/how-to-urlencode-a-querystring-in-python,828,python;urllib;urlencode,
How to print a date in a regular format?,https://stackoverflow.com/questions/311627/how-to-print-a-date-in-a-regular-format,828,python;date;datetime;formatting,
How do I wait for a pressed key?,https://stackoverflow.com/questions/983354/how-do-i-wait-for-a-pressed-key,827,python;wait;keyboard-input,
Split string with multiple delimiters in Python,https://stackoverflow.com/questions/4998629/split-string-with-multiple-delimiters-in-python,824,python;string;split;delimiter,
Why shouldn&#39;t I use PyPy over CPython if PyPy is 6.3 times faster?,https://stackoverflow.com/questions/18946662/why-shouldnt-i-use-pypy-over-cpython-if-pypy-is-6-3-times-faster,824,python;performance;jit;pypy;cpython,
Convert all strings in a list to integers,https://stackoverflow.com/questions/7368789/convert-all-strings-in-a-list-to-integers,822,python;string;list;integer,
Where does pip install its packages?,https://stackoverflow.com/questions/29980798/where-does-pip-install-its-packages,821,python;pip;virtualenv,
Dump a NumPy array into a csv file,https://stackoverflow.com/questions/6081008/dump-a-numpy-array-into-a-csv-file,821,python;arrays;numpy;csv;file-io,
Filter dict to contain only certain keys?,https://stackoverflow.com/questions/3420122/filter-dict-to-contain-only-certain-keys,821,python;dictionary,
"Get statistics for each group (such as count, mean, etc) using pandas GroupBy?",https://stackoverflow.com/questions/19384532/get-statistics-for-each-group-such-as-count-mean-etc-using-pandas-groupby,818,python;pandas;dataframe;group-by;statistics,
Create list of single item repeated N times,https://stackoverflow.com/questions/3459098/create-list-of-single-item-repeated-n-times,818,python;list;list-comprehension;multiplication;replicate,
What do ** (double star/asterisk) and * (star/asterisk) mean in a function call?,https://stackoverflow.com/questions/2921847/what-do-double-star-asterisk-and-star-asterisk-mean-in-a-function-call,818,python;syntax;parameter-passing;iterable-unpacking;argument-unpacking,
How do I prepend to a short python list?,https://stackoverflow.com/questions/8537916/how-do-i-prepend-to-a-short-python-list,817,python;list;prepend,
How to change a string into uppercase?,https://stackoverflow.com/questions/9257094/how-to-change-a-string-into-uppercase,816,python;string;function;uppercase;string-conversion,
Append integer to beginning of list in Python,https://stackoverflow.com/questions/17911091/append-integer-to-beginning-of-list-in-python,811,python;list;prepend,
How do I protect Python code from being read by users?,https://stackoverflow.com/questions/261638/how-do-i-protect-python-code-from-being-read-by-users,810,python;licensing;obfuscation;copy-protection,
What is the purpose of the single underscore &quot;_&quot; variable in Python?,https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python,810,python;variables;naming-conventions;metasyntactic-variable,
"IndentationError: unindent does not match any outer indentation level, although the indentation looks correct",https://stackoverflow.com/questions/492387/indentationerror-unindent-does-not-match-any-outer-indentation-level-although,809,python;indentation;python-2.x,
How can the Euclidean distance be calculated with NumPy?,https://stackoverflow.com/questions/1401712/how-can-the-euclidean-distance-be-calculated-with-numpy,808,python;numpy;euclidean-distance,
How do I do a case-insensitive string comparison?,https://stackoverflow.com/questions/319426/how-do-i-do-a-case-insensitive-string-comparison,808,python;comparison;case-insensitive,
How to represent an infinite number in Python?,https://stackoverflow.com/questions/7781260/how-to-represent-an-infinite-number-in-python,806,python;infinite;infinity,
Import a module from a relative path,https://stackoverflow.com/questions/279237/import-a-module-from-a-relative-path,805,python;relative-path;python-import,
Set value for particular cell in pandas DataFrame using index,https://stackoverflow.com/questions/13842088/set-value-for-particular-cell-in-pandas-dataframe-using-index,804,python;pandas;dataframe;cell;nan,
Using @property versus getters and setters,https://stackoverflow.com/questions/6618002/using-property-versus-getters-and-setters,804,python;properties;getter-setter,
Why is [] faster than list()?,https://stackoverflow.com/questions/30216000/why-is-faster-than-list,800,python;performance;list;instantiation;literals,
How can I fill out a Python string with spaces?,https://stackoverflow.com/questions/5676646/how-can-i-fill-out-a-python-string-with-spaces,798,python;string;string-formatting;padding,
How to calculate number of days between two given dates,https://stackoverflow.com/questions/151199/how-to-calculate-number-of-days-between-two-given-dates,798,python;date;datetime,
What is the difference between __init__ and __call__?,https://stackoverflow.com/questions/9663562/what-is-the-difference-between-init-and-call,797,python;class;oop;object;callable-object,
Return a default value if a dictionary key is not available,https://stackoverflow.com/questions/6130768/return-a-default-value-if-a-dictionary-key-is-not-available,797,python;dictionary;key;nonetype,
How do I get my program to sleep for 50 milliseconds?,https://stackoverflow.com/questions/377454/how-do-i-get-my-program-to-sleep-for-50-milliseconds,797,python;timer;sleep;milliseconds,
How can I force division to be floating point? Division keeps rounding down to 0?,https://stackoverflow.com/questions/1267869/how-can-i-force-division-to-be-floating-point-division-keeps-rounding-down-to-0,796,python;floating-point;integer;division;python-2.x,
Why does python use &#39;else&#39; after for and while loops?,https://stackoverflow.com/questions/9979970/why-does-python-use-else-after-for-and-while-loops,792,python;if-statement;for-loop;for-else,
How do I log a Python error with debug information?,https://stackoverflow.com/questions/5191830/how-do-i-log-a-python-error-with-debug-information,792,python;exception;logging;python-logging,
Is there a portable way to get the current username in Python?,https://stackoverflow.com/questions/842059/is-there-a-portable-way-to-get-the-current-username-in-python,792,python;portability,
Changing the tick frequency on the x or y axis,https://stackoverflow.com/questions/12608788/changing-the-tick-frequency-on-the-x-or-y-axis,790,python;matplotlib;frequency;xticks;yticks,
Does Python have an ordered set?,https://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set,789,python;set,
Determine function name from within that function,https://stackoverflow.com/questions/5067604/determine-function-name-from-within-that-function,788,python;function;introspection,
Does Python have “private” variables in classes?,https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes,787,python;class;private,
Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2,https://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u,782,python;tensorflow;cpu;avx,
What is the difference between dict.items() and dict.iteritems() in Python 2?,https://stackoverflow.com/questions/10458437/what-is-the-difference-between-dict-items-and-dict-iteritems-in-python-2,782,python;dictionary;python-2.x,
Import multiple CSV files into pandas and concatenate into one DataFrame,https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe,780,python;pandas;csv;dataframe;concatenation,
Which Python memory profiler is recommended?,https://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended,776,python;performance;memory-management;profiling,
What is the quickest way to HTTP GET in Python?,https://stackoverflow.com/questions/645312/what-is-the-quickest-way-to-http-get-in-python,773,python;http;network-programming,
Are dictionaries ordered in Python 3.6+?,https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6,773,python;dictionary;python-3.6;python-internals,
Correct way to try/except using Python requests module?,https://stackoverflow.com/questions/16511337/correct-way-to-try-except-using-python-requests-module,770,python;exception;python-requests;request,
What is a &quot;slug&quot; in Django?,https://stackoverflow.com/questions/427102/what-is-a-slug-in-django,770,python;django;url;django-models;slug,
"When to use cla(), clf() or close() for clearing a plot",https://stackoverflow.com/questions/8213522/when-to-use-cla-clf-or-close-for-clearing-a-plot,770,python;matplotlib;plot,
How do I access command line arguments?,https://stackoverflow.com/questions/4033723/how-do-i-access-command-line-arguments,769,python;command-line;command-line-arguments,
How do I append one string to another in Python?,https://stackoverflow.com/questions/4435169/how-do-i-append-one-string-to-another-in-python,767,python;string;append,
Decorators with parameters?,https://stackoverflow.com/questions/5929107/decorators-with-parameters,766,python;function;parameters;arguments;decorator,
How can I break out of multiple loops?,https://stackoverflow.com/questions/189645/how-can-i-break-out-of-multiple-loops,764,python;nested-loops;break;control-flow,
Asking the user for input until they give a valid response,https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response,764,python;validation;input,
What does &#39;super&#39; do in Python? - difference between super().__init__() and explicit superclass __init__(),https://stackoverflow.com/questions/222877/what-does-super-do-in-python-difference-between-super-init-and-expl,764,python;oop;inheritance;multiple-inheritance;super,
Is arr.__len__() the preferred way to get the length of an array in Python?,https://stackoverflow.com/questions/518021/is-arr-len-the-preferred-way-to-get-the-length-of-an-array-in-python,761,python;arrays;methods,
"How do I convert seconds to hours, minutes and seconds?",https://stackoverflow.com/questions/775049/how-do-i-convert-seconds-to-hours-minutes-and-seconds,760,python;datetime,
How to rename a file using Python,https://stackoverflow.com/questions/2491222/how-to-rename-a-file-using-python,757,python;file-rename,
"How can I check if a string represents an int, without using try/except?",https://stackoverflow.com/questions/1265665/how-can-i-check-if-a-string-represents-an-int-without-using-try-except,753,python;string;integer,
How can I get a value from a cell of a dataframe?,https://stackoverflow.com/questions/16729574/how-can-i-get-a-value-from-a-cell-of-a-dataframe,751,python;pandas;dataframe;indexing;filter,
CSV file written with Python has blank lines between each row,https://stackoverflow.com/questions/3348460/csv-file-written-with-python-has-blank-lines-between-each-row,751,python;windows;csv,
"Difference between map, applymap and apply methods in Pandas",https://stackoverflow.com/questions/19798153/difference-between-map-applymap-and-apply-methods-in-pandas,751,python;pandas;dataframe;vectorization,
Finding local IP addresses using Python&#39;s stdlib,https://stackoverflow.com/questions/166506/finding-local-ip-addresses-using-pythons-stdlib,749,python;network-programming;ip-address,
How to check if any value is NaN in a Pandas DataFrame,https://stackoverflow.com/questions/29530232/how-to-check-if-any-value-is-nan-in-a-pandas-dataframe,749,python;pandas;dataframe;nan,
Dealing with multiple Python versions and PIP,https://stackoverflow.com/questions/2812520/dealing-with-multiple-python-versions-and-pip,749,python;pip,
Making Python loggers output all messages to stdout in addition to log file,https://stackoverflow.com/questions/14058453/making-python-loggers-output-all-messages-to-stdout-in-addition-to-log-file,748,python;logging;error-logging;python-logging,
"In practice, what are the main uses for the &quot;yield from&quot; syntax in Python 3.3?",https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-yield-from-syntax-in-python-3-3,748,python;yield,
Sort a list by multiple attributes?,https://stackoverflow.com/questions/4233476/sort-a-list-by-multiple-attributes,747,python;sorting,
Speed comparison with Project Euler: C vs Python vs Erlang vs Haskell,https://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell,744,python;c;performance;haskell;erlang,
"What is the maximum recursion depth, and how to increase it?",https://stackoverflow.com/questions/3323001/what-is-the-maximum-recursion-depth-and-how-to-increase-it,744,python;recursion;limit;stack-overflow;sys,
How to install psycopg2 with &quot;pip&quot; on Python?,https://stackoverflow.com/questions/5420789/how-to-install-psycopg2-with-pip-on-python,741,python;virtualenv;psycopg2;pip,
How to set the current working directory?,https://stackoverflow.com/questions/1810743/how-to-set-the-current-working-directory,739,python;working-directory,
How to check if a dictionary is empty?,https://stackoverflow.com/questions/23177439/how-to-check-if-a-dictionary-is-empty,734,python;dictionary,
Finding the average of a list,https://stackoverflow.com/questions/9039961/finding-the-average-of-a-list,733,python;list;average;mean;reduce,
Getting the index of the returned max or min item using max()/min() on a list,https://stackoverflow.com/questions/2474015/getting-the-index-of-the-returned-max-or-min-item-using-max-min-on-a-list,733,python;list;max;min;argmax,
How can I use pickle to save a dict (or any other Python object)?,https://stackoverflow.com/questions/11218477/how-can-i-use-pickle-to-save-a-dict-or-any-other-python-object,732,python;dictionary;pickle,
How do I find the duplicates in a list and create another list with them?,https://stackoverflow.com/questions/9835762/how-do-i-find-the-duplicates-in-a-list-and-create-another-list-with-them,731,python;list;duplicates,
Is there a simple way to remove multiple spaces in a string?,https://stackoverflow.com/questions/1546226/is-there-a-simple-way-to-remove-multiple-spaces-in-a-string,730,python;regex;string,
Configure Flask dev server to be visible across the network,https://stackoverflow.com/questions/7023052/configure-flask-dev-server-to-be-visible-across-the-network,729,python;flask;werkzeug,
How to extract numbers from a string in Python?,https://stackoverflow.com/questions/4289331/how-to-extract-numbers-from-a-string-in-python,728,python;string;numbers,
How do I capture SIGINT in Python?,https://stackoverflow.com/questions/1112343/how-do-i-capture-sigint-in-python,728,python;signals,
Remove specific characters from a string in Python,https://stackoverflow.com/questions/3939361/remove-specific-characters-from-a-string-in-python,727,python;string;replace;immutability,
How to check Django version,https://stackoverflow.com/questions/6468397/how-to-check-django-version,725,python;django;command-line;command;version,
How would you make a comma-separated string from a list of strings?,https://stackoverflow.com/questions/44778/how-would-you-make-a-comma-separated-string-from-a-list-of-strings,724,python;string;list,
How can I import a module dynamically given its name as string?,https://stackoverflow.com/questions/301134/how-can-i-import-a-module-dynamically-given-its-name-as-string,724,python;python-import,
Python &quot;extend&quot; for a dictionary,https://stackoverflow.com/questions/577234/python-extend-for-a-dictionary,723,python;dictionary,
No module named pkg_resources,https://stackoverflow.com/questions/7446187/no-module-named-pkg-resources,723,python;django;virtualenv;setuptools;pip,
